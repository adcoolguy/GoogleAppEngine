/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(1);
	var angular = __webpack_require__(5);
	__webpack_require__(6);
	__webpack_require__(8);
	console.log('entry.js: app booted!');

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../react/node_modules/css-loader/index.js!./milligram.css", function() {
				var newContent = require("!!./../../../../react/node_modules/css-loader/index.js!./milligram.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports


	// module
	exports.push([module.id, "/*!\n * Milligram v1.1.0\n * http://milligram.github.io\n *\n * Copyright (c) 2016 CJ Patoilo\n * Licensed under the MIT license\n*/\n\n\nhtml {\n  box-sizing: border-box;\n  font-size: 62.5%;\n}\n\nbody {\n  color: #606c76;\n  font-family: \"Roboto\", \"Helvetica Neue\", \"Helvetica\", \"Arial\", sans-serif;\n  font-size: 1.6em;\n  font-weight: 300;\n  letter-spacing: 0.01em;\n  line-height: 1.6;\n}\n\n*,\n*:after,\n*:before {\n  box-sizing: inherit;\n}\n\nblockquote {\n  border-left: 0.3rem solid #d1d1d1;\n  margin-left: 0;\n  margin-right: 0;\n  padding: 1rem 1.5rem;\n}\nblockquote *:last-child {\n  margin: 0;\n}\n\n.button,\nbutton,\ninput[type='button'],\ninput[type='reset'],\ninput[type='submit'] {\n  background-color: #9b4dca;\n  border: 0.1rem solid #9b4dca;\n  border-radius: 0.4rem;\n  color: #fff;\n  cursor: pointer;\n  display: inline-block;\n  font-size: 1.1rem;\n  font-weight: 700;\n  height: 3.8rem;\n  letter-spacing: 0.1rem;\n  line-height: 3.8rem;\n  padding: 0 3rem;\n  text-align: center;\n  text-decoration: none;\n  text-transform: uppercase;\n  white-space: nowrap;\n}\n.button:hover, .button:focus,\nbutton:hover,\nbutton:focus,\ninput[type='button']:hover,\ninput[type='button']:focus,\ninput[type='reset']:hover,\ninput[type='reset']:focus,\ninput[type='submit']:hover,\ninput[type='submit']:focus {\n  background-color: #606c76;\n  border-color: #606c76;\n  color: #fff;\n  outline: 0;\n}\n.button.button-disabled, .button[disabled],\nbutton.button-disabled,\nbutton[disabled],\ninput[type='button'].button-disabled,\ninput[type='button'][disabled],\ninput[type='reset'].button-disabled,\ninput[type='reset'][disabled],\ninput[type='submit'].button-disabled,\ninput[type='submit'][disabled] {\n  opacity: 0.5;\n  cursor: default;\n}\n.button.button-disabled:hover, .button.button-disabled:focus, .button[disabled]:hover, .button[disabled]:focus,\nbutton.button-disabled:hover,\nbutton.button-disabled:focus,\nbutton[disabled]:hover,\nbutton[disabled]:focus,\ninput[type='button'].button-disabled:hover,\ninput[type='button'].button-disabled:focus,\ninput[type='button'][disabled]:hover,\ninput[type='button'][disabled]:focus,\ninput[type='reset'].button-disabled:hover,\ninput[type='reset'].button-disabled:focus,\ninput[type='reset'][disabled]:hover,\ninput[type='reset'][disabled]:focus,\ninput[type='submit'].button-disabled:hover,\ninput[type='submit'].button-disabled:focus,\ninput[type='submit'][disabled]:hover,\ninput[type='submit'][disabled]:focus {\n  background-color: #9b4dca;\n  border-color: #9b4dca;\n}\n.button.button-outline,\nbutton.button-outline,\ninput[type='button'].button-outline,\ninput[type='reset'].button-outline,\ninput[type='submit'].button-outline {\n  color: #9b4dca;\n  background-color: transparent;\n}\n.button.button-outline:hover, .button.button-outline:focus,\nbutton.button-outline:hover,\nbutton.button-outline:focus,\ninput[type='button'].button-outline:hover,\ninput[type='button'].button-outline:focus,\ninput[type='reset'].button-outline:hover,\ninput[type='reset'].button-outline:focus,\ninput[type='submit'].button-outline:hover,\ninput[type='submit'].button-outline:focus {\n  color: #606c76;\n  background-color: transparent;\n  border-color: #606c76;\n}\n.button.button-outline.button-disabled:hover, .button.button-outline.button-disabled:focus, .button.button-outline[disabled]:hover, .button.button-outline[disabled]:focus,\nbutton.button-outline.button-disabled:hover,\nbutton.button-outline.button-disabled:focus,\nbutton.button-outline[disabled]:hover,\nbutton.button-outline[disabled]:focus,\ninput[type='button'].button-outline.button-disabled:hover,\ninput[type='button'].button-outline.button-disabled:focus,\ninput[type='button'].button-outline[disabled]:hover,\ninput[type='button'].button-outline[disabled]:focus,\ninput[type='reset'].button-outline.button-disabled:hover,\ninput[type='reset'].button-outline.button-disabled:focus,\ninput[type='reset'].button-outline[disabled]:hover,\ninput[type='reset'].button-outline[disabled]:focus,\ninput[type='submit'].button-outline.button-disabled:hover,\ninput[type='submit'].button-outline.button-disabled:focus,\ninput[type='submit'].button-outline[disabled]:hover,\ninput[type='submit'].button-outline[disabled]:focus {\n  color: #9b4dca;\n  border-color: inherit;\n}\n.button.button-clear,\nbutton.button-clear,\ninput[type='button'].button-clear,\ninput[type='reset'].button-clear,\ninput[type='submit'].button-clear {\n  color: #9b4dca;\n  background-color: transparent;\n  border-color: transparent;\n}\n.button.button-clear:hover, .button.button-clear:focus,\nbutton.button-clear:hover,\nbutton.button-clear:focus,\ninput[type='button'].button-clear:hover,\ninput[type='button'].button-clear:focus,\ninput[type='reset'].button-clear:hover,\ninput[type='reset'].button-clear:focus,\ninput[type='submit'].button-clear:hover,\ninput[type='submit'].button-clear:focus {\n  color: #606c76;\n  background-color: transparent;\n  border-color: transparent;\n}\n.button.button-clear.button-disabled:hover, .button.button-clear.button-disabled:focus, .button.button-clear[disabled]:hover, .button.button-clear[disabled]:focus,\nbutton.button-clear.button-disabled:hover,\nbutton.button-clear.button-disabled:focus,\nbutton.button-clear[disabled]:hover,\nbutton.button-clear[disabled]:focus,\ninput[type='button'].button-clear.button-disabled:hover,\ninput[type='button'].button-clear.button-disabled:focus,\ninput[type='button'].button-clear[disabled]:hover,\ninput[type='button'].button-clear[disabled]:focus,\ninput[type='reset'].button-clear.button-disabled:hover,\ninput[type='reset'].button-clear.button-disabled:focus,\ninput[type='reset'].button-clear[disabled]:hover,\ninput[type='reset'].button-clear[disabled]:focus,\ninput[type='submit'].button-clear.button-disabled:hover,\ninput[type='submit'].button-clear.button-disabled:focus,\ninput[type='submit'].button-clear[disabled]:hover,\ninput[type='submit'].button-clear[disabled]:focus {\n  color: #9b4dca;\n}\n\ncode {\n  background: #f4f5f6;\n  border-radius: 0.4rem;\n  font-size: 86%;\n  padding: 0.2rem 0.5rem;\n  margin: 0 0.2rem;\n  white-space: nowrap;\n}\n\npre {\n  background: #f4f5f6;\n  border-left: 0.3rem solid #9b4dca;\n  font-family: \"Menlo\", \"Consolas\", \"Bitstream Vera Sans Mono\", \"DejaVu Sans Mono\", \"Monaco\", monospace;\n}\npre > code {\n  background: transparent;\n  border-radius: 0;\n  display: block;\n  padding: 1rem 1.5rem;\n  white-space: pre;\n}\n\nhr {\n  border: 0;\n  border-top: 0.1rem solid #f4f5f6;\n  margin-bottom: 3.5rem;\n  margin-top: 3rem;\n}\n\ninput[type='email'],\ninput[type='number'],\ninput[type='password'],\ninput[type='search'],\ninput[type='tel'],\ninput[type='text'],\ninput[type='url'],\ntextarea,\nselect {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background-color: transparent;\n  border: 0.1rem solid #d1d1d1;\n  border-radius: 0.4rem;\n  box-shadow: none;\n  height: 3.8rem;\n  padding: 0.6rem 1rem;\n  width: 100%;\n}\ninput[type='email']:focus,\ninput[type='number']:focus,\ninput[type='password']:focus,\ninput[type='search']:focus,\ninput[type='tel']:focus,\ninput[type='text']:focus,\ninput[type='url']:focus,\ntextarea:focus,\nselect:focus {\n  border: 0.1rem solid #9b4dca;\n  outline: 0;\n}\n\nselect {\n  padding: 0.6rem 3rem 0.6rem 1rem;\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiICAgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjkgMTQiICAgaGVpZ2h0PSIxNHB4IiAgIGlkPSJMYXllcl8xIiAgIHZlcnNpb249IjEuMSIgICB2aWV3Qm94PSIwIDAgMjkgMTQiICAgd2lkdGg9IjI5cHgiICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ4LjQgcjk5MzkiICAgc29kaXBvZGk6ZG9jbmFtZT0iY2FyZXQtZ3JheS5zdmciPjxtZXRhZGF0YSAgICAgaWQ9Im1ldGFkYXRhMzAzOSI+PHJkZjpSREY+PGNjOldvcmsgICAgICAgICByZGY6YWJvdXQ9IiI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGUgICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzICAgICBpZD0iZGVmczMwMzciIC8+PHNvZGlwb2RpOm5hbWVkdmlldyAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiICAgICBib3JkZXJvcGFjaXR5PSIxIiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIgICAgIGdyaWR0b2xlcmFuY2U9IjEwIiAgICAgZ3VpZGV0b2xlcmFuY2U9IjEwIiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSI5MDMiICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI1OTQiICAgICBpZD0ibmFtZWR2aWV3MzAzNSIgICAgIHNob3dncmlkPSJ0cnVlIiAgICAgaW5rc2NhcGU6em9vbT0iMTIuMTM3OTMxIiAgICAgaW5rc2NhcGU6Y3g9Ii00LjExOTMxODJlLTA4IiAgICAgaW5rc2NhcGU6Y3k9IjciICAgICBpbmtzY2FwZTp3aW5kb3cteD0iNTAyIiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjMwMiIgICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJMYXllcl8xIj48aW5rc2NhcGU6Z3JpZCAgICAgICB0eXBlPSJ4eWdyaWQiICAgICAgIGlkPSJncmlkMzA0MSIgLz48L3NvZGlwb2RpOm5hbWVkdmlldz48cG9seWdvbiAgICAgcG9pbnRzPSIwLjE1LDAgMTQuNSwxNC4zNSAyOC44NSwwICIgICAgIGlkPSJwb2x5Z29uMzAzMyIgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuMzU0MTEzODcsMCwwLDAuNDgzMjkxMSw5LjMyNDE1NDUsMy42MjQ5OTkyKSIgICAgIHN0eWxlPSJmaWxsOiNkMWQxZDE7ZmlsbC1vcGFjaXR5OjEiIC8+PC9zdmc+) center right no-repeat;\n}\nselect:focus {\n  background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIgICB4bWxuczpzdmc9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiICAgeG1sbnM6aW5rc2NhcGU9Imh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGUiICAgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjkgMTQiICAgaGVpZ2h0PSIxNHB4IiAgIGlkPSJMYXllcl8xIiAgIHZlcnNpb249IjEuMSIgICB2aWV3Qm94PSIwIDAgMjkgMTQiICAgd2lkdGg9IjI5cHgiICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjQ4LjQgcjk5MzkiICAgc29kaXBvZGk6ZG9jbmFtZT0iY2FyZXQuc3ZnIj48bWV0YWRhdGEgICAgIGlkPSJtZXRhZGF0YTMwMzkiPjxyZGY6UkRGPjxjYzpXb3JrICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmcyAgICAgaWQ9ImRlZnMzMDM3IiAvPjxzb2RpcG9kaTpuYW1lZHZpZXcgICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIgICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IiAgICAgYm9yZGVyb3BhY2l0eT0iMSIgICAgIG9iamVjdHRvbGVyYW5jZT0iMTAiICAgICBncmlkdG9sZXJhbmNlPSIxMCIgICAgIGd1aWRldG9sZXJhbmNlPSIxMCIgICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwIiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIgICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iOTAzIiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iNTk0IiAgICAgaWQ9Im5hbWVkdmlldzMwMzUiICAgICBzaG93Z3JpZD0idHJ1ZSIgICAgIGlua3NjYXBlOnpvb209IjEyLjEzNzkzMSIgICAgIGlua3NjYXBlOmN4PSItNC4xMTkzMTgyZS0wOCIgICAgIGlua3NjYXBlOmN5PSI3IiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjUwMiIgICAgIGlua3NjYXBlOndpbmRvdy15PSIzMDIiICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIwIiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0iTGF5ZXJfMSI+PGlua3NjYXBlOmdyaWQgICAgICAgdHlwZT0ieHlncmlkIiAgICAgICBpZD0iZ3JpZDMwNDEiIC8+PC9zb2RpcG9kaTpuYW1lZHZpZXc+PHBvbHlnb24gICAgIHBvaW50cz0iMjguODUsMCAwLjE1LDAgMTQuNSwxNC4zNSAiICAgICBpZD0icG9seWdvbjMwMzMiICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjM1NDExMzg3LDAsMCwwLjQ4MzI5MTEsOS4zMjQxNTUzLDMuNjI1KSIgICAgIHN0eWxlPSJmaWxsOiM5YjRkY2Y7ZmlsbC1vcGFjaXR5OjEiIC8+PC9zdmc+);\n}\n\ntextarea {\n  padding-bottom: 0.6rem;\n  padding-top: 0.6rem;\n  min-height: 6.5rem;\n}\n\nlabel,\nlegend {\n  font-size: 1.6rem;\n  font-weight: 700;\n  display: block;\n  margin-bottom: 0.5rem;\n}\n\nfieldset {\n  border-width: 0;\n  padding: 0;\n}\n\ninput[type='checkbox'],\ninput[type='radio'] {\n  display: inline;\n}\n\n.label-inline {\n  font-weight: normal;\n  display: inline-block;\n  margin-left: 0.5rem;\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 112rem;\n  padding: 0 2rem;\n  position: relative;\n  width: 100%;\n}\n\n.row {\n  display: flex;\n  flex-direction: column;\n  padding: 0;\n  width: 100%;\n}\n.row .row-wrap {\n  flex-wrap: wrap;\n}\n.row .row-no-padding {\n  padding: 0;\n}\n.row .row-no-padding > .column {\n  padding: 0;\n}\n.row .row-top {\n  align-items: flex-start;\n}\n.row .row-bottom {\n  align-items: flex-end;\n}\n.row .row-center {\n  align-items: center;\n}\n.row .row-stretch {\n  align-items: stretch;\n}\n.row .row-baseline {\n  align-items: baseline;\n}\n.row .column {\n  display: block;\n  flex: 1;\n  margin-left: 0;\n  max-width: 100%;\n  width: 100%;\n}\n.row .column .col-top {\n  align-self: flex-start;\n}\n.row .column .col-bottom {\n  align-self: flex-end;\n}\n.row .column .col-center {\n  align-self: center;\n}\n.row .column.column-offset-10 {\n  margin-left: 10%;\n}\n.row .column.column-offset-20 {\n  margin-left: 20%;\n}\n.row .column.column-offset-25 {\n  margin-left: 25%;\n}\n.row .column.column-offset-33, .row .column.column-offset-34 {\n  margin-left: 33.3333%;\n}\n.row .column.column-offset-50 {\n  margin-left: 50%;\n}\n.row .column.column-offset-66, .row .column.column-offset-67 {\n  margin-left: 66.6666%;\n}\n.row .column.column-offset-75 {\n  margin-left: 75%;\n}\n.row .column.column-offset-80 {\n  margin-left: 80%;\n}\n.row .column.column-offset-90 {\n  margin-left: 90%;\n}\n.row .column.column-10 {\n  flex: 0 0 10%;\n  max-width: 10%;\n}\n.row .column.column-20 {\n  flex: 0 0 20%;\n  max-width: 20%;\n}\n.row .column.column-25 {\n  flex: 0 0 25%;\n  max-width: 25%;\n}\n.row .column.column-33, .row .column.column-34 {\n  flex: 0 0 33.3333%;\n  max-width: 33.3333%;\n}\n.row .column.column-40 {\n  flex: 0 0 40%;\n  max-width: 40%;\n}\n.row .column.column-50 {\n  flex: 0 0 50%;\n  max-width: 50%;\n}\n.row .column.column-60 {\n  flex: 0 0 60%;\n  max-width: 60%;\n}\n.row .column.column-66, .row .column.column-67 {\n  flex: 0 0 66.6666%;\n  max-width: 66.6666%;\n}\n.row .column.column-75 {\n  flex: 0 0 75%;\n  max-width: 75%;\n}\n.row .column.column-80 {\n  flex: 0 0 80%;\n  max-width: 80%;\n}\n.row .column.column-90 {\n  flex: 0 0 90%;\n  max-width: 90%;\n}\n\n@media (min-width: 40rem) {\n  .row {\n    flex-direction: row;\n    margin-left: -1rem;\n    width: calc(100% + 2.0rem);\n  }\n  .row .column {\n    margin-bottom: inherit;\n    padding: 0 1rem;\n  }\n}\na {\n  color: #9b4dca;\n  text-decoration: none;\n}\na:hover {\n  color: #606c76;\n}\n\ndl,\nol,\nul {\n  margin-top: 0;\n  padding-left: 0;\n}\ndl ul,\ndl ol,\nol ul,\nol ol,\nul ul,\nul ol {\n  font-size: 90%;\n  margin: 1.5rem 0 1.5rem 3rem;\n}\n\ndl {\n  list-style: none;\n}\n\nul {\n  list-style: circle inside;\n}\n\nol {\n  list-style: decimal inside;\n}\n\ndt,\ndd,\nli {\n  margin-bottom: 1rem;\n}\n\n.button,\nbutton {\n  margin-bottom: 1rem;\n}\n\ninput,\ntextarea,\nselect,\nfieldset {\n  margin-bottom: 1.5rem;\n}\n\npre,\nblockquote,\ndl,\nfigure,\ntable,\np,\nul,\nol,\nform {\n  margin-bottom: 2.5rem;\n}\n\ntable {\n  width: 100%;\n}\n\nth,\ntd {\n  border-bottom: 0.1rem solid #e1e1e1;\n  padding: 1.2rem 1.5rem;\n  text-align: left;\n}\nth:first-child,\ntd:first-child {\n  padding-left: 0;\n}\nth:last-child,\ntd:last-child {\n  padding-right: 0;\n}\n\np {\n  margin-top: 0;\n}\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-weight: 300;\n  margin-bottom: 2rem;\n  margin-top: 0;\n}\n\nh1 {\n  font-size: 4rem;\n  letter-spacing: -0.1rem;\n  line-height: 1.2;\n}\n\nh2 {\n  font-size: 3.6rem;\n  letter-spacing: -0.1rem;\n  line-height: 1.25;\n}\n\nh3 {\n  font-size: 3rem;\n  letter-spacing: -0.1rem;\n  line-height: 1.3;\n}\n\nh4 {\n  font-size: 2.4rem;\n  letter-spacing: -0.08rem;\n  line-height: 1.35;\n}\n\nh5 {\n  font-size: 1.8rem;\n  letter-spacing: -0.05rem;\n  line-height: 1.5;\n}\n\nh6 {\n  font-size: 1.6rem;\n  letter-spacing: 0;\n  line-height: 1.4;\n}\n\n@media (min-width: 40rem) {\n  h1 {\n    font-size: 5rem;\n  }\n\n  h2 {\n    font-size: 4.2rem;\n  }\n\n  h3 {\n    font-size: 3.6rem;\n  }\n\n  h4 {\n    font-size: 3rem;\n  }\n\n  h5 {\n    font-size: 2.4rem;\n  }\n\n  h6 {\n    font-size: 1.5rem;\n  }\n}\n.float-right {\n  float: right;\n}\n\n.float-left {\n  float: left;\n}\n\n.clearfix {\n  *zoom: 1;\n}\n.clearfix:after, .clearfix:before {\n  content: \"\";\n  display: table;\n}\n.clearfix:after {\n  clear: both;\n}\n", ""]);

	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./angular\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	module.exports = angular;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;}; /*!
	 * State-based routing for AngularJS
	 * @version v1.0.0-alpha.3
	 * @link http://angular-ui.github.com/ui-router
	 * @license MIT License, http://www.opensource.org/licenses/MIT
	 */(function webpackUniversalModuleDefinition(root,factory){if(( false?'undefined':_typeof(exports))==='object'&&( false?'undefined':_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if((typeof exports==='undefined'?'undefined':_typeof(exports))==='object')exports["angular-ui-router"]=factory();else root["angular-ui-router"]=factory();})(undefined,function(){return  (/******/function(modules){ // webpackBootstrap
	/******/ // The module cache
	/******/var installedModules={}; /******/ /******/ // The require function
	/******/function __webpack_require__(moduleId){ /******/ /******/ // Check if module is in cache
	/******/if(installedModules[moduleId]) /******/return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache)
	/******/var module=installedModules[moduleId]={ /******/exports:{}, /******/id:moduleId, /******/loaded:false /******/}; /******/ /******/ // Execute the module function
	/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__); /******/ /******/ // Flag the module as loaded
	/******/module.loaded=true; /******/ /******/ // Return the exports of the module
	/******/return module.exports; /******/} /******/ /******/ /******/ // expose the modules object (__webpack_modules__)
	/******/__webpack_require__.m=modules; /******/ /******/ // expose the module cache
	/******/__webpack_require__.c=installedModules; /******/ /******/ // __webpack_public_path__
	/******/__webpack_require__.p=""; /******/ /******/ // Load entry module and return exports
	/******/return __webpack_require__(0); /******/}( /************************************************************************/ /******/[ /* 0 */ /***/function(module,exports,__webpack_require__){ /**
		 * Main entry point for angular 1.x build
		 * @module ng1
		 */ /** for typedoc */"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}__export(__webpack_require__(1));__export(__webpack_require__(53));__export(__webpack_require__(54));__webpack_require__(56);__webpack_require__(57);__webpack_require__(58);__webpack_require__(59);Object.defineProperty(exports,"__esModule",{value:true});exports.default="ui.router"; /***/}, /* 1 */ /***/function(module,exports,__webpack_require__){ /** @module common */ /** */"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}}__export(__webpack_require__(2));__export(__webpack_require__(20));__export(__webpack_require__(44));__export(__webpack_require__(40));__export(__webpack_require__(17));__export(__webpack_require__(13));__export(__webpack_require__(45));__export(__webpack_require__(49));var router_1=__webpack_require__(51);exports.UIRouter=router_1.UIRouter; /***/}, /* 2 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module common */ /** for typedoc */__export(__webpack_require__(3));__export(__webpack_require__(6));__export(__webpack_require__(7));__export(__webpack_require__(5));__export(__webpack_require__(4));__export(__webpack_require__(8));__export(__webpack_require__(9));__export(__webpack_require__(12)); /***/}, /* 3 */ /***/function(module,exports,__webpack_require__){ /**
		 * Random utility functions used in the UI-Router code
		 *
		 * @preferred @module common
		 */ /** for typedoc */"use strict";var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5);var angular=window.angular||{};exports.fromJson=angular.fromJson||JSON.parse.bind(JSON);exports.toJson=angular.toJson||JSON.stringify.bind(JSON);exports.copy=angular.copy||_copy;exports.forEach=angular.forEach||_forEach;exports.extend=angular.extend||_extend;exports.equals=angular.equals||_equals;exports.identity=function(x){return x;};exports.noop=function(){return undefined;};exports.abstractKey='abstract'; /**
		 * Binds and copies functions onto an object
		 *
		 * Takes functions from the 'from' object, binds those functions to the _this object, and puts the bound functions
		 * on the 'to' object.
		 *
		 * This example creates an new class instance whose functions are prebound to the new'd object.
		 * @example
		 * ```
		 *
		 * class Foo {
		 *   constructor(data) {
		 *     // Binds all functions from Foo.prototype to 'this',
		 *     // then copies them to 'this'
		 *     bindFunctions(Foo.prototype, this, this);
		 *     this.data = data;
		 *   }
		 *
		 *   log() {
		 *     console.log(this.data);
		 *   }
		 * }
		 *
		 * let myFoo = new Foo([1,2,3]);
		 * var logit = myFoo.log;
		 * logit(); // logs [1, 2, 3] from the myFoo 'this' instance
		 * ```
		 *
		 * This example creates a bound version of a service function, and copies it to another object
		 * @example
		 * ```
		 *
		 * var SomeService = {
		 *   this.data = [3, 4, 5];
		 *   this.log = function() {
		 *     console.log(this.data);
		 *   }
		 * }
		 *
		 * // Constructor fn
		 * function OtherThing() {
		 *   // Binds all functions from SomeService to SomeService,
		 *   // then copies them to 'this'
		 *   bindFunctions(SomeService, this, SomeService);
		 * }
		 *
		 * let myOtherThing = new OtherThing();
		 * myOtherThing.log(); // logs [3, 4, 5] from SomeService's 'this'
		 * ```
		 *
		 * @param from The object which contains the functions to be bound
		 * @param to The object which will receive the bound functions
		 * @param bindTo The object which the functions will be bound to
		 * @param fnNames The function names which will be bound (Defaults to all the functions found on the 'from' object)
		 */function bindFunctions(from,to,bindTo,fnNames){if(fnNames===void 0){fnNames=Object.keys(from);}return fnNames.filter(function(name){return typeof from[name]==='function';}).forEach(function(name){return to[name]=from[name].bind(bindTo);});}exports.bindFunctions=bindFunctions; /**
		 * prototypal inheritance helper.
		 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
		 */exports.inherit=function(parent,extra){return exports.extend(new (exports.extend(function(){},{prototype:parent}))(),extra);}; /**
		 * Given an arguments object, converts the arguments at index idx and above to an array.
		 * This is similar to es6 rest parameters.
		 *
		 * Optionally, the argument at index idx may itself already be an array.
		 *
		 * For example,
		 * given either:
		 *        arguments = [ obj, "foo", "bar" ]
		 * or:
		 *        arguments = [ obj, ["foo", "bar"] ]
		 * then:
		 *        restArgs(arguments, 1) == ["foo", "bar"]
		 *
		 * This allows functions like pick() to be implemented such that it allows either a bunch
		 * of string arguments (like es6 rest parameters), or a single array of strings:
		 *
		 * given:
		 *        var obj = { foo: 1, bar: 2, baz: 3 };
		 * then:
		 *        pick(obj, "foo", "bar");   // returns { foo: 1, bar: 2 }
		 *        pick(obj, ["foo", "bar"]); // returns { foo: 1, bar: 2 }
		 */var restArgs=function restArgs(args,idx){if(idx===void 0){idx=0;}return Array.prototype.concat.apply(Array.prototype,Array.prototype.slice.call(args,idx));}; /** Given an array, returns true if the object is found in the array, (using indexOf) */var inArray=function inArray(array,obj){return array.indexOf(obj)!==-1;}; /** Given an array, and an item, if the item is found in the array, it removes it (in-place).  The same array is returned */exports.removeFrom=hof_1.curry(function(array,obj){var idx=array.indexOf(obj);if(idx>=0)array.splice(idx,1);return array;}); /**
		 * Applies a set of defaults to an options object.  The options object is filtered
		 * to only those properties of the objects in the defaultsList.
		 * Earlier objects in the defaultsList take precedence when applying defaults.
		 */function defaults(opts){if(opts===void 0){opts={};}var defaultsList=[];for(var _i=1;_i<arguments.length;_i++){defaultsList[_i-1]=arguments[_i];}var defaults=merge.apply(null,[{}].concat(defaultsList));return exports.extend({},defaults,pick(opts||{},Object.keys(defaults)));}exports.defaults=defaults; /**
		 * Merges properties from the list of objects to the destination object.
		 * If a property already exists in the destination object, then it is not overwritten.
		 */function merge(dst){var objs=[];for(var _i=1;_i<arguments.length;_i++){objs[_i-1]=arguments[_i];}exports.forEach(objs,function(obj){exports.forEach(obj,function(value,key){if(!dst.hasOwnProperty(key))dst[key]=value;});});return dst;}exports.merge=merge; /** Reduce function that merges each element of the list into a single object, using extend */exports.mergeR=function(memo,item){return exports.extend(memo,item);}; /**
		 * Finds the common ancestor path between two states.
		 *
		 * @param {Object} first The first state.
		 * @param {Object} second The second state.
		 * @return {Array} Returns an array of state names in descending order, not including the root.
		 */function ancestors(first,second){var path=[];for(var n in first.path){if(first.path[n]!==second.path[n])break;path.push(first.path[n]);}return path;}exports.ancestors=ancestors; /**
		 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
		 *
		 * @param {Object} a The first object.
		 * @param {Object} b The second object.
		 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
		 *                     it defaults to the list of keys in `a`.
		 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
		 */function equalForKeys(a,b,keys){if(keys===void 0){keys=Object.keys(a);}for(var i=0;i<keys.length;i++){var k=keys[i];if(a[k]!=b[k])return false; // Not '===', values aren't necessarily normalized
	}return true;}exports.equalForKeys=equalForKeys;function pickOmitImpl(predicate,obj){var objCopy={},keys=restArgs(arguments,2);for(var key in obj){if(predicate(keys,key))objCopy[key]=obj[key];}return objCopy;} /** Return a copy of the object only containing the whitelisted properties. */function pick(obj){return pickOmitImpl.apply(null,[inArray].concat(restArgs(arguments)));}exports.pick=pick; /** Return a copy of the object omitting the blacklisted properties. */function omit(obj){return pickOmitImpl.apply(null,[hof_1.not(inArray)].concat(restArgs(arguments)));}exports.omit=omit; /**
		 * Maps an array, or object to a property (by name)
		 */function pluck(collection,propName){return map(collection,hof_1.prop(propName));}exports.pluck=pluck; /** Filters an Array or an Object's properties based on a predicate */function filter(collection,callback){var arr=predicates_1.isArray(collection),result=arr?[]:{};var accept=arr?function(x){return result.push(x);}:function(x,key){return result[key]=x;};exports.forEach(collection,function(item,i){if(callback(item,i))accept(item,i);});return result;}exports.filter=filter; /** Finds an object from an array, or a property of an object, that matches a predicate */function find(collection,callback){var result;exports.forEach(collection,function(item,i){if(result)return;if(callback(item,i))result=item;});return result;}exports.find=find; /** Given an object, returns a new object, where each property is transformed by the callback function */exports.mapObj=map; /** Maps an array or object properties using a callback function */function map(collection,callback){var result=predicates_1.isArray(collection)?[]:{};exports.forEach(collection,function(item,i){return result[i]=callback(item,i);});return result;}exports.map=map; /**
		 * Given an object, return its enumerable property values
		 *
		 * @example
		 * ```
		 *
		 * let foo = { a: 1, b: 2, c: 3 }
		 * let vals = values(foo); // [ 1, 2, 3 ]
		 * ```
		 */exports.values=function(obj){return Object.keys(obj).map(function(key){return obj[key];});}; /**
		 * Reduce function that returns true if all of the values are truthy.
		 *
		 * @example
		 * ```
		 *
		 * let vals = [ 1, true, {}, "hello world"];
		 * vals.reduce(allTrueR, true); // true
		 *
		 * vals.push(0);
		 * vals.reduce(allTrueR, true); // false
		 * ```
		 */exports.allTrueR=function(memo,elem){return memo&&elem;}; /**
		 * Reduce function that returns true if any of the values are truthy.
		 *
		 *  * @example
		 * ```
		 *
		 * let vals = [ 0, null, undefined ];
		 * vals.reduce(anyTrueR, true); // false
		 *
		 * vals.push("hello world");
		 * vals.reduce(anyTrueR, true); // true
		 * ```
		 */exports.anyTrueR=function(memo,elem){return memo||elem;}; /**
		 * Reduce function which un-nests a single level of arrays
		 * @example
		 * ```
		 *
		 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
		 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
		 * ```
		 */exports.unnestR=function(memo,elem){return memo.concat(elem);}; /**
		 * Reduce function which recursively un-nests all arrays
		 *
		 * @example
		 * ```
		 *
		 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
		 * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]
		 * ```
		 */exports.flattenR=function(memo,elem){return predicates_1.isArray(elem)?memo.concat(elem.reduce(exports.flattenR,[])):pushR(memo,elem);}; /** Reduce function that pushes an object to an array, then returns the array.  Mostly just for [[flattenR]] */function pushR(arr,obj){arr.push(obj);return arr;} /**
		 * Return a new array with a single level of arrays unnested.
		 *
		 * @example
		 * ```
		 *
		 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
		 * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
		 * ```
		 */exports.unnest=function(arr){return arr.reduce(exports.unnestR,[]);}; /**
		 * Return a completely flattened version of an array.
		 *
		 * @example
		 * ```
		 *
		 * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
		 * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]
		 * ```
		 */exports.flatten=function(arr){return arr.reduce(exports.flattenR,[]);}; /**
		 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
		 * @example
		 * ```
		 *
		 * let isNumber = (obj) => typeof(obj) === 'number';
		 * let allNumbers = [ 1, 2, 3, 4, 5 ];
		 * allNumbers.filter(assertPredicate(isNumber)); //OK
		 *
		 * let oneString = [ 1, 2, 3, 4, "5" ];
		 * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
		 * ```
		 */function assertPredicate(predicate,errMsg){if(errMsg===void 0){errMsg="assert failure";}return function(obj){if(!predicate(obj)){throw new Error(predicates_1.isFunction(errMsg)?errMsg(obj):errMsg);}return true;};}exports.assertPredicate=assertPredicate; /**
		 * Like _.pairs: Given an object, returns an array of key/value pairs
		 *
		 * @example
		 * ```
		 *
		 * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]
		 * ```
		 */exports.pairs=function(object){return Object.keys(object).map(function(key){return [key,object[key]];});}; /**
		 * Given two or more parallel arrays, returns an array of tuples where
		 * each tuple is composed of [ a[i], b[i], ... z[i] ]
		 *
		 * @example
		 * ```
		 *
		 * let foo = [ 0, 2, 4, 6 ];
		 * let bar = [ 1, 3, 5, 7 ];
		 * let baz = [ 10, 30, 50, 70 ];
		 * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
		 * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
		 * ```
		 */function arrayTuples(){var arrayArgs=[];for(var _i=0;_i<arguments.length;_i++){arrayArgs[_i-0]=arguments[_i];}if(arrayArgs.length===0)return [];var length=arrayArgs.reduce(function(min,arr){return Math.min(arr.length,min);},9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER
	return Array.apply(null,Array(length)).map(function(ignored,idx){return arrayArgs.map(function(arr){return arr[idx];});});}exports.arrayTuples=arrayTuples; /**
		 * Reduce function which builds an object from an array of [key, value] pairs.
		 *
		 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
		 *
		 * Each keyValueTuple should be an array with values [ key: string, value: any ]
		 *
		 * @example
		 * ```
		 *
		 * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
		 *
		 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
		 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
		 *
		 * // Or, more simply:
		 * var pairsToObj = pairs.reduce(applyPairs, {})
		 * // pairsToObj == { fookey: "fooval", barkey: "barval" }
		 * ```
		 */function applyPairs(memo,keyValTuple){var key,value;if(predicates_1.isArray(keyValTuple))key=keyValTuple[0],value=keyValTuple[1];if(!predicates_1.isString(key))throw new Error("invalid parameters to applyPairs");memo[key]=value;return memo;}exports.applyPairs=applyPairs; /** Get the last element of an array */function tail(arr){return arr.length&&arr[arr.length-1]||undefined;}exports.tail=tail; /**
		 * shallow copy from src to dest
		 *
		 * note: This is a shallow copy, while angular.copy is a deep copy.
		 * ui-router uses `copy` only to make copies of state parameters.
		 */function _copy(src,dest){if(dest)Object.keys(dest).forEach(function(key){return delete dest[key];});if(!dest)dest={};return exports.extend(dest,src);}function _forEach(obj,cb,_this){if(predicates_1.isArray(obj))return obj.forEach(cb,_this);Object.keys(obj).forEach(function(key){return cb(obj[key],key);});}function _copyProps(to,from){Object.keys(from).forEach(function(key){return to[key]=from[key];});return to;}function _extend(toObj,rest){return restArgs(arguments,1).filter(exports.identity).reduce(_copyProps,toObj);}function _equals(o1,o2){if(o1===o2)return true;if(o1===null||o2===null)return false;if(o1!==o1&&o2!==o2)return true; // NaN === NaN
	var t1=typeof o1==='undefined'?'undefined':_typeof(o1),t2=typeof o2==='undefined'?'undefined':_typeof(o2);if(t1!==t2||t1!=='object')return false;var tup=[o1,o2];if(hof_1.all(predicates_1.isArray)(tup))return _arraysEq(o1,o2);if(hof_1.all(predicates_1.isDate)(tup))return o1.getTime()===o2.getTime();if(hof_1.all(predicates_1.isRegExp)(tup))return o1.toString()===o2.toString();if(hof_1.all(predicates_1.isFunction)(tup))return true; // meh
	var predicates=[predicates_1.isFunction,predicates_1.isArray,predicates_1.isDate,predicates_1.isRegExp];if(predicates.map(hof_1.any).reduce(function(b,fn){return b||!!fn(tup);},false))return false;var key,keys={};for(key in o1){if(!_equals(o1[key],o2[key]))return false;keys[key]=true;}for(key in o2){if(!keys[key])return false;}return true;}function _arraysEq(a1,a2){if(a1.length!==a2.length)return false;return arrayTuples(a1,a2).reduce(function(b,t){return b&&_equals(t[0],t[1]);},true);} //
	//const _addToGroup = (result, keyFn) => (item) =>
	//  (result[keyFn(item)] = result[keyFn(item)] || []).push(item) && result;
	//const groupBy = (array, keyFn) => array.reduce((memo, item) => _addToGroup(memo, keyFn), {});
	//
	//
	/***/}, /* 4 */ /***/function(module,exports,__webpack_require__){"use strict"; /** Predicates @module common_predicates */ /** */var hof_1=__webpack_require__(5);var toStr=Object.prototype.toString;var tis=function tis(t){return function(x){return (typeof x==='undefined'?'undefined':_typeof(x))===t;};};exports.isUndefined=tis('undefined');exports.isDefined=hof_1.not(exports.isUndefined);exports.isNull=function(o){return o===null;};exports.isFunction=tis('function');exports.isNumber=tis('number');exports.isString=tis('string');exports.isObject=function(x){return x!==null&&(typeof x==='undefined'?'undefined':_typeof(x))==='object';};exports.isArray=Array.isArray;exports.isDate=function(x){return toStr.call(x)==='[object Date]';};exports.isRegExp=function(x){return toStr.call(x)==='[object RegExp]';}; /**
		 * Predicate which checks if a value is injectable
		 *
		 * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
		 * where all the elements in the array are Strings, except the last one, which is a Function
		 */function isInjectable(val){if(exports.isArray(val)&&val.length){var head=val.slice(0,-1),tail=val.slice(-1);return !(head.filter(hof_1.not(exports.isString)).length||tail.filter(hof_1.not(exports.isFunction)).length);}return exports.isFunction(val);}exports.isInjectable=isInjectable; /**
		 * Predicate which checks if a value looks like a Promise
		 *
		 * It is probably a Promise if it's an object, and it has a `then` property which is a Function
		 */exports.isPromise=hof_1.and(exports.isObject,hof_1.pipe(hof_1.prop('then'),exports.isFunction)); /***/}, /* 5 */ /***/function(module,exports){ /**
		 * Higher order functions
		 *
		 * @module common_hof
		 */"use strict"; /**
		 * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
		 *
		 * Given a function with N parameters, returns a new function that supports partial application.
		 * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
		 * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
		 * accept more parameters until all N parameters have been supplied.
		 *
		 *
		 * This contrived example uses a partially applied function as an predicate, which returns true
		 * if an object is found in both arrays.
		 * @example
		 * ```
		 * // returns true if an object is in both of the two arrays
		 * function inBoth(array1, array2, object) {
		 *   return array1.indexOf(object) !== -1 &&
		 *          array2.indexOf(object) !== 1;
		 * }
		 * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
		 * let foos = [obj1, obj3]
		 * let bars = [obj3, obj4, obj5]
		 *
		 * // A curried "copy" of inBoth
		 * let curriedInBoth = curry(inBoth);
		 * // Partially apply both the array1 and array2
		 * let inFoosAndBars = curriedInBoth(foos, bars);
		 *
		 * // Supply the final argument; since all arguments are
		 * // supplied, the original inBoth function is then called.
		 * let obj1InBoth = inFoosAndBars(obj1); // false
		 *
		 * // Use the inFoosAndBars as a predicate.
		 * // Filter, on each iteration, supplies the final argument
		 * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
		 * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
		 *
		 * ```
		 *
		 * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function
		 *
		 * @param fn
		 * @returns {*|function(): (*|any)}
		 */function curry(fn){var initial_args=[].slice.apply(arguments,[1]);var func_args_length=fn.length;function curried(args){if(args.length>=func_args_length)return fn.apply(null,args);return function(){return curried(args.concat([].slice.apply(arguments)));};}return curried(initial_args);}exports.curry=curry; /**
		 * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left
		 * given: f(x), g(x), h(x)
		 * let composed = compose(f,g,h)
		 * then, composed is: f(g(h(x)))
		 */function compose(){var args=arguments;var start=args.length-1;return function(){var i=start,result=args[start].apply(this,arguments);while(i--){result=args[i].call(this,result);}return result;};}exports.compose=compose; /**
		 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
		 * given: f(x), g(x), h(x)
		 * let piped = pipe(f,g,h);
		 * then, piped is: h(g(f(x)))
		 */function pipe(){var funcs=[];for(var _i=0;_i<arguments.length;_i++){funcs[_i-0]=arguments[_i];}return compose.apply(null,[].slice.call(arguments).reverse());}exports.pipe=pipe; /**
		 * Given a property name, returns a function that returns that property from an object
		 * let obj = { foo: 1, name: "blarg" };
		 * let getName = prop("name");
		 * getName(obj) === "blarg"
		 */exports.prop=function(name){return function(obj){return obj&&obj[name];};}; /**
		 * Given a property name and a value, returns a function that returns a boolean based on whether
		 * the passed object has a property that matches the value
		 * let obj = { foo: 1, name: "blarg" };
		 * let getName = propEq("name", "blarg");
		 * getName(obj) === true
		 */exports.propEq=curry(function(name,val,obj){return obj&&obj[name]===val;}); /**
		 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
		 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
		 * let getName = prop("nestedObj.name");
		 * getName(obj) === "blarg"
		 * let propNotFound = prop("this.property.doesnt.exist");
		 * propNotFound(obj) === undefined
		 */exports.parse=function(name){return pipe.apply(null,name.split(".").map(exports.prop));}; /**
		 * Given a function that returns a truthy or falsey value, returns a
		 * function that returns the opposite (falsey or truthy) value given the same inputs
		 */exports.not=function(fn){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i-0]=arguments[_i];}return !fn.apply(null,args);};}; /**
		 * Given two functions that return truthy or falsey values, returns a function that returns truthy
		 * if both functions return truthy for the given arguments
		 */function and(fn1,fn2){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i-0]=arguments[_i];}return fn1.apply(null,args)&&fn2.apply(null,args);};}exports.and=and; /**
		 * Given two functions that return truthy or falsey values, returns a function that returns truthy
		 * if at least one of the functions returns truthy for the given arguments
		 */function or(fn1,fn2){return function(){var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i-0]=arguments[_i];}return fn1.apply(null,args)||fn2.apply(null,args);};}exports.or=or; /**
		 * Check if all the elements of an array match a predicate function
		 *
		 * @param fn1 a predicate function `fn1`
		 * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array
		 */exports.all=function(fn1){return function(arr){return arr.reduce(function(b,x){return b&&!!fn1(x);},true);};};exports.any=function(fn1){return function(arr){return arr.reduce(function(b,x){return b||!!fn1(x);},false);};};exports.none=exports.not(exports.any); /** Given a class, returns a Predicate function that returns true if the object is of that class */exports.is=function(ctor){return function(obj){return obj!=null&&obj.constructor===ctor||obj instanceof ctor;};}; /** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */exports.eq=function(val){return function(other){return val===other;};}; /** Given a value, returns a function which returns the value */exports.val=function(v){return function(){return v;};};function invoke(fnName,args){return function(obj){return obj[fnName].apply(obj,args);};}exports.invoke=invoke; /**
		 * Sorta like Pattern Matching (a functional programming conditional construct)
		 *
		 * See http://c2.com/cgi/wiki?PatternMatching
		 *
		 * This is a conditional construct which allows a series of predicates and output functions
		 * to be checked and then applied.  Each predicate receives the input.  If the predicate
		 * returns truthy, then its matching output function (mapping function) is provided with
		 * the input and, then the result is returned.
		 *
		 * Each combination (2-tuple) of predicate + output function should be placed in an array
		 * of size 2: [ predicate, mapFn ]
		 *
		 * These 2-tuples should be put in an outer array.
		 *
		 * @example
		 * ```
		 *
		 * // Here's a 2-tuple where the first element is the isString predicate
		 * // and the second element is a function that returns a description of the input
		 * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
		 *
		 * // Second tuple: predicate "isNumber", mapfn returns a description
		 * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
		 *
		 * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
		 *
		 * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
		 *
		 * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
		 *
		 * console.log(descriptionOf(undefined)); // 'notdefined'
		 * console.log(descriptionOf(55)); // '(55) That's a number!'
		 * console.log(descriptionOf("foo")); // 'Here's your string foo'
		 * ```
		 *
		 * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
		 * with a Predicate and a mapping/output function
		 * @returns {function(any): *}
		 */function pattern(struct){return function(x){for(var i=0;i<struct.length;i++){if(struct[i][0](x))return struct[i][1](x);}};}exports.pattern=pattern; /***/}, /* 6 */ /***/function(module,exports){ /**
		 * This module is a stub for core services such as Dependency Injection or Browser Location.
		 * Core services may be implemented by a specific framework, such as ng1 or ng2, or be pure javascript.
		 *
		 * @module common
		 */"use strict"; /** for typedoc */ //import {IQService} from "angular";
	//import {IInjectorService} from "angular";
	var notImplemented=function notImplemented(fnname){return function(){throw new Error(fnname+"(): No coreservices implementation for UI-Router is loaded. You should include one of: ['angular1.js']");};};var services={$q:undefined,$injector:undefined,location:{},locationConfig:{},template:{}};exports.services=services;["replace","url","path","search","hash","onChange"].forEach(function(key){return services.location[key]=notImplemented(key);});["port","protocol","host","baseHref","html5Mode","hashPrefix"].forEach(function(key){return services.locationConfig[key]=notImplemented(key);}); /***/}, /* 7 */ /***/function(module,exports){"use strict"; /** @module state */ /** for typedoc */var Glob=function(){function Glob(text){this.text=text;this.glob=text.split('.');}Glob.prototype.matches=function(name){var segments=name.split('.'); // match single stars
	for(var i=0,l=this.glob.length;i<l;i++){if(this.glob[i]==='*')segments[i]='*';} // match greedy starts
	if(this.glob[0]==='**'){segments=segments.slice(segments.indexOf(this.glob[1]));segments.unshift('**');} // match greedy ends
	if(this.glob[this.glob.length-1]==='**'){segments.splice(segments.indexOf(this.glob[this.glob.length-2])+1,Number.MAX_VALUE);segments.push('**');}if(this.glob.length!=segments.length)return false;return segments.join('')===this.glob.join('');};Glob.is=function(text){return text.indexOf('*')>-1;};Glob.fromString=function(text){if(!this.is(text))return null;return new Glob(text);};return Glob;}();exports.Glob=Glob; /***/}, /* 8 */ /***/function(module,exports){ /** @module common */ /** for typedoc */"use strict";var Queue=function(){function Queue(_items,_limit){if(_items===void 0){_items=[];}if(_limit===void 0){_limit=null;}this._items=_items;this._limit=_limit;}Queue.prototype.enqueue=function(item){var items=this._items;items.push(item);if(this._limit&&items.length>this._limit)items.shift();return item;};Queue.prototype.dequeue=function(){if(this.size())return this._items.splice(0,1)[0];};Queue.prototype.clear=function(){var current=this._items;this._items=[];return current;};Queue.prototype.size=function(){return this._items.length;};Queue.prototype.remove=function(item){var idx=this._items.indexOf(item);return idx>-1&&this._items.splice(idx,1)[0];};Queue.prototype.peekTail=function(){return this._items[this._items.length-1];};Queue.prototype.peekHead=function(){if(this.size())return this._items[0];};return Queue;}();exports.Queue=Queue; /***/}, /* 9 */ /***/function(module,exports,__webpack_require__){ /** @module common_strings */ /** */"use strict";var predicates_1=__webpack_require__(4);var rejectFactory_1=__webpack_require__(10);var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var transition_1=__webpack_require__(11);var resolvable_1=__webpack_require__(32); /**
		 * Returns a string shortened to a maximum length
		 *
		 * If the string is already less than the `max` length, return the string.
		 * Else return the string, shortened to `max - 3` and append three dots ("...").
		 *
		 * @param max the maximum length of the string to return
		 * @param str the input string
		 */function maxLength(max,str){if(str.length<=max)return str;return str.substr(0,max-3)+"...";}exports.maxLength=maxLength; /**
		 * Returns a string, with spaces added to the end, up to a desired str length
		 *
		 * If the string is already longer than the desired length, return the string.
		 * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
		 *
		 * @param length the desired length of the string to return
		 * @param str the input string
		 */function padString(length,str){while(str.length<length){str+=" ";}return str;}exports.padString=padString;exports.kebobString=function(camelCase){return camelCase.replace(/([A-Z])/g,function($1){return "-"+$1.toLowerCase();});};function _toJson(obj){return JSON.stringify(obj);}function _fromJson(json){return predicates_1.isString(json)?JSON.parse(json):json;}function promiseToString(p){if(hof_1.is(rejectFactory_1.TransitionRejection)(p.reason))return p.reason.toString();return "Promise("+JSON.stringify(p)+")";}function functionToString(fn){var fnStr=fnToString(fn);var namedFunctionMatch=fnStr.match(/^(function [^ ]+\([^)]*\))/);return namedFunctionMatch?namedFunctionMatch[1]:fnStr;}exports.functionToString=functionToString;function fnToString(fn){var _fn=predicates_1.isArray(fn)?fn.slice(-1)[0]:fn;return _fn&&_fn.toString()||"undefined";}exports.fnToString=fnToString;var stringifyPattern=hof_1.pattern([[hof_1.not(predicates_1.isDefined),hof_1.val("undefined")],[predicates_1.isNull,hof_1.val("null")],[predicates_1.isPromise,promiseToString],[hof_1.is(transition_1.Transition),hof_1.invoke("toString")],[hof_1.is(resolvable_1.Resolvable),hof_1.invoke("toString")],[predicates_1.isInjectable,functionToString],[hof_1.val(true),common_1.identity]]);function stringify(o){var seen=[];function format(val){if(predicates_1.isObject(val)){if(seen.indexOf(val)!==-1)return '[circular ref]';seen.push(val);}return stringifyPattern(val);}return JSON.stringify(o,function(key,val){return format(val);}).replace(/\\"/g,'"');}exports.stringify=stringify; /***/}, /* 10 */ /***/function(module,exports,__webpack_require__){ /** @module transition */ /** for typedoc */"use strict";var common_1=__webpack_require__(3);var coreservices_1=__webpack_require__(6);var strings_1=__webpack_require__(9);(function(RejectType){RejectType[RejectType["SUPERSEDED"]=2]="SUPERSEDED";RejectType[RejectType["ABORTED"]=3]="ABORTED";RejectType[RejectType["INVALID"]=4]="INVALID";RejectType[RejectType["IGNORED"]=5]="IGNORED";})(exports.RejectType||(exports.RejectType={}));var RejectType=exports.RejectType;var TransitionRejection=function(){function TransitionRejection(type,message,detail){common_1.extend(this,{type:type,message:message,detail:detail});}TransitionRejection.prototype.toString=function(){var detailString=function detailString(d){return d&&d.toString!==Object.prototype.toString?d.toString():strings_1.stringify(d);};var type=this.type,message=this.message,detail=detailString(this.detail);return "TransitionRejection(type: "+type+", message: "+message+", detail: "+detail+")";};return TransitionRejection;}();exports.TransitionRejection=TransitionRejection;var RejectFactory=function(){function RejectFactory(){}RejectFactory.prototype.superseded=function(detail,options){var message="The transition has been superseded by a different transition (see detail).";var reason=new TransitionRejection(RejectType.SUPERSEDED,message,detail);if(options&&options.redirected){reason.redirected=true;}return common_1.extend(coreservices_1.services.$q.reject(reason),{reason:reason});};RejectFactory.prototype.redirected=function(detail){return this.superseded(detail,{redirected:true});};RejectFactory.prototype.invalid=function(detail){var message="This transition is invalid (see detail)";var reason=new TransitionRejection(RejectType.INVALID,message,detail);return common_1.extend(coreservices_1.services.$q.reject(reason),{reason:reason});};RejectFactory.prototype.ignored=function(detail){var message="The transition was ignored.";var reason=new TransitionRejection(RejectType.IGNORED,message,detail);return common_1.extend(coreservices_1.services.$q.reject(reason),{reason:reason});};RejectFactory.prototype.aborted=function(detail){ // TODO think about how to encapsulate an Error() object
	var message="The transition has been aborted.";var reason=new TransitionRejection(RejectType.ABORTED,message,detail);return common_1.extend(coreservices_1.services.$q.reject(reason),{reason:reason});};return RejectFactory;}();exports.RejectFactory=RejectFactory; /***/}, /* 11 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module transition */ /** for typedoc */var trace_1=__webpack_require__(12);var coreservices_1=__webpack_require__(6);var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5);var module_1=__webpack_require__(13);var node_1=__webpack_require__(39);var pathFactory_1=__webpack_require__(38);var module_2=__webpack_require__(17);var module_3=__webpack_require__(20);var module_4=__webpack_require__(40);var transitionCount=0,REJECT=new module_1.RejectFactory();var stateSelf=hof_1.prop("self"); /**
		 * The representation of a transition between two states.
		 *
		 * Contains all contextual information about the to/from states, parameters, resolves, as well as the
		 * list of states being entered and exited as a result of this transition.
		 */var Transition=function(){ /**
		     * Creates a new Transition object.
		     *
		     * If the target state is not valid, an error is thrown.
		     *
		     * @param fromPath The path of [[Node]]s from which the transition is leaving.  The last node in the `fromPath`
		     *        encapsulates the "from state".
		     * @param targetState The target state and parameters being transitioned to (also, the transition options)
		     * @param _transitionService The Transition Service instance
		     */function Transition(fromPath,targetState,_transitionService){var _this=this;this._transitionService=_transitionService;this._deferred=coreservices_1.services.$q.defer(); /**
		         * This promise is resolved or rejected based on the outcome of the Transition.
		         *
		         * When the transition is successful, the promise is resolved
		         * When the transition is unsuccessful, the promise is rejected with the [[TransitionRejection]] or javascript error
		         */this.promise=this._deferred.promise;this.treeChanges=function(){return _this._treeChanges;};this.isActive=function(){return _this===_this._options.current();};if(!targetState.valid()){throw new Error(targetState.error());} // Makes the Transition instance a hook registry (onStart, etc)
	module_1.HookRegistry.mixin(new module_1.HookRegistry(),this); // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
	this._options=common_1.extend({current:hof_1.val(this)},targetState.options());this.$id=transitionCount++;var toPath=pathFactory_1.PathFactory.buildToPath(fromPath,targetState);toPath=pathFactory_1.PathFactory.applyViewConfigs(_transitionService.$view,toPath);this._treeChanges=pathFactory_1.PathFactory.treeChanges(fromPath,toPath,this._options.reloadState);pathFactory_1.PathFactory.bindTransitionResolve(this._treeChanges,this);}Transition.prototype.$from=function(){return common_1.tail(this._treeChanges.from).state;};Transition.prototype.$to=function(){return common_1.tail(this._treeChanges.to).state;}; /**
		     * Returns the "from state"
		     *
		     * @returns The state object for the Transition's "from state".
		     */Transition.prototype.from=function(){return this.$from().self;}; /**
		     * Returns the "to state"
		     *
		     * @returns The state object for the Transition's target state ("to state").
		     */Transition.prototype.to=function(){return this.$to().self;}; /**
		     * Determines whether two transitions are equivalent.
		     */Transition.prototype.is=function(compare){if(compare instanceof Transition){ // TODO: Also compare parameters
	return this.is({to:compare.$to().name,from:compare.$from().name});}return !(compare.to&&!module_1.matchState(this.$to(),compare.to)||compare.from&&!module_1.matchState(this.$from(),compare.from));}; /**
		     * Gets transition parameter values
		     *
		     * @param pathname Pick which treeChanges path to get parameters for:
		     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
		     * @returns transition parameter values for the desired path.
		     */Transition.prototype.params=function(pathname){if(pathname===void 0){pathname="to";}return this._treeChanges[pathname].map(hof_1.prop("paramValues")).reduce(common_1.mergeR,{});}; /**
		     * Get resolved data
		     *
		     * @returns an object (key/value pairs) where keys are resolve names and values are any settled resolve data,
		     *    or `undefined` for pending resolve data
		     */Transition.prototype.resolves=function(){return common_1.map(common_1.tail(this._treeChanges.to).resolveContext.getResolvables(),function(res){return res.data;});}; /**
		     * Adds new resolves to this transition.
		     *
		     * @param resolves an [[ResolveDeclarations]] object which describes the new resolves
		     * @param state the state in the "to path" which should receive the new resolves (otherwise, the root state)
		     */Transition.prototype.addResolves=function(resolves,state){if(state===void 0){state="";}var stateName=typeof state==="string"?state:state.name;var topath=this._treeChanges.to;var targetNode=common_1.find(topath,function(node){return node.state.name===stateName;});common_1.tail(topath).resolveContext.addResolvables(module_4.Resolvable.makeResolvables(resolves),targetNode.state);}; /**
		     * Gets the previous transition, from which this transition was redirected.
		     *
		     * @returns The previous Transition, or null if this Transition is not the result of a redirection
		     */Transition.prototype.previous=function(){return this._options.previous||null;}; /**
		     * Get the transition options
		     *
		     * @returns the options for this Transition.
		     */Transition.prototype.options=function(){return this._options;}; /**
		     * Gets the states being entered.
		     *
		     * @returns an array of states that will be entered during this transition.
		     */Transition.prototype.entering=function(){return common_1.map(this._treeChanges.entering,hof_1.prop('state')).map(stateSelf);}; /**
		     * Gets the states being exited.
		     *
		     * @returns an array of states that will be exited during this transition.
		     */Transition.prototype.exiting=function(){return common_1.map(this._treeChanges.exiting,hof_1.prop('state')).map(stateSelf).reverse();}; /**
		     * Gets the states being retained.
		     *
		     * @returns an array of states that are already entered from a previous Transition, that will not be
		     *    exited during this Transition
		     */Transition.prototype.retained=function(){return common_1.map(this._treeChanges.retained,hof_1.prop('state')).map(stateSelf);}; /**
		     * Get the [[ViewConfig]]s associated with this Transition
		     *
		     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
		     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
		     *
		     * @param pathname the name of the path to fetch views for:
		     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
		     * @param state If provided, only returns the `ViewConfig`s for a single state in the path
		     *
		     * @returns a list of ViewConfig objects for the given path.
		     */Transition.prototype.views=function(pathname,state){if(pathname===void 0){pathname="entering";}var path=this._treeChanges[pathname];path=!state?path:path.filter(hof_1.propEq('state',state));return path.map(hof_1.prop("views")).filter(common_1.identity).reduce(common_1.unnestR,[]);}; /**
		     * @ngdoc function
		     * @name ui.router.state.type:Transition#redirect
		     * @methodOf ui.router.state.type:Transition
		     *
		     * @description
		     * Creates a new transition that is a redirection of the current one. This transition can
		     * be returned from a `$transitionsProvider` hook, `$state` event, or other method, to
		     * redirect a transition to a new state and/or set of parameters.
		     *
		     * @returns {Transition} Returns a new `Transition` instance.
		     */Transition.prototype.redirect=function(targetState){var newOptions=common_1.extend({},this.options(),targetState.options(),{previous:this});targetState=new module_2.TargetState(targetState.identifier(),targetState.$state(),targetState.params(),newOptions);var redirectTo=new Transition(this._treeChanges.from,targetState,this._transitionService);var reloadState=targetState.options().reloadState; // If the current transition has already resolved any resolvables which are also in the redirected "to path", then
	// add those resolvables to the redirected transition.  Allows you to define a resolve at a parent level, wait for
	// the resolve, then redirect to a child state based on the result, and not have to re-fetch the resolve.
	var redirectedPath=this.treeChanges().to;var copyResolvesFor=node_1.Node.matching(redirectTo.treeChanges().to,redirectedPath).filter(function(node){return !reloadState||!reloadState.includes[node.state.name];});var includeResolve=function includeResolve(resolve,key){return ['$stateParams','$transition$'].indexOf(key)===-1;};copyResolvesFor.forEach(function(node,idx){return common_1.extend(node.resolves,common_1.filter(redirectedPath[idx].resolves,includeResolve));});return redirectTo;}; /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */Transition.prototype._changedParams=function(){var _a=this._treeChanges,to=_a.to,from=_a.from;if(this._options.reload||common_1.tail(to).state!==common_1.tail(from).state)return undefined;var nodeSchemas=to.map(function(node){return node.paramSchema;});var _b=[to,from].map(function(path){return path.map(function(x){return x.paramValues;});}),toValues=_b[0],fromValues=_b[1];var tuples=common_1.arrayTuples(nodeSchemas,toValues,fromValues);return tuples.map(function(_a){var schema=_a[0],toVals=_a[1],fromVals=_a[2];return module_3.Param.changed(schema,toVals,fromVals);}).reduce(common_1.unnestR,[]);}; /**
		     * Returns true if the transition is dynamic.
		     *
		     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
		     *
		     * @returns true if the Transition is dynamic
		     */Transition.prototype.dynamic=function(){var changes=this._changedParams();return !changes?false:changes.map(function(x){return x.dynamic;}).reduce(common_1.anyTrueR,false);}; /**
		     * Returns true if the transition is ignored.
		     *
		     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
		     *
		     * @returns true if the Transition is ignored.
		     */Transition.prototype.ignored=function(){var changes=this._changedParams();return !changes?false:changes.length===0;}; /**
		     * @hidden
		     */Transition.prototype.hookBuilder=function(){return new module_1.HookBuilder(this._transitionService,this,{transition:this,current:this._options.current});}; /**
		     * Runs the transition
		     *
		     * This method is generally called from the [[StateService.transitionTo]]
		     *
		     * @returns a promise for a successful transition.
		     */Transition.prototype.run=function(){var _this=this;var hookBuilder=this.hookBuilder();var runSynchronousHooks=module_1.TransitionHook.runSynchronousHooks; // TODO: nuke these in favor of chaining off the promise, i.e.,
	// $transitions.onBefore({}, $transition$ => {$transition$.promise.then()}
	var runSuccessHooks=function runSuccessHooks(){return runSynchronousHooks(hookBuilder.getOnSuccessHooks(),{},true);};var runErrorHooks=function runErrorHooks($error$){return runSynchronousHooks(hookBuilder.getOnErrorHooks(),{$error$:$error$},true);}; // Run the success/error hooks *after* the Transition promise is settled.
	this.promise.then(runSuccessHooks,runErrorHooks);var syncResult=runSynchronousHooks(hookBuilder.getOnBeforeHooks());if(module_1.TransitionHook.isRejection(syncResult)){var rejectReason=syncResult.reason;this._deferred.reject(rejectReason);return this.promise;}if(!this.valid()){var error=new Error(this.error());this._deferred.reject(error);return this.promise;}if(this.ignored()){trace_1.trace.traceTransitionIgnored(this);var ignored=REJECT.ignored();this._deferred.reject(ignored.reason);return this.promise;} // When the chain is complete, then resolve or reject the deferred
	var resolve=function resolve(){_this.success=true;_this._deferred.resolve(_this);trace_1.trace.traceSuccess(_this.$to(),_this);};var reject=function reject(error){_this.success=false;_this._deferred.reject(error);trace_1.trace.traceError(error,_this);return coreservices_1.services.$q.reject(error);};trace_1.trace.traceTransitionStart(this);var chain=hookBuilder.asyncHooks().reduce(function(_chain,step){return _chain.then(step.invokeStep);},syncResult);chain.then(resolve,reject);return this.promise;}; /**
		     * Checks if the Transition is valid
		     *
		     * @returns true if the Transition is valid
		     */Transition.prototype.valid=function(){return !this.error();}; /**
		     * The reason the Transition is invalid
		     *
		     * @returns an error message explaining why the transition is invalid
		     */Transition.prototype.error=function(){var state=this.$to();if(state.self[common_1.abstractKey])return "Cannot transition to abstract state '"+state.name+"'";if(!module_3.Param.validates(state.parameters(),this.params()))return "Param values not valid for state '"+state.name+"'";}; /**
		     * A string representation of the Transition
		     *
		     * @returns A string representation of the Transition
		     */Transition.prototype.toString=function(){var fromStateOrName=this.from();var toStateOrName=this.to();var avoidEmptyHash=function avoidEmptyHash(params){return params["#"]!==null&&params["#"]!==undefined?params:common_1.omit(params,"#");}; // (X) means the to state is invalid.
	var id=this.$id,from=predicates_1.isObject(fromStateOrName)?fromStateOrName.name:fromStateOrName,fromParams=common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR,{}))),toValid=this.valid()?"":"(X) ",to=predicates_1.isObject(toStateOrName)?toStateOrName.name:toStateOrName,toParams=common_1.toJson(avoidEmptyHash(this.params()));return "Transition#"+id+"( '"+from+"'"+fromParams+" -> "+toValid+"'"+to+"'"+toParams+" )";};return Transition;}();exports.Transition=Transition; /***/}, /* 12 */ /***/function(module,exports,__webpack_require__){"use strict"; /**
		 * UI-Router Transition Tracing
		 *
		 * Enable transition tracing to print transition information to the console, in order to help debug your application.
		 * Tracing logs detailed information about each Transition to your console.
		 *
		 * To enable tracing, import the [[trace]] singleton and enable one or more categories.
		 *
		 * ES6
		 * ```
		 *
		 * import {trace} from "ui-router-ng2"; // or "angular-ui-router"
		 * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
		 * ```
		 *
		 * CJS
		 * ```
		 *
		 * let trace = require("angular-ui-router").trace; // or "ui-router-ng2"
		 * trace.enable("TRANSITION", "VIEWCONFIG");
		 * ```
		 *
		 * Globals
		 * ```
		 *
		 * let trace = window["angular-ui-router"].trace; // or "ui-router-ng2"
		 * trace.enable(); // Trace everything (very verbose)
		 * ```
		 *
		 * @module trace
		 */ /** for typedoc */var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var strings_1=__webpack_require__(9); /** @hidden */function uiViewString(viewData){if(!viewData)return 'ui-view (defunct)';return "ui-view id#"+viewData.id+", contextual name '"+viewData.name+"@"+viewData.creationContext+"', fqn: '"+viewData.fqn+"'";} /** @hidden */var viewConfigString=function viewConfigString(viewConfig){return "ViewConfig targeting ui-view: '"+viewConfig.viewDecl.$uiViewName+"@"+viewConfig.viewDecl.$uiViewContextAnchor+"', context: '"+viewConfig.viewDecl.$context.name+"'";}; /** @hidden */function normalizedCat(input){return predicates_1.isNumber(input)?Category[input]:Category[Category[input]];} /**
		 * Trace categories
		 *
		 * [[Trace.enable]] or [[Trace.disable]] a category
		 *
		 * `trace.enable(Category.TRANSITION)`
		 *
		 * These can also be provided using a matching string, or position ordinal
		 *
		 * `trace.enable("TRANSITION")`
		 *
		 * `trace.enable(1)`
		 */(function(Category){Category[Category["RESOLVE"]=0]="RESOLVE";Category[Category["TRANSITION"]=1]="TRANSITION";Category[Category["HOOK"]=2]="HOOK";Category[Category["INVOKE"]=3]="INVOKE";Category[Category["UIVIEW"]=4]="UIVIEW";Category[Category["VIEWCONFIG"]=5]="VIEWCONFIG";})(exports.Category||(exports.Category={}));var Category=exports.Category; /**
		 * Prints UI-Router Transition trace information to the console.
		 */var Trace=function(){function Trace(){ /** @hidden */this._enabled={};this.approximateDigests=0;} /** @hidden */Trace.prototype._set=function(enabled,categories){var _this=this;if(!categories.length){categories=Object.keys(Category).filter(function(k){return isNaN(parseInt(k,10));}).map(function(key){return Category[key];});}categories.map(normalizedCat).forEach(function(category){return _this._enabled[category]=enabled;});}; /**
		     * Enables a trace [[Category]]
		     *
		     * ```
		     * trace.enable("TRANSITION");
		     * ```
		     *
		     * @param categories categories to enable. If `categories` is omitted, all categories are enabled.
		     *        Also takes strings (category name) or ordinal (category position)
		     */Trace.prototype.enable=function(){var categories=[];for(var _i=0;_i<arguments.length;_i++){categories[_i-0]=arguments[_i];}this._set(true,categories);}; /**
		     * Disables a trace [[Category]]
		     *
		     * ```
		     * trace.disable("VIEWCONFIG");
		     * ```
		     *
		     * @param categories categories to disable. If `categories` is omitted, all categories are disabled.
		     *        Also takes strings (category name) or ordinal (category position)
		     */Trace.prototype.disable=function(){var categories=[];for(var _i=0;_i<arguments.length;_i++){categories[_i-0]=arguments[_i];}this._set(false,categories);}; /**
		     * Retrieves the enabled stateus of a [[Category]]
		     *
		     * ```
		     * trace.enabled("VIEWCONFIG"); // true or false
		     * ```
		     *
		     * @returns boolean true if the category is enabled
		     */Trace.prototype.enabled=function(category){return !!this._enabled[normalizedCat(category)];}; /** called by ui-router code */Trace.prototype.traceTransitionStart=function(transition){if(!this.enabled(Category.TRANSITION))return;var tid=transition.$id,digest=this.approximateDigests,transitionStr=strings_1.stringify(transition);console.log("Transition #"+tid+" Digest #"+digest+": Started  -> "+transitionStr);}; /** called by ui-router code */Trace.prototype.traceTransitionIgnored=function(transition){if(!this.enabled(Category.TRANSITION))return;var tid=transition.$id,digest=this.approximateDigests,transitionStr=strings_1.stringify(transition);console.log("Transition #"+tid+" Digest #"+digest+": Ignored  <> "+transitionStr);}; /** called by ui-router code */Trace.prototype.traceHookInvocation=function(step,options){if(!this.enabled(Category.HOOK))return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,event=hof_1.parse("traceData.hookType")(options)||"internal",context=hof_1.parse("traceData.context.state.name")(options)||hof_1.parse("traceData.context")(options)||"unknown",name=strings_1.functionToString(step.fn);console.log("Transition #"+tid+" Digest #"+digest+":   Hook -> "+event+" context: "+context+", "+strings_1.maxLength(200,name));}; /** called by ui-router code */Trace.prototype.traceHookResult=function(hookResult,transitionResult,transitionOptions){if(!this.enabled(Category.HOOK))return;var tid=hof_1.parse("transition.$id")(transitionOptions),digest=this.approximateDigests,hookResultStr=strings_1.stringify(hookResult),transitionResultStr=strings_1.stringify(transitionResult);console.log("Transition #"+tid+" Digest #"+digest+":   <- Hook returned: "+strings_1.maxLength(200,hookResultStr)+", transition result: "+strings_1.maxLength(200,transitionResultStr));}; /** called by ui-router code */Trace.prototype.traceResolvePath=function(path,options){if(!this.enabled(Category.RESOLVE))return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,pathStr=path&&path.toString(),policyStr=options&&options.resolvePolicy;console.log("Transition #"+tid+" Digest #"+digest+":         Resolving "+pathStr+" ("+policyStr+")");}; /** called by ui-router code */Trace.prototype.traceResolvePathElement=function(pathElement,resolvablePromises,options){if(!this.enabled(Category.RESOLVE))return;if(!resolvablePromises.length)return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,resolvablePromisesStr=Object.keys(resolvablePromises).join(", "),pathElementStr=pathElement&&pathElement.toString(),policyStr=options&&options.resolvePolicy;console.log("Transition #"+tid+" Digest #"+digest+":         Resolve "+pathElementStr+" resolvables: ["+resolvablePromisesStr+"] ("+policyStr+")");}; /** called by ui-router code */Trace.prototype.traceResolveResolvable=function(resolvable,options){if(!this.enabled(Category.RESOLVE))return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,resolvableStr=resolvable&&resolvable.toString();console.log("Transition #"+tid+" Digest #"+digest+":               Resolving -> "+resolvableStr);}; /** called by ui-router code */Trace.prototype.traceResolvableResolved=function(resolvable,options){if(!this.enabled(Category.RESOLVE))return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,resolvableStr=resolvable&&resolvable.toString(),result=strings_1.stringify(resolvable.data);console.log("Transition #"+tid+" Digest #"+digest+":               <- Resolved  "+resolvableStr+" to: "+strings_1.maxLength(200,result));}; /** called by ui-router code */Trace.prototype.tracePathElementInvoke=function(node,fn,deps,options){if(!this.enabled(Category.INVOKE))return;var tid=hof_1.parse("transition.$id")(options),digest=this.approximateDigests,stateName=node&&node.state&&node.state.toString(),fnName=strings_1.functionToString(fn);console.log("Transition #"+tid+" Digest #"+digest+":         Invoke "+options.when+": context: "+stateName+" "+strings_1.maxLength(200,fnName));}; /** called by ui-router code */Trace.prototype.traceError=function(error,transition){if(!this.enabled(Category.TRANSITION))return;var tid=transition.$id,digest=this.approximateDigests,transitionStr=strings_1.stringify(transition);console.log("Transition #"+tid+" Digest #"+digest+": <- Rejected "+transitionStr+", reason: "+error);}; /** called by ui-router code */Trace.prototype.traceSuccess=function(finalState,transition){if(!this.enabled(Category.TRANSITION))return;var tid=transition.$id,digest=this.approximateDigests,state=finalState.name,transitionStr=strings_1.stringify(transition);console.log("Transition #"+tid+" Digest #"+digest+": <- Success  "+transitionStr+", final state: "+state);}; /** called by ui-router code */Trace.prototype.traceUiViewEvent=function(event,viewData,extra){if(extra===void 0){extra="";}if(!this.enabled(Category.UIVIEW))return;console.log("ui-view: "+strings_1.padString(30,event)+" "+uiViewString(viewData)+extra);}; /** called by ui-router code */Trace.prototype.traceUiViewConfigUpdated=function(viewData,context){if(!this.enabled(Category.UIVIEW))return;this.traceUiViewEvent("Updating",viewData," with ViewConfig from context='"+context+"'");}; /** called by ui-router code */Trace.prototype.traceUiViewScopeCreated=function(viewData,newScope){if(!this.enabled(Category.UIVIEW))return;this.traceUiViewEvent("Created scope for",viewData,", scope #"+newScope.$id);}; /** called by ui-router code */Trace.prototype.traceUiViewFill=function(viewData,html){if(!this.enabled(Category.UIVIEW))return;this.traceUiViewEvent("Fill",viewData," with: "+strings_1.maxLength(200,html));}; /** called by ui-router code */Trace.prototype.traceViewServiceEvent=function(event,viewConfig){if(!this.enabled(Category.VIEWCONFIG))return;console.log("$view.ViewConfig: "+event+" "+viewConfigString(viewConfig));}; /** called by ui-router code */Trace.prototype.traceViewServiceUiViewEvent=function(event,viewData){if(!this.enabled(Category.VIEWCONFIG))return;console.log("$view.ViewConfig: "+event+" "+uiViewString(viewData));};return Trace;}();exports.Trace=Trace; /**
		 * The [[Trace]] singleton
		 *
		 * @example
		 * ```js
		 *
		 * import {trace} from "angular-ui-router";
		 * trace.enable(1, 5);
		 * ```
		 */var trace=new Trace();exports.trace=trace; /***/}, /* 13 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /**
		 * This module contains APIs related to a Transition.
		 *
		 * See [[Transition]], [[$transitions]]
		 *
		 * @module transition
		 * @preferred
		 */ /** for typedoc */__export(__webpack_require__(14));__export(__webpack_require__(15));__export(__webpack_require__(10));__export(__webpack_require__(11));__export(__webpack_require__(16));__export(__webpack_require__(43)); /***/}, /* 14 */ /***/function(module,exports,__webpack_require__){ /** @module transition */ /** for typedoc */"use strict";var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(13); /**
		 * This class returns applicable TransitionHooks for a specific Transition instance.
		 *
		 * Hooks (IEventHook) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
		 * myTransition.onEnter(...).  The HookBuilder finds matching IEventHooks (where the match criteria is
		 * determined by the type of hook)
		 *
		 * The HookBuilder also converts IEventHooks objects to TransitionHook objects, which are used to run a Transition.
		 *
		 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
		 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
		 * in the Transition class, so we must also provide the Transition's _treeChanges)
		 *
		 */var HookBuilder=function(){function HookBuilder($transitions,transition,baseHookOptions){var _this=this;this.$transitions=$transitions;this.transition=transition;this.baseHookOptions=baseHookOptions; // TODO: These get* methods are returning different cardinalities of hooks
	// onBefore/onStart/onFinish/onSuccess/onError returns an array of hooks
	// onExit/onRetain/onEnter returns an array of arrays of hooks
	this.getOnBeforeHooks=function(){return _this._buildNodeHooks("onBefore","to",tupleSort(),undefined,{async:false});};this.getOnStartHooks=function(){return _this._buildNodeHooks("onStart","to",tupleSort());};this.getOnExitHooks=function(){return _this._buildNodeHooks("onExit","exiting",tupleSort(true),function(node){return {$state$:node.state};});};this.getOnRetainHooks=function(){return _this._buildNodeHooks("onRetain","retained",tupleSort(),function(node){return {$state$:node.state};});};this.getOnEnterHooks=function(){return _this._buildNodeHooks("onEnter","entering",tupleSort(),function(node){return {$state$:node.state};});};this.getOnFinishHooks=function(){return _this._buildNodeHooks("onFinish","to",tupleSort(),function(node){return {$treeChanges$:_this.treeChanges};});};this.getOnSuccessHooks=function(){return _this._buildNodeHooks("onSuccess","to",tupleSort(),undefined,{async:false,rejectIfSuperseded:false});};this.getOnErrorHooks=function(){return _this._buildNodeHooks("onError","to",tupleSort(),undefined,{async:false,rejectIfSuperseded:false});};this.treeChanges=transition.treeChanges();this.toState=common_1.tail(this.treeChanges.to).state;this.fromState=common_1.tail(this.treeChanges.from).state;this.transitionOptions=transition.options();}HookBuilder.prototype.asyncHooks=function(){var onStartHooks=this.getOnStartHooks();var onExitHooks=this.getOnExitHooks();var onRetainHooks=this.getOnRetainHooks();var onEnterHooks=this.getOnEnterHooks();var onFinishHooks=this.getOnFinishHooks();var asyncHooks=[onStartHooks,onExitHooks,onRetainHooks,onEnterHooks,onFinishHooks];return asyncHooks.reduce(common_1.unnestR,[]).filter(common_1.identity);}; /**
		     * Returns an array of newly built TransitionHook objects.
		     *
		     * - Finds all IEventHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
		     * - Finds [[Node]] (or `Node[]`) to use as the TransitionHook context(s)
		     * - For each of the [[Node]]s, creates a TransitionHook
		     *
		     * @param hookType the name of the hook registration function, e.g., 'onEnter', 'onFinish'.
		     * @param matchingNodesProp selects which [[Node]]s from the [[IMatchingNodes]] object to create hooks for.
		     * @param getLocals a function which accepts a [[Node]] and returns additional locals to provide to the hook as injectables
		     * @param sortHooksFn a function which compares two HookTuple and returns <1, 0, or >1
		     * @param options any specific Transition Hook Options
		     */HookBuilder.prototype._buildNodeHooks=function(hookType,matchingNodesProp,sortHooksFn,getLocals,options){var _this=this;if(getLocals===void 0){getLocals=function getLocals(node){return {};};} // Find all the matching registered hooks for a given hook type
	var matchingHooks=this._matchingHooks(hookType,this.treeChanges);if(!matchingHooks)return [];var makeTransitionHooks=function makeTransitionHooks(hook){ // Fetch the Nodes that caused this hook to match.
	var matches=hook.matches(_this.treeChanges); // Select the Node[] that will be used as TransitionHook context objects
	var nodes=matches[matchingNodesProp]; // Return an array of HookTuples
	return nodes.map(function(node){var _options=common_1.extend({bind:hook.bind,traceData:{hookType:hookType,context:node}},_this.baseHookOptions,options);var transitionHook=new module_1.TransitionHook(hook.callback,getLocals(node),node.resolveContext,_options);return {hook:hook,node:node,transitionHook:transitionHook};});};return matchingHooks.map(makeTransitionHooks).reduce(common_1.unnestR,[]).sort(sortHooksFn).map(function(tuple){return tuple.transitionHook;});}; /**
		     * Finds all IEventHooks from:
		     * - The Transition object instance hook registry
		     * - The TransitionService ($transitions) global hook registry
		     *
		     * which matched:
		     * - the eventType
		     * - the matchCriteria (to, from, exiting, retained, entering)
		     *
		     * @returns an array of matched [[IEventHook]]s
		     */HookBuilder.prototype._matchingHooks=function(hookName,treeChanges){return [this.transition,this.$transitions] // Instance and Global hook registries
	.map(function(reg){return reg.getHooks(hookName);}) // Get named hooks from registries
	.filter(common_1.assertPredicate(predicates_1.isArray,"broken event named: "+hookName)) // Sanity check
	.reduce(common_1.unnestR,[]) // Un-nest IEventHook[][] to IEventHook[] array
	.filter(function(hook){return hook.matches(treeChanges);}); // Only those satisfying matchCriteria
	};return HookBuilder;}();exports.HookBuilder=HookBuilder; /**
		 * A factory for a sort function for HookTuples.
		 *
		 * The sort function first compares the Node depth (how deep in the state tree a node is), then compares
		 * the EventHook priority.
		 *
		 * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
		 * @returns a tuple sort function
		 */function tupleSort(reverseDepthSort){if(reverseDepthSort===void 0){reverseDepthSort=false;}return function nodeDepthThenPriority(l,r){var factor=reverseDepthSort?-1:1;var depthDelta=(l.node.state.path.length-r.node.state.path.length)*factor;return depthDelta!==0?depthDelta:r.hook.priority-l.hook.priority;};} /***/}, /* 15 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module transition */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var glob_1=__webpack_require__(7); /**
		 * Determines if the given state matches the matchCriteria
		 * @param state a State Object to test against
		 * @param criterion
		 * - If a string, matchState uses the string as a glob-matcher against the state name
		 * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
		 *   and returns a positive match if any of the globs match.
		 * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
		 * @returns {boolean}
		 */function matchState(state,criterion){var toMatch=predicates_1.isString(criterion)?[criterion]:criterion;function matchGlobs(_state){var globStrings=toMatch;for(var i=0;i<globStrings.length;i++){var glob=glob_1.Glob.fromString(globStrings[i]);if(glob&&glob.matches(_state.name)||!glob&&globStrings[i]===_state.name){return true;}}return false;}var matchFn=predicates_1.isFunction(toMatch)?toMatch:matchGlobs;return !!matchFn(state);}exports.matchState=matchState;var EventHook=function(){function EventHook(matchCriteria,callback,options){if(options===void 0){options={};}this.callback=callback;this.matchCriteria=common_1.extend({to:true,from:true,exiting:true,retained:true,entering:true},matchCriteria);this.priority=options.priority||0;this.bind=options.bind||null;}EventHook._matchingNodes=function(nodes,criterion){if(criterion===true)return nodes;var matching=nodes.filter(function(node){return matchState(node.state,criterion);});return matching.length?matching:null;}; /**
		     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
		     *
		     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
		     * are the matching [[Node]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
		     */EventHook.prototype.matches=function(treeChanges){var mc=this.matchCriteria,_matchingNodes=EventHook._matchingNodes;var matches={to:_matchingNodes([common_1.tail(treeChanges.to)],mc.to),from:_matchingNodes([common_1.tail(treeChanges.from)],mc.from),exiting:_matchingNodes(treeChanges.exiting,mc.exiting),retained:_matchingNodes(treeChanges.retained,mc.retained),entering:_matchingNodes(treeChanges.entering,mc.entering)}; // Check if all the criteria matched the TreeChanges object
	var allMatched=["to","from","exiting","retained","entering"].map(function(prop){return matches[prop];}).reduce(common_1.allTrueR,true);return allMatched?matches:null;};return EventHook;}();exports.EventHook=EventHook; // Return a registration function of the requested type.
	function makeHookRegistrationFn(hooks,name){return function(matchObject,callback,options){if(options===void 0){options={};}var eventHook=new EventHook(matchObject,callback,options);hooks[name].push(eventHook);return function deregisterEventHook(){common_1.removeFrom(hooks[name])(eventHook);};};}var HookRegistry=function(){function HookRegistry(){var _this=this;this._transitionEvents={onBefore:[],onStart:[],onEnter:[],onRetain:[],onExit:[],onFinish:[],onSuccess:[],onError:[]};this.getHooks=function(name){return _this._transitionEvents[name];};this.onBefore=makeHookRegistrationFn(this._transitionEvents,"onBefore");this.onStart=makeHookRegistrationFn(this._transitionEvents,"onStart"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onEnter
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from' states,
		         * when the matched 'to' state is being entered. This function is injected with the entering state's resolves.
		         *
		         * This function can be injected with two additional special value:
		         * - **`$transition$`**: The current transition
		         * - **`$state$`**: The state being entered
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         */this.onEnter=makeHookRegistrationFn(this._transitionEvents,"onEnter"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onRetain
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,
		         * when the matched 'from' state is already active and is not being exited nor entered.
		         *
		         * This function can be injected with two additional special value:
		         * - **`$transition$`**: The current transition
		         * - **`$state$`**: The state that is retained
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         */this.onRetain=makeHookRegistrationFn(this._transitionEvents,"onRetain"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onExit
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked during a transition between the matched 'to' and 'from states,
		         * when the matched 'from' state is being exited. This function is in injected with the exiting state's resolves.
		         *
		         * This function can be injected with two additional special value:
		         * - **`$transition$`**: The current transition
		         * - **`$state$`**: The state being entered
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         */this.onExit=makeHookRegistrationFn(this._transitionEvents,"onExit"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onFinish
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked when a transition is finished entering/exiting all states.
		         *
		         * This function can be injected with:
		         * - **`$transition$`**: The current transition
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback See callback in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         */this.onFinish=makeHookRegistrationFn(this._transitionEvents,"onFinish"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onSuccess
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked when a transition has successfully completed between the matched
		         * 'to' and 'from' state is being exited.
		         * This function is in injected with the 'to' state's resolves (note: `JIT` resolves are not injected).
		         *
		         * This function can be injected with two additional special value:
		         * - **`$transition$`**: The current transition
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.
		         *   The function's return value is ignored.
		         */this.onSuccess=makeHookRegistrationFn(this._transitionEvents,"onSuccess"); /**
		         * @ngdoc function
		         * @name ui.router.state.$transitionsProvider#onError
		         * @methodOf ui.router.state.$transitionsProvider
		         *
		         * @description
		         * Registers a function to be injected and invoked when a transition has failed for any reason between the matched
		         * 'to' and 'from' state. The transition rejection reason is injected as `$error$`.
		         *
		         * @param {object} matchObject See transitionCriteria in {@link ui.router.state.$transitionsProvider#on $transitionsProvider.on}.
		         * @param {function} callback The function which will be injected and invoked, when a matching transition is started.
		         *   The function's return value is ignored.
		         */this.onError=makeHookRegistrationFn(this._transitionEvents,"onError");}HookRegistry.mixin=function(source,target){Object.keys(source._transitionEvents).concat(["getHooks"]).forEach(function(key){return target[key]=source[key];});};return HookRegistry;}();exports.HookRegistry=HookRegistry; /***/}, /* 16 */ /***/function(module,exports,__webpack_require__){"use strict";var common_1=__webpack_require__(3);var strings_1=__webpack_require__(9);var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5);var trace_1=__webpack_require__(12);var coreservices_1=__webpack_require__(6);var rejectFactory_1=__webpack_require__(10);var module_1=__webpack_require__(17);var REJECT=new rejectFactory_1.RejectFactory();var defaultOptions={async:true,rejectIfSuperseded:true,current:common_1.noop,transition:null,traceData:{},bind:null};var TransitionHook=function(){function TransitionHook(fn,locals,resolveContext,options){var _this=this;this.fn=fn;this.locals=locals;this.resolveContext=resolveContext;this.options=options;this.isSuperseded=function(){return _this.options.current()!==_this.options.transition;}; /**
		         * Handles transition abort and transition redirect. Also adds any returned resolvables
		         * to the pathContext for the current pathElement.  If the transition is rejected, then a rejected
		         * promise is returned here, otherwise undefined is returned.
		         */this.mapHookResult=hof_1.pattern([ // Transition is no longer current
	[this.isSuperseded,function(){return REJECT.superseded(_this.options.current());}], // If the hook returns false, abort the current Transition
	[hof_1.eq(false),function(){return REJECT.aborted("Hook aborted transition");}], // If the hook returns a Transition, halt the current Transition and redirect to that Transition.
	[hof_1.is(module_1.TargetState),function(target){return REJECT.redirected(target);}], // A promise was returned, wait for the promise and then chain another hookHandler
	[predicates_1.isPromise,function(promise){return promise.then(_this.handleHookResult.bind(_this));}]]);this.invokeStep=function(moreLocals){var _a=_this,options=_a.options,fn=_a.fn,resolveContext=_a.resolveContext;var locals=common_1.extend({},_this.locals,moreLocals);trace_1.trace.traceHookInvocation(_this,options);if(options.rejectIfSuperseded&&_this.isSuperseded()){return REJECT.superseded(options.current());} // TODO: Need better integration of returned promises in synchronous code.
	if(!options.async){var hookResult=resolveContext.invokeNow(fn,locals,options);return _this.handleHookResult(hookResult);}return resolveContext.invokeLater(fn,locals,options).then(_this.handleHookResult.bind(_this));};this.options=common_1.defaults(options,defaultOptions);}TransitionHook.prototype.handleHookResult=function(hookResult){if(!predicates_1.isDefined(hookResult))return undefined;trace_1.trace.traceHookResult(hookResult,undefined,this.options);var transitionResult=this.mapHookResult(hookResult);if(transitionResult)trace_1.trace.traceHookResult(hookResult,transitionResult,this.options);return transitionResult;};TransitionHook.prototype.toString=function(){var _a=this,options=_a.options,fn=_a.fn;var event=hof_1.parse("traceData.hookType")(options)||"internal",context=hof_1.parse("traceData.context.state.name")(options)||hof_1.parse("traceData.context")(options)||"unknown",name=strings_1.fnToString(fn);return event+" context: "+context+", "+strings_1.maxLength(200,name);}; /**
		     * Given an array of TransitionHooks, runs each one synchronously and sequentially.
		     *
		     * Returns a promise chain composed of any promises returned from each hook.invokeStep() call
		     */TransitionHook.runSynchronousHooks=function(hooks,locals,swallowExceptions){if(locals===void 0){locals={};}if(swallowExceptions===void 0){swallowExceptions=false;}var results=[];for(var i=0;i<hooks.length;i++){try{results.push(hooks[i].invokeStep(locals));}catch(exception){if(!swallowExceptions)return REJECT.aborted(exception);console.log("Swallowed exception during synchronous hook handler: "+exception); // TODO: What to do here?
	}}var rejections=results.filter(TransitionHook.isRejection);if(rejections.length)return rejections[0];return results.filter(hof_1.not(TransitionHook.isRejection)).filter(predicates_1.isPromise).reduce(function(chain,promise){return chain.then(hof_1.val(promise));},coreservices_1.services.$q.when());};TransitionHook.isRejection=function(hookResult){return hookResult&&hookResult.reason instanceof rejectFactory_1.TransitionRejection&&hookResult;};return TransitionHook;}();exports.TransitionHook=TransitionHook; /***/}, /* 17 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module state */ /** for typedoc */__export(__webpack_require__(18));__export(__webpack_require__(19));__export(__webpack_require__(26));__export(__webpack_require__(33));__export(__webpack_require__(34));__export(__webpack_require__(35));__export(__webpack_require__(36));__export(__webpack_require__(37));__export(__webpack_require__(27)); /***/}, /* 18 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var predicates_1=__webpack_require__(4);var common_1=__webpack_require__(3); /**
		 * @ngdoc object
		 * @name ui.router.state.$stateProvider
		 *
		 * @requires ui.router.router.$urlRouterProvider
		 * @requires ui.router.util.$urlMatcherFactoryProvider
		 *
		 * @description
		 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
		 * on state.
		 *
		 * A state corresponds to a "place" in the application in terms of the overall UI and
		 * navigation. A state describes (via the controller / template / view properties) what
		 * the UI looks like and does at that place.
		 *
		 * States often have things in common, and the primary way of factoring out these
		 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
		 * nested states.
		 *
		 * The `$stateProvider` provides interfaces to declare these states for your app.
		 */var StateProvider=function(){function StateProvider(stateRegistry){this.stateRegistry=stateRegistry;this.invalidCallbacks=[];common_1.bindFunctions(StateProvider.prototype,this,this);} /**
		     * @ngdoc function
		     * @name ui.router.state.$stateProvider#decorator
		     * @methodOf ui.router.state.$stateProvider
		     *
		     * @description
		     * Allows you to extend (carefully) or override (at your own peril) the
		     * `stateBuilder` object used internally by `$stateProvider`. This can be used
		     * to add custom functionality to ui-router, for example inferring templateUrl
		     * based on the state name.
		     *
		     * When passing only a name, it returns the current (original or decorated) builder
		     * function that matches `name`.
		     *
		     * The builder functions that can be decorated are listed below. Though not all
		     * necessarily have a good use case for decoration, that is up to you to decide.
		     *
		     * In addition, users can attach custom decorators, which will generate new
		     * properties within the state's internal definition. There is currently no clear
		     * use-case for this beyond accessing internal states (i.e. $state.$current),
		     * however, expect this to become increasingly relevant as we introduce additional
		     * meta-programming features.
		     *
		     * **Warning**: Decorators should not be interdependent because the order of
		     * execution of the builder functions in non-deterministic. Builder functions
		     * should only be dependent on the state definition object and super function.
		     *
		     *
		     * Existing builder functions and current return values:
		     *
		     * - **parent** `{object}` - returns the parent state object.
		     * - **data** `{object}` - returns state data, including any inherited data that is not
		     *   overridden by own values (if any).
		     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
		     *   or `null`.
		     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
		     *   navigable).
		     * - **params** `{object}` - returns an array of state params that are ensured to
		     *   be a super-set of parent's params.
		     * - **views** `{object}` - returns a views object where each key is an absolute view
		     *   name (i.e. "viewName@stateName") and each value is the config object
		     *   (template, controller) for the view. Even when you don't use the views object
		     *   explicitly on a state config, one is still created for you internally.
		     *   So by decorating this builder function you have access to decorating template
		     *   and controller properties.
		     * - **ownParams** `{object}` - returns an array of params that belong to the state,
		     *   not including any params defined by ancestor states.
		     * - **path** `{string}` - returns the full path from the root down to this state.
		     *   Needed for state activation.
		     * - **includes** `{object}` - returns an object that includes every state that
		     *   would pass a `$state.includes()` test.
		     *
		     * @example
		     * <pre>
		     * // Override the internal 'views' builder with a function that takes the state
		     * // definition, and a reference to the internal function being overridden:
		     * $stateProvider.decorator('views', function (state, parent) {
		     *   let result = {},
		     *       views = parent(state);
		     *
		     *   angular.forEach(views, function (config, name) {
		     *     let autoName = (state.name + '.' + name).replace('.', '/');
		     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
		     *     result[name] = config;
		     *   });
		     *   return result;
		     * });
		     *
		     * $stateProvider.state('home', {
		     *   views: {
		     *     'contact.list': { controller: 'ListController' },
		     *     'contact.item': { controller: 'ItemController' }
		     *   }
		     * });
		     *
		     * // ...
		     *
		     * $state.go('home');
		     * // Auto-populates list and item views with /partials/home/contact/list.html,
		     * // and /partials/home/contact/item.html, respectively.
		     * </pre>
		     *
		     * @param {string} name The name of the builder function to decorate.
		     * @param {object} func A function that is responsible for decorating the original
		     * builder function. The function receives two parameters:
		     *
		     *   - `{object}` - state - The state config object.
		     *   - `{object}` - super - The original builder function.
		     *
		     * @return {object} $stateProvider - $stateProvider instance
		     */StateProvider.prototype.decorator=function(name,func){return this.stateRegistry.decorator(name,func)||this;}; /**
		     * @ngdoc function
		     * @name ui.router.state.$stateProvider#state
		     * @methodOf ui.router.state.$stateProvider
		     *
		     * @description
		     * Registers a state configuration under a given state name. The stateConfig object
		     * has the following acceptable properties.
		     *
		     * <a id='template'></a>
		     *
		     * - **`template`** - {string|function=} - html template as a string or a function that returns
		     *   an html template as a string which should be used by the uiView directives. This property
		     *   takes precedence over templateUrl.
		     *
		     *   If `template` is a function, it will be called with the following parameters:
		     *
		     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
		     *     applying the current state
		     *
		     * <a id='templateUrl'></a>
		     *
		     * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html
		     *   template that should be used by uiView.
		     *
		     *   If `templateUrl` is a function, it will be called with the following parameters:
		     *
		     *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
		     *     applying the current state
		     *
		     * <a id='templateProvider'></a>
		     *
		     * - **`templateProvider`** - {function=} - Provider function that returns HTML content
		     *   string.
		     *
		     * <a id='controller'></a>
		     *
		     * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly
		     *   related scope or the name of a registered controller if passed as a string.
		     *
		     * <a id='controllerProvider'></a>
		     *
		     * - **`controllerProvider`** - {function=} - Injectable provider function that returns
		     *   the actual controller or string.
		     *
		     * <a id='controllerAs'></a>
		     *
		     * - **`controllerAs`** – {string=} – A controller alias name. If present the controller will be
		     *   published to scope under the controllerAs name.
		     *
		     * <a id='resolve'></a>
		     *
		     * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which
		     *   should be injected into the controller. If any of these dependencies are promises,
		     *   the router will wait for them all to be resolved or one to be rejected before the
		     *   controller is instantiated. If all the promises are resolved successfully, the values
		     *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any
		     *   of the promises are rejected the $stateChangeError event is fired. The map object is:
		     *
		     *   - key - {string}: name of dependency to be injected into controller
		     *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,
		     *     it is injected and return value it treated as dependency. If result is a promise, it is
		     *     resolved before its value is injected into controller.
		     *
		     * <a id='url'></a>
		     *
		     * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or
		     *   transitioned to, the `$stateParams` service will be populated with any
		     *   parameters that were passed.
		     *
		     * <a id='params'></a>
		     *
		     * - **`params`** - {object=} - An array of parameter names or regular expressions. Only
		     *   use this within a state if you are not using url. Otherwise you can specify your
		     *   parameters within the url. When a state is navigated or transitioned to, the
		     *   $stateParams service will be populated with any parameters that were passed.
		     *
		     * <a id='views'></a>
		     *
		     * - **`views`** - {object=} - Use the views property to set up multiple views or to target views
		     *   manually/explicitly.
		     *
		     * <a id='abstract'></a>
		     *
		     * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,
		     *   but can provide inherited properties to its common children states.
		     *
		     * <a id='onEnter'></a>
		     *
		     * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way
		     *   to trigger an action or dispatch an event, such as opening a dialog.
		     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.
		     *
		     * <a id='onExit'></a>
		     *
		     * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to
		     *   trigger an action or dispatch an event, such as opening a dialog.
		     * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.
		     *
		     * <a id='reloadOnSearch'></a>
		     *
		     * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state
		     *   just because a search/query parameter has changed (via $location.search() or $location.hash()).
		     *   Useful for when you'd like to modify $location.search() without triggering a reload.
		     *
		     * <a id='data'></a>
		     *
		     * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.
		     *
		     * @example
		     * <pre>
		     * // Some state name examples
		     *
		     * // stateName can be a single top-level name (must be unique).
		     * $stateProvider.state("home", {});
		     *
		     * // Or it can be a nested state name. This state is a child of the
		     * // above "home" state.
		     * $stateProvider.state("home.newest", {});
		     *
		     * // Nest states as deeply as needed.
		     * $stateProvider.state("home.newest.abc.xyz.inception", {});
		     *
		     * // state() returns $stateProvider, so you can chain state declarations.
		     * $stateProvider
		     *   .state("home", {})
		     *   .state("about", {})
		     *   .state("contacts", {});
		     * </pre>
		     *
		     * @param {string} name A unique state name, e.g. "home", "about", "contacts".
		     * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
		     * @param {object} definition State configuration object.
		     */StateProvider.prototype.state=function(name,definition){if(predicates_1.isObject(name)){definition=name;}else {definition.name=name;}this.stateRegistry.register(definition);return this;}; /**
		     * @ngdoc function
		     * @name ui.router.state.$stateProvider#onInvalid
		     * @methodOf ui.router.state.$stateProvider
		     *
		     * @description
		     * Registers a function to be injected and invoked when transitionTo has been called with an invalid
		     * state reference parameter
		     *
		     * This function can be injected with one some special values:
		     * - **`$to$`**: TargetState
		     * - **`$from$`**: TargetState
		     *
		     * @param {function} callback
		     *   The function which will be injected and invoked, when a matching transition is started.
		     *   The function may optionally return a {TargetState} or a Promise for a TargetState.  If one
		     *   is returned, it is treated as a redirect.
		     */StateProvider.prototype.onInvalid=function(callback){this.invalidCallbacks.push(callback);};return StateProvider;}();exports.StateProvider=StateProvider; /***/}, /* 19 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5);var module_1=__webpack_require__(20);var parseUrl=function parseUrl(url){if(!predicates_1.isString(url))return false;var root=url.charAt(0)==='^';return {val:root?url.substring(1):url,root:root};}; /**
		 * @internalapi A internal global service
		 *
		 * StateBuilder is a factory for the internal [[State]] objects.
		 *
		 * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
		 * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
		 * [[State]] object, which has an API and is used internally.
		 *
		 * Custom properties or API may be added to the internal [[State]] object by registering a decorator function
		 * using the [[builder]] method.
		 */var StateBuilder=function(){function StateBuilder(matcher,$urlMatcherFactoryProvider){this.matcher=matcher;var self=this;var isRoot=function isRoot(state){return state.name==="";};var root=function root(){return matcher.find("");};this.builders={self:[function(state){state.self.$$state=function(){return state;};return state.self;}],parent:[function(state){if(isRoot(state))return null;return matcher.find(self.parentName(state))||root();}],data:[function(state){if(state.parent&&state.parent.data){state.data=state.self.data=common_1.inherit(state.parent.data,state.data);}return state.data;}], // Build a URLMatcher if necessary, either via a relative or absolute URL
	url:[function(state){var stateDec=state;var parsed=parseUrl(stateDec.url),parent=state.parent;var url=!parsed?stateDec.url:$urlMatcherFactoryProvider.compile(parsed.val,{params:state.params||{},paramMap:function paramMap(paramConfig,isSearch){if(stateDec.reloadOnSearch===false&&isSearch)paramConfig=common_1.extend(paramConfig||{},{dynamic:true});return paramConfig;}});if(!url)return null;if(!$urlMatcherFactoryProvider.isMatcher(url))throw new Error("Invalid url '"+url+"' in state '"+state+"'");return parsed&&parsed.root?url:(parent&&parent.navigable||root()).url.append(url);}], // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
	navigable:[function(state){return !isRoot(state)&&state.url?state:state.parent?state.parent.navigable:null;}],params:[function(state){var makeConfigParam=function makeConfigParam(config,id){return module_1.Param.fromConfig(id,null,config);};var urlParams=state.url&&state.url.parameters({inherit:false})||[];var nonUrlParams=common_1.values(common_1.map(common_1.omit(state.params||{},urlParams.map(hof_1.prop('id'))),makeConfigParam));return urlParams.concat(nonUrlParams).map(function(p){return [p.id,p];}).reduce(common_1.applyPairs,{});}], // Each framework-specific ui-router implementation should define its own `views` builder
	// e.g., src/ng1/viewsBuilder.ts
	views:[], // Keep a full path from the root down to this state as this is needed for state activation.
	path:[function(state){return state.parent?state.parent.path.concat(state):[state];}], // Speed up $state.includes() as it's used a lot
	includes:[function(state){var includes=state.parent?common_1.extend({},state.parent.includes):{};includes[state.name]=true;return includes;}]};} /**
		     * Registers a [[BuilderFunction]] for a specific [[State]] property (e.g., `parent`, `url`, or `path`).
		     * More than one BuilderFunction can be registered for a given property.
		     *
		     * The BuilderFunction(s) will be used to define the property on any subsequently built [[State]] objects.
		     *
		     * @param name The name of the State property being registered for.
		     * @param fn The BuilderFunction which will be used to build the State property
		     * @returns a function which deregisters the BuilderFunction
		     */StateBuilder.prototype.builder=function(name,fn){var builders=this.builders;var array=builders[name]||[]; // Backwards compat: if only one builder exists, return it, else return whole arary.
	if(predicates_1.isString(name)&&!predicates_1.isDefined(fn))return array.length>1?array:array[0];if(!predicates_1.isString(name)||!predicates_1.isFunction(fn))return;builders[name]=array;builders[name].push(fn);return function(){return builders[name].splice(builders[name].indexOf(fn,1))&&null;};}; /**
		     * Builds all of the properties on an essentially blank State object, returning a State object which has all its
		     * properties and API built.
		     *
		     * @param state an uninitialized State object
		     * @returns the built State object
		     */StateBuilder.prototype.build=function(state){var _a=this,matcher=_a.matcher,builders=_a.builders;var parent=this.parentName(state);if(parent&&!matcher.find(parent))return null;for(var key in builders){if(!builders.hasOwnProperty(key))continue;var chain=builders[key].reduce(function(parentFn,step){return function(_state){return step(_state,parentFn);};},common_1.noop);state[key]=chain(state);}return state;};StateBuilder.prototype.parentName=function(state){var name=state.name||"";if(name.indexOf('.')!==-1)return name.substring(0,name.lastIndexOf('.'));if(!state.parent)return "";return predicates_1.isString(state.parent)?state.parent:state.parent.name;};StateBuilder.prototype.name=function(state){var name=state.name;if(name.indexOf('.')!==-1||!state.parent)return name;var parentName=predicates_1.isString(state.parent)?state.parent:state.parent.name;return parentName?parentName+"."+name:name;};return StateBuilder;}();exports.StateBuilder=StateBuilder; /***/}, /* 20 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /**
		 * This module contains code for State Parameters.
		 *
		 * See [[ParamDeclaration]]
		 * @module params
		 * @preferred doc
		 */ /** for typedoc */__export(__webpack_require__(21));__export(__webpack_require__(24));__export(__webpack_require__(25));__export(__webpack_require__(23)); /***/}, /* 21 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module params */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var coreservices_1=__webpack_require__(6);var urlMatcherConfig_1=__webpack_require__(22);var type_1=__webpack_require__(23);var paramTypes_1=__webpack_require__(24);var hasOwn=Object.prototype.hasOwnProperty;var isShorthand=function isShorthand(cfg){return ["value","type","squash","array","dynamic"].filter(hasOwn.bind(cfg||{})).length===0;};(function(DefType){DefType[DefType["PATH"]=0]="PATH";DefType[DefType["SEARCH"]=1]="SEARCH";DefType[DefType["CONFIG"]=2]="CONFIG";})(exports.DefType||(exports.DefType={}));var DefType=exports.DefType;function unwrapShorthand(cfg){cfg=isShorthand(cfg)&&{value:cfg}||cfg;return common_1.extend(cfg,{$$fn:predicates_1.isInjectable(cfg.value)?cfg.value:function(){return cfg.value;}});}function getType(cfg,urlType,location,id){if(cfg.type&&urlType&&urlType.name!=='string')throw new Error("Param '"+id+"' has two type configurations.");if(cfg.type&&urlType&&urlType.name==='string'&&paramTypes_1.paramTypes.type(cfg.type))return paramTypes_1.paramTypes.type(cfg.type);if(urlType)return urlType;if(!cfg.type)return location===DefType.CONFIG?paramTypes_1.paramTypes.type("any"):paramTypes_1.paramTypes.type("string");return cfg.type instanceof type_1.Type?cfg.type:paramTypes_1.paramTypes.type(cfg.type);} /**
		 * returns false, true, or the squash value to indicate the "default parameter url squash policy".
		 */function getSquashPolicy(config,isOptional){var squash=config.squash;if(!isOptional||squash===false)return false;if(!predicates_1.isDefined(squash)||squash==null)return urlMatcherConfig_1.matcherConfig.defaultSquashPolicy();if(squash===true||predicates_1.isString(squash))return squash;throw new Error("Invalid squash policy: '"+squash+"'. Valid policies: false, true, or arbitrary string");}function getReplace(config,arrayMode,isOptional,squash){var replace,configuredKeys,defaultPolicy=[{from:"",to:isOptional||arrayMode?undefined:""},{from:null,to:isOptional||arrayMode?undefined:""}];replace=predicates_1.isArray(config.replace)?config.replace:[];if(predicates_1.isString(squash))replace.push({from:squash,to:undefined});configuredKeys=common_1.map(replace,hof_1.prop("from"));return common_1.filter(defaultPolicy,function(item){return configuredKeys.indexOf(item.from)===-1;}).concat(replace);}var Param=function(){function Param(id,type,config,location){config=unwrapShorthand(config);type=getType(config,type,location,id);var arrayMode=getArrayMode();type=arrayMode?type.$asArray(arrayMode,location===DefType.SEARCH):type;var isOptional=config.value!==undefined;var dynamic=config.dynamic===true;var squash=getSquashPolicy(config,isOptional);var replace=getReplace(config,arrayMode,isOptional,squash); // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
	function getArrayMode(){var arrayDefaults={array:location===DefType.SEARCH?"auto":false};var arrayParamNomenclature=id.match(/\[\]$/)?{array:true}:{};return common_1.extend(arrayDefaults,arrayParamNomenclature,config).array;}common_1.extend(this,{id:id,type:type,location:location,squash:squash,replace:replace,isOptional:isOptional,dynamic:dynamic,config:config,array:arrayMode});}Param.prototype.isDefaultValue=function(value){return this.isOptional&&this.type.equals(this.value(),value);}; /**
		     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
		     * default value, which may be the result of an injectable function.
		     */Param.prototype.value=function(value){var _this=this; /**
		         * [Internal] Get the default value of a parameter, which may be an injectable function.
		         */var $$getDefaultValue=function $$getDefaultValue(){if(!coreservices_1.services.$injector)throw new Error("Injectable functions cannot be called at configuration time");var defaultValue=coreservices_1.services.$injector.invoke(_this.config.$$fn);if(defaultValue!==null&&defaultValue!==undefined&&!_this.type.is(defaultValue))throw new Error("Default value ("+defaultValue+") for parameter '"+_this.id+"' is not an instance of Type ("+_this.type.name+")");return defaultValue;};var $replace=function $replace(val){var replacement=common_1.map(common_1.filter(_this.replace,hof_1.propEq('from',val)),hof_1.prop("to"));return replacement.length?replacement[0]:val;};value=$replace(value);return !predicates_1.isDefined(value)?$$getDefaultValue():this.type.$normalize(value);};Param.prototype.isSearch=function(){return this.location===DefType.SEARCH;};Param.prototype.validates=function(value){ // There was no parameter value, but the param is optional
	if((!predicates_1.isDefined(value)||value===null)&&this.isOptional)return true; // The value was not of the correct Type, and could not be decoded to the correct Type
	var normalized=this.type.$normalize(value);if(!this.type.is(normalized))return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
	var encoded=this.type.encode(normalized);return !(predicates_1.isString(encoded)&&!this.type.pattern.exec(encoded));};Param.prototype.toString=function(){return "{Param:"+this.id+" "+this.type+" squash: '"+this.squash+"' optional: "+this.isOptional+"}";}; /** Creates a new [[Param]] from a CONFIG block */Param.fromConfig=function(id,type,config){return new Param(id,type,config,DefType.CONFIG);}; /** Creates a new [[Param]] from a url PATH */Param.fromPath=function(id,type,config){return new Param(id,type,config,DefType.PATH);}; /** Creates a new [[Param]] from a url SEARCH */Param.fromSearch=function(id,type,config){return new Param(id,type,config,DefType.SEARCH);};Param.values=function(params,values){if(values===void 0){values={};}return params.map(function(param){return [param.id,param.value(values[param.id])];}).reduce(common_1.applyPairs,{});}; /**
		     * Finds [[Param]] objects which have different param values
		     *
		     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
		     *
		     * @param params: The list of Param objects to filter
		     * @param values1: The first set of parameter values
		     * @param values2: the second set of parameter values
		     *
		     * @returns any Param objects whose values were different between values1 and values2
		     */Param.changed=function(params,values1,values2){if(values1===void 0){values1={};}if(values2===void 0){values2={};}return params.filter(function(param){return !param.type.equals(values1[param.id],values2[param.id]);});}; /**
		     * Checks if two param value objects are equal (for a set of [[Param]] objects)
		     *
		     * @param params The list of [[Param]] objects to check
		     * @param values1 The first set of param values
		     * @param values2 The second set of param values
		     *
		     * @returns true if the param values in values1 and values2 are equal
		     */Param.equals=function(params,values1,values2){if(values1===void 0){values1={};}if(values2===void 0){values2={};}return Param.changed(params,values1,values2).length===0;}; /** Returns true if a the parameter values are valid, according to the Param definitions */Param.validates=function(params,values){if(values===void 0){values={};}return params.map(function(param){return param.validates(values[param.id]);}).reduce(common_1.allTrueR,true);};return Param;}();exports.Param=Param; /***/}, /* 22 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module url */ /** for typedoc */var predicates_1=__webpack_require__(4);var MatcherConfig=function(){function MatcherConfig(){this._isCaseInsensitive=false;this._isStrictMode=true;this._defaultSquashPolicy=false;}MatcherConfig.prototype.caseInsensitive=function(value){return this._isCaseInsensitive=predicates_1.isDefined(value)?value:this._isCaseInsensitive;};MatcherConfig.prototype.strictMode=function(value){return this._isStrictMode=predicates_1.isDefined(value)?value:this._isStrictMode;};MatcherConfig.prototype.defaultSquashPolicy=function(value){if(predicates_1.isDefined(value)&&value!==true&&value!==false&&!predicates_1.isString(value))throw new Error("Invalid squash policy: "+value+". Valid policies: false, true, arbitrary-string");return this._defaultSquashPolicy=predicates_1.isDefined(value)?value:this._defaultSquashPolicy;};return MatcherConfig;}();exports.MatcherConfig=MatcherConfig; // TODO: Do not export global instance; create one in UIRouter() constructor
	exports.matcherConfig=new MatcherConfig(); /***/}, /* 23 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module params */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4); /**
		 * Wraps up a `Type` object to handle array values.
		 */function ArrayType(type,mode){var _this=this; // Wrap non-array value as array
	function arrayWrap(val){return predicates_1.isArray(val)?val:predicates_1.isDefined(val)?[val]:[];} // Unwrap array value for "auto" mode. Return undefined for empty array.
	function arrayUnwrap(val){switch(val.length){case 0:return undefined;case 1:return mode==="auto"?val[0]:val;default:return val;}} // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
	function arrayHandler(callback,allTruthyMode){return function handleArray(val){if(predicates_1.isArray(val)&&val.length===0)return val;var arr=arrayWrap(val);var result=common_1.map(arr,callback);return allTruthyMode===true?common_1.filter(result,function(x){return !x;}).length===0:arrayUnwrap(result);};} // Wraps type (.equals) functions to operate on each value of an array
	function arrayEqualsHandler(callback){return function handleArray(val1,val2){var left=arrayWrap(val1),right=arrayWrap(val2);if(left.length!==right.length)return false;for(var i=0;i<left.length;i++){if(!callback(left[i],right[i]))return false;}return true;};}['encode','decode','equals','$normalize'].map(function(name){_this[name]=(name==='equals'?arrayEqualsHandler:arrayHandler)(type[name].bind(type));});common_1.extend(this,{name:type.name,pattern:type.pattern,is:arrayHandler(type.is.bind(type),true),$arrayMode:mode});} /**
		 * Implements an interface to define custom parameter types that can be decoded from and encoded to
		 * string parameters matched in a URL. Used by [[UrlMatcher]]
		 * objects when matching or formatting URLs, or comparing or validating parameter values.
		 *
		 * See [[UrlMatcherFactory.type]] for more information on registering custom types.
		 *
		 * @example
		 * ```
		 *
		 * {
		 *   decode: function(val) { return parseInt(val, 10); },
		 *   encode: function(val) { return val && val.toString(); },
		 *   equals: function(a, b) { return this.is(a) && a === b; },
		 *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
		 *   pattern: /\d+/
		 * }
		 * ```
		 */var Type=function(){ /**
		     * @param def  A configuration object which contains the custom type definition.  The object's
		     *        properties will override the default methods and/or pattern in `Type`'s public interface.
		     * @returns a new Type object
		     */function Type(def){this.pattern=/.*/;common_1.extend(this,def);} // consider these four methods to be "abstract methods" that should be overridden
	/** @inheritdoc */Type.prototype.is=function(val,key){return true;}; /** @inheritdoc */Type.prototype.encode=function(val,key){return val;}; /** @inheritdoc */Type.prototype.decode=function(val,key){return val;}; /** @inheritdoc */Type.prototype.equals=function(a,b){return a==b;};Type.prototype.$subPattern=function(){var sub=this.pattern.toString();return sub.substr(1,sub.length-2);};Type.prototype.toString=function(){return "{Type:"+this.name+"}";}; /** Given an encoded string, or a decoded object, returns a decoded object */Type.prototype.$normalize=function(val){return this.is(val)?val:this.decode(val);}; /**
		     * Wraps an existing custom Type as an array of Type, depending on 'mode'.
		     * e.g.:
		     * - urlmatcher pattern "/path?{queryParam[]:int}"
		     * - url: "/path?queryParam=1&queryParam=2
		     * - $stateParams.queryParam will be [1, 2]
		     * if `mode` is "auto", then
		     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
		     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
		     */Type.prototype.$asArray=function(mode,isSearch){if(!mode)return this;if(mode==="auto"&&!isSearch)throw new Error("'auto' array mode is for query parameters only");return new ArrayType(this,mode);};return Type;}();exports.Type=Type; /***/}, /* 24 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module params */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5);var coreservices_1=__webpack_require__(6);var type_1=__webpack_require__(23); // Use tildes to pre-encode slashes.
	// If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
	// and bidirectional encoding/decoding fails.
	// Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
	function valToString(val){return val!=null?val.toString().replace(/~/g,"~~").replace(/\//g,"~2F"):val;}function valFromString(val){return val!=null?val.toString().replace(/~2F/g,"/").replace(/~~/g,"~"):val;}var ParamTypes=function(){function ParamTypes(){this.enqueue=true;this.typeQueue=[];this.defaultTypes={"hash":{encode:valToString,decode:valFromString,is:hof_1.is(String),pattern:/.*/,equals:hof_1.val(true)},"string":{encode:valToString,decode:valFromString,is:hof_1.is(String),pattern:/[^/]*/},"int":{encode:valToString,decode:function decode(val){return parseInt(val,10);},is:function is(val){return predicates_1.isDefined(val)&&this.decode(val.toString())===val;},pattern:/-?\d+/},"bool":{encode:function encode(val){return val&&1||0;},decode:function decode(val){return parseInt(val,10)!==0;},is:hof_1.is(Boolean),pattern:/0|1/},"date":{encode:function encode(val){return !this.is(val)?undefined:[val.getFullYear(),('0'+(val.getMonth()+1)).slice(-2),('0'+val.getDate()).slice(-2)].join("-");},decode:function decode(val){if(this.is(val))return val;var match=this.capture.exec(val);return match?new Date(match[1],match[2]-1,match[3]):undefined;},is:function is(val){return val instanceof Date&&!isNaN(val.valueOf());},equals:function equals(l,r){return ['getFullYear','getMonth','getDate'].reduce(function(acc,fn){return acc&&l[fn]()===r[fn]();},true);},pattern:/[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,capture:/([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/},"json":{encode:common_1.toJson,decode:common_1.fromJson,is:hof_1.is(Object),equals:common_1.equals,pattern:/[^/]*/},"any":{encode:common_1.identity,decode:common_1.identity,equals:common_1.equals,pattern:/.*/}}; // Register default types. Store them in the prototype of this.types.
	var makeType=function makeType(definition,name){return new type_1.Type(common_1.extend({name:name},definition));};this.types=common_1.inherit(common_1.map(this.defaultTypes,makeType),{});}ParamTypes.prototype.type=function(name,definition,definitionFn){if(!predicates_1.isDefined(definition))return this.types[name];if(this.types.hasOwnProperty(name))throw new Error("A type named '"+name+"' has already been defined.");this.types[name]=new type_1.Type(common_1.extend({name:name},definition));if(definitionFn){this.typeQueue.push({name:name,def:definitionFn});if(!this.enqueue)this._flushTypeQueue();}return this;};ParamTypes.prototype._flushTypeQueue=function(){while(this.typeQueue.length){var type=this.typeQueue.shift();if(type.pattern)throw new Error("You cannot override a type's .pattern at runtime.");common_1.extend(this.types[type.name],coreservices_1.services.$injector.invoke(type.def));}};return ParamTypes;}();exports.ParamTypes=ParamTypes;exports.paramTypes=new ParamTypes(); /***/}, /* 25 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module params */ /** for typedoc */var common_1=__webpack_require__(3);var StateParams=function(){function StateParams(params){if(params===void 0){params={};}common_1.extend(this,params);} /**
		     * Merges a set of parameters with all parameters inherited between the common parents of the
		     * current state and a given destination state.
		     *
		     * @param {Object} newParams The set of parameters which will be composited with inherited params.
		     * @param {Object} $current Internal definition of object representing the current state.
		     * @param {Object} $to Internal definition of object representing state to transition to.
		     */StateParams.prototype.$inherit=function(newParams,$current,$to){var parents=common_1.ancestors($current,$to),parentParams,inherited={},inheritList=[];for(var i in parents){if(!parents[i]||!parents[i].params)continue;parentParams=Object.keys(parents[i].params);if(!parentParams.length)continue;for(var j in parentParams){if(inheritList.indexOf(parentParams[j])>=0)continue;inheritList.push(parentParams[j]);inherited[parentParams[j]]=this[parentParams[j]];}}return common_1.extend({},inherited,newParams);};;return StateParams;}();exports.StateParams=StateParams; /***/}, /* 26 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var hof_1=__webpack_require__(5);var param_1=__webpack_require__(21);var rejectFactory_1=__webpack_require__(10);var targetState_1=__webpack_require__(27);var viewHooks_1=__webpack_require__(28);var enterExitHooks_1=__webpack_require__(29);var resolveHooks_1=__webpack_require__(30);var coreservices_1=__webpack_require__(6); /**
		 * This class:
		 *
		 * * Takes a blank transition object and adds all the hooks necessary for it to behave like a state transition.
		 *
		 * * Runs the transition, returning a chained promise which:
		 *   * transforms the resolved Transition.promise to the final destination state.
		 *   * manages the rejected Transition.promise, checking for Dynamic or Redirected transitions
		 *
		 * * Registers a handler to update global $state data such as "active transitions" and "current state/params"
		 *
		 * * Registers view hooks, which maintain the list of active view configs and sync with/update the ui-views
		 *
		 * * Registers onEnter/onRetain/onExit hooks which delegate to the state's hooks of the same name, at the appropriate time
		 *
		 * * Registers eager and lazy resolve hooks
		 */var TransitionManager=function(){function TransitionManager(transition,$transitions,$urlRouter,$view, // service
	$state,globals){this.transition=transition;this.$transitions=$transitions;this.$urlRouter=$urlRouter;this.$view=$view;this.$state=$state;this.globals=globals;this.$q=coreservices_1.services.$q;this.viewHooks=new viewHooks_1.ViewHooks(transition,$view);this.enterExitHooks=new enterExitHooks_1.EnterExitHooks(transition);this.resolveHooks=new resolveHooks_1.ResolveHooks(transition);this.treeChanges=transition.treeChanges();this.registerUpdateGlobalState();this.viewHooks.registerHooks();this.enterExitHooks.registerHooks();this.resolveHooks.registerHooks();}TransitionManager.prototype.runTransition=function(){var _this=this;this.globals.transitionHistory.enqueue(this.transition);return this.transition.run().then(function(trans){return trans.to();}) // resolve to the final state (TODO: good? bad?)
	.catch(function(error){return _this.transRejected(error);}); // if rejected, handle dynamic and redirect
	};TransitionManager.prototype.registerUpdateGlobalState=function(){ // After globals.current is updated at priority: 10000
	this.transition.onSuccess({},this.updateUrl.bind(this),{priority:9999});};TransitionManager.prototype.transRejected=function(error){var _a=this,transition=_a.transition,$state=_a.$state,$q=_a.$q; // Handle redirect and abort
	if(error instanceof rejectFactory_1.TransitionRejection){if(error.type===rejectFactory_1.RejectType.IGNORED){ // Update $stateParmas/$state.params/$location.url if transition ignored, but dynamic params have changed.
	var dynamic=$state.$current.parameters().filter(hof_1.prop('dynamic'));if(!param_1.Param.equals(dynamic,$state.params,transition.params())){this.updateUrl();}return $state.current;}if(error.type===rejectFactory_1.RejectType.SUPERSEDED&&error.redirected&&error.detail instanceof targetState_1.TargetState){return this._redirectMgr(transition.redirect(error.detail)).runTransition();}if(error.type===rejectFactory_1.RejectType.ABORTED){this.$urlRouter.update();}}this.$transitions.defaultErrorHandler()(error);return $q.reject(error);};TransitionManager.prototype.updateUrl=function(){var transition=this.transition;var _a=this,$urlRouter=_a.$urlRouter,$state=_a.$state;var options=transition.options();var toState=transition.$to();if(options.location&&$state.$current.navigable){$urlRouter.push($state.$current.navigable.url,$state.params,{replace:options.location==='replace'});}$urlRouter.update(true);};TransitionManager.prototype._redirectMgr=function(redirect){var _a=this,$transitions=_a.$transitions,$urlRouter=_a.$urlRouter,$view=_a.$view,$state=_a.$state,globals=_a.globals;return new TransitionManager(redirect,$transitions,$urlRouter,$view,$state,globals);};return TransitionManager;}();exports.TransitionManager=TransitionManager; /***/}, /* 27 */ /***/function(module,exports){ /** @module state */ /** for typedoc */"use strict"; /**
		 * @ngdoc object
		 * @name ui.router.state.type:TargetState
		 *
		 * @description
		 * Encapsulate the desired target of a transition.
		 * Wraps an identifier for a state, a set of parameters, and transition options with the definition of the state.
		 *
		 * @param {StateOrName} _identifier  An identifier for a state. Either a fully-qualified path, or the object
		 *            used to define the state.
		 * @param {IState} _definition The `State` object definition.
		 * @param {ParamsOrArray} _params Parameters for the target state
		 * @param {TransitionOptions} _options Transition options.
		 */var TargetState=function(){function TargetState(_identifier,_definition,_params,_options){if(_params===void 0){_params={};}if(_options===void 0){_options={};}this._identifier=_identifier;this._definition=_definition;this._options=_options;this._params=_params||{};}TargetState.prototype.name=function(){return this._definition&&this._definition.name||this._identifier;};TargetState.prototype.identifier=function(){return this._identifier;};TargetState.prototype.params=function(){return this._params;};TargetState.prototype.$state=function(){return this._definition;};TargetState.prototype.state=function(){return this._definition&&this._definition.self;};TargetState.prototype.options=function(){return this._options;};TargetState.prototype.exists=function(){return !!(this._definition&&this._definition.self);};TargetState.prototype.valid=function(){return !this.error();};TargetState.prototype.error=function(){var base=this.options().relative;if(!this._definition&&!!base){var stateName=base.name?base.name:base;return "Could not resolve '"+this.name()+"' from state '"+stateName+"'";}if(!this._definition)return "No such state '"+this.name()+"'";if(!this._definition.self)return "State '"+this.name()+"' has an invalid definition";};return TargetState;}();exports.TargetState=TargetState; /***/}, /* 28 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var common_1=__webpack_require__(3);var coreservices_1=__webpack_require__(6);var ViewHooks=function(){function ViewHooks(transition,$view){this.transition=transition;this.$view=$view;this.treeChanges=transition.treeChanges();this.enteringViews=transition.views("entering");this.exitingViews=transition.views("exiting");}ViewHooks.prototype.loadAllEnteringViews=function(){return coreservices_1.services.$q.all(this.enteringViews.map(function(view){return view.load();})).then(common_1.noop);};ViewHooks.prototype.updateViews=function(){var $view=this.$view;this.exitingViews.forEach(function(viewConfig){return $view.deactivateViewConfig(viewConfig);});this.enteringViews.forEach(function(viewConfig){return $view.activateViewConfig(viewConfig);});$view.sync();};ViewHooks.prototype.registerHooks=function(){if(this.enteringViews.length){this.transition.onStart({},this.loadAllEnteringViews.bind(this));}if(this.exitingViews.length||this.enteringViews.length)this.transition.onSuccess({},this.updateViews.bind(this));};return ViewHooks;}();exports.ViewHooks=ViewHooks; /***/}, /* 29 */ /***/function(module,exports){"use strict";var EnterExitHooks=function(){function EnterExitHooks(transition){this.transition=transition;}EnterExitHooks.prototype.registerHooks=function(){this.registerOnEnterHooks();this.registerOnRetainHooks();this.registerOnExitHooks();};EnterExitHooks.prototype.registerOnEnterHooks=function(){var _this=this;this.transition.entering().filter(function(state){return !!state.onEnter;}).forEach(function(state){return _this.transition.onEnter({entering:state.name},state.onEnter);});};EnterExitHooks.prototype.registerOnRetainHooks=function(){var _this=this;this.transition.retained().filter(function(state){return !!state.onRetain;}).forEach(function(state){return _this.transition.onRetain({retained:state.name},state.onRetain);});};EnterExitHooks.prototype.registerOnExitHooks=function(){var _this=this;this.transition.exiting().filter(function(state){return !!state.onExit;}).forEach(function(state){return _this.transition.onExit({exiting:state.name},state.onExit);});};return EnterExitHooks;}();exports.EnterExitHooks=EnterExitHooks; /***/}, /* 30 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var interface_1=__webpack_require__(31);var hof_2=__webpack_require__(5);var resolvable_1=__webpack_require__(32);var LAZY=interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];var EAGER=interface_1.ResolvePolicy[interface_1.ResolvePolicy.EAGER]; /**
		 * Registers Eager and Lazy (for entering states) resolve hooks
		 *
		 * * registers a hook that resolves EAGER resolves, for the To Path, onStart of the transition
		 * * registers a hook that resolves LAZY resolves, for each state, before it is entered
		 */var ResolveHooks=function(){function ResolveHooks(transition){this.transition=transition;}ResolveHooks.prototype.registerHooks=function(){var treeChanges=this.transition.treeChanges(); /** a function which resolves any EAGER Resolvables for a Path */$eagerResolvePath.$inject=['$transition$'];function $eagerResolvePath($transition$){return common_1.tail(treeChanges.to).resolveContext.resolvePath(common_1.extend({transition:$transition$},{resolvePolicy:EAGER}));} /** Returns a function which pre-resolves any LAZY Resolvables for a Node in a Path */$lazyResolveEnteringState.$inject=['$state$','$transition$'];function $lazyResolveEnteringState($state$,$transition$){var node=common_1.find(treeChanges.entering,hof_1.propEq('state',$state$)); // A new Resolvable contains all the resolved data in this context as a single object, for injection as `$resolve$`
	var context=node.resolveContext;var $resolve$=new resolvable_1.Resolvable("$resolve$",function(){return common_1.map(context.getResolvables(),function(r){return r.data;});});var options=common_1.extend({transition:$transition$},{resolvePolicy:LAZY}); // Resolve all the LAZY resolves, then resolve the `$resolve$` object, then add `$resolve$` to the context
	return context.resolvePathElement(node.state,options).then(function(){return $resolve$.resolveResolvable(context);}).then(function(){return context.addResolvables({$resolve$:$resolve$},node.state);});} // Resolve eager resolvables before when the transition starts
	this.transition.onStart({},$eagerResolvePath,{priority:1000}); // Resolve lazy resolvables before each state is entered
	this.transition.onEnter({entering:hof_2.val(true)},$lazyResolveEnteringState,{priority:1000});};return ResolveHooks;}();exports.ResolveHooks=ResolveHooks; /***/}, /* 31 */ /***/function(module,exports){"use strict"; // Defines the available policies and their ordinals.
	(function(ResolvePolicy){ResolvePolicy[ResolvePolicy["JIT"]=0]="JIT";ResolvePolicy[ResolvePolicy["LAZY"]=1]="LAZY";ResolvePolicy[ResolvePolicy["EAGER"]=2]="EAGER"; // Eager resolves are resolved before the transition starts.
	})(exports.ResolvePolicy||(exports.ResolvePolicy={}));var ResolvePolicy=exports.ResolvePolicy; /***/}, /* 32 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module resolve */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var coreservices_1=__webpack_require__(6);var trace_1=__webpack_require__(12); /**
		 * The basic building block for the resolve system.
		 *
		 * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
		 * and the unwrapped-when-complete (.data) result of the resolveFn.
		 *
		 * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
		 * resolveFn) and returns the resulting promise.
		 *
		 * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
		 * parameter to those fns.
		 */var Resolvable=function(){function Resolvable(name,resolveFn,preResolvedData){this.promise=undefined;common_1.extend(this,{name:name,resolveFn:resolveFn,deps:coreservices_1.services.$injector.annotate(resolveFn,coreservices_1.services.$injector.strictDi),data:preResolvedData});} // synchronous part:
	// - sets up the Resolvable's promise
	// - retrieves dependencies' promises
	// - returns promise for async part
	// asynchronous part:
	// - wait for dependencies promises to resolve
	// - invoke the resolveFn
	// - wait for resolveFn promise to resolve
	// - store unwrapped data
	// - resolve the Resolvable's promise
	Resolvable.prototype.resolveResolvable=function(resolveContext,options){var _this=this;if(options===void 0){options={};}var _a=this,name=_a.name,deps=_a.deps,resolveFn=_a.resolveFn;trace_1.trace.traceResolveResolvable(this,options); // First, set up an overall deferred/promise for this Resolvable
	var deferred=coreservices_1.services.$q.defer();this.promise=deferred.promise; // Load a map of all resolvables for this state from the context path
	// Omit the current Resolvable from the result, so we don't try to inject this into this
	var ancestorsByName=resolveContext.getResolvables(null,{omitOwnLocals:[name]}); // Limit the ancestors Resolvables map to only those that the current Resolvable fn's annotations depends on
	var depResolvables=common_1.pick(ancestorsByName,deps); // Get promises (or synchronously invoke resolveFn) for deps
	var depPromises=common_1.map(depResolvables,function(resolvable){return resolvable.get(resolveContext,options);}); // Return a promise chain that waits for all the deps to resolve, then invokes the resolveFn passing in the
	// dependencies as locals, then unwraps the resulting promise's data.
	return coreservices_1.services.$q.all(depPromises).then(function(locals){try{var result=coreservices_1.services.$injector.invoke(resolveFn,null,locals);deferred.resolve(result);}catch(error){deferred.reject(error);}return _this.promise;}).then(function(data){_this.data=data;trace_1.trace.traceResolvableResolved(_this,options);return _this.promise;});};Resolvable.prototype.get=function(resolveContext,options){return this.promise||this.resolveResolvable(resolveContext,options);};Resolvable.prototype.toString=function(){return "Resolvable(name: "+this.name+", requires: ["+this.deps+"])";}; /**
		     * Validates the result map as a "resolve:" style object, then transforms the resolves into Resolvables
		     */Resolvable.makeResolvables=function(resolves){ // If a hook result is an object, it should be a map of strings to functions.
	var invalid=common_1.filter(resolves,hof_1.not(predicates_1.isInjectable)),keys=Object.keys(invalid);if(keys.length)throw new Error("Invalid resolve key/value: "+keys[0]+"/"+invalid[keys[0]]);return common_1.map(resolves,function(fn,name){return new Resolvable(name,fn);});};return Resolvable;}();exports.Resolvable=Resolvable; /***/}, /* 33 */ /***/function(module,exports,__webpack_require__){ /** @module state */ /** for typedoc */"use strict";var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5); /**
		 * @ngdoc object
		 * @name ui.router.state.type:State
		 *
		 * @description
		 * Definition object for states. Includes methods for manipulating the state heirarchy.
		 *
		 * @param {Object} config  A configuration object hash that includes the results of user-supplied
		 *        values, as well as values from `StateBuilder`.
		 *
		 * @returns {Object}  Returns a new `State` object.
		 */var State=function(){function State(config){common_1.extend(this,config); // Object.freeze(this);
	} /**
		     * @ngdoc function
		     * @name ui.router.state.type:State#is
		     * @methodOf ui.router.state.type:State
		     *
		     * @description
		     * Compares the identity of the state against the passed value, which is either an object
		     * reference to the actual `State` instance, the original definition object passed to
		     * `$stateProvider.state()`, or the fully-qualified name.
		     *
		     * @param {Object} ref Can be one of (a) a `State` instance, (b) an object that was passed
		     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
		     * @returns {boolean} Returns `true` if `ref` matches the current `State` instance.
		     */State.prototype.is=function(ref){return this===ref||this.self===ref||this.fqn()===ref;}; /**
		     * @ngdoc function
		     * @name ui.router.state.type:State#fqn
		     * @methodOf ui.router.state.type:State
		     *
		     * @description
		     * Returns the fully-qualified name of the state, based on its current position in the tree.
		     *
		     * @returns {string} Returns a dot-separated name of the state.
		     */State.prototype.fqn=function(){if(!this.parent||!(this.parent instanceof this.constructor))return this.name;var name=this.parent.fqn();return name?name+"."+this.name:this.name;}; /**
		     * @ngdoc function
		     * @name ui.router.state.type:State#root
		     * @methodOf ui.router.state.type:State
		     *
		     * @description
		     * Returns the root node of this state's tree.
		     *
		     * @returns {State} The root of this state's tree.
		     */State.prototype.root=function(){return this.parent&&this.parent.root()||this;};State.prototype.parameters=function(opts){opts=common_1.defaults(opts,{inherit:true});var inherited=opts.inherit&&this.parent&&this.parent.parameters()||[];return inherited.concat(common_1.values(this.params));};State.prototype.parameter=function(id,opts){if(opts===void 0){opts={};}return this.url&&this.url.parameter(id,opts)||common_1.find(common_1.values(this.params),hof_1.propEq('id',id))||opts.inherit&&this.parent&&this.parent.parameter(id);};State.prototype.toString=function(){return this.fqn();};return State;}();exports.State=State; /***/}, /* 34 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var predicates_1=__webpack_require__(4);var StateMatcher=function(){function StateMatcher(_states){this._states=_states;}StateMatcher.prototype.isRelative=function(stateName){stateName=stateName||"";return stateName.indexOf(".")===0||stateName.indexOf("^")===0;};StateMatcher.prototype.find=function(stateOrName,base){if(!stateOrName&&stateOrName!=="")return undefined;var isStr=predicates_1.isString(stateOrName);var name=isStr?stateOrName:stateOrName.name;if(this.isRelative(name))name=this.resolvePath(name,base);var state=this._states[name];if(state&&(isStr||!isStr&&(state===stateOrName||state.self===stateOrName))){return state;}return undefined;};StateMatcher.prototype.resolvePath=function(name,base){if(!base)throw new Error("No reference point given for path '"+name+"'");var baseState=this.find(base);var splitName=name.split("."),i=0,pathLength=splitName.length,current=baseState;for(;i<pathLength;i++){if(splitName[i]===""&&i===0){current=baseState;continue;}if(splitName[i]==="^"){if(!current.parent)throw new Error("Path '"+name+"' not valid for state '"+baseState.name+"'");current=current.parent;continue;}break;}var relName=splitName.slice(i).join(".");return current.name+(current.name&&relName?".":"")+relName;};return StateMatcher;}();exports.StateMatcher=StateMatcher; /***/}, /* 35 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(17);var StateQueueManager=function(){function StateQueueManager(states,builder,$urlRouterProvider){this.states=states;this.builder=builder;this.$urlRouterProvider=$urlRouterProvider;this.queue=[];}StateQueueManager.prototype.register=function(config){var _a=this,states=_a.states,queue=_a.queue,$state=_a.$state; // Wrap a new object around the state so we can store our private details easily.
	// @TODO: state = new State(extend({}, config, { ... }))
	var state=common_1.inherit(new module_1.State(),common_1.extend({},config,{self:config,resolve:config.resolve||{},toString:function toString(){return config.name;}}));if(!predicates_1.isString(state.name))throw new Error("State must have a valid name");if(states.hasOwnProperty(state.name)||common_1.pluck(queue,'name').indexOf(state.name)!==-1)throw new Error("State '"+state.name+"' is already defined");queue.push(state);if(this.$state){this.flush($state);}return state;};StateQueueManager.prototype.flush=function($state){var _a=this,queue=_a.queue,states=_a.states,builder=_a.builder;var result,state,orphans=[],orphanIdx,previousQueueLength={};while(queue.length>0){state=queue.shift();result=builder.build(state);orphanIdx=orphans.indexOf(state);if(result){if(states.hasOwnProperty(state.name))throw new Error("State '"+name+"' is already defined");states[state.name]=state;this.attachRoute($state,state);if(orphanIdx>=0)orphans.splice(orphanIdx,1);continue;}var prev=previousQueueLength[state.name];previousQueueLength[state.name]=queue.length;if(orphanIdx>=0&&prev===queue.length){ // Wait until two consecutive iterations where no additional states were dequeued successfully.
	throw new Error("Cannot register orphaned state '"+state.name+"'");}else if(orphanIdx<0){orphans.push(state);}queue.push(state);}return states;};StateQueueManager.prototype.autoFlush=function($state){this.$state=$state;this.flush($state);};StateQueueManager.prototype.attachRoute=function($state,state){var $urlRouterProvider=this.$urlRouterProvider;if(state[common_1.abstractKey]||!state.url)return;$urlRouterProvider.when(state.url,['$match','$stateParams',function($match,$stateParams){if($state.$current.navigable!==state||!common_1.equalForKeys($match,$stateParams)){$state.transitionTo(state,$match,{inherit:true});}}]);};return StateQueueManager;}();exports.StateQueueManager=StateQueueManager; /***/}, /* 36 */ /***/function(module,exports,__webpack_require__){ /** @module state */ /** for typedoc */"use strict";var stateMatcher_1=__webpack_require__(34);var stateBuilder_1=__webpack_require__(19);var stateQueueManager_1=__webpack_require__(35);var StateRegistry=function(){function StateRegistry(urlMatcherFactory,urlRouterProvider){this.states={};this.matcher=new stateMatcher_1.StateMatcher(this.states);this.builder=new stateBuilder_1.StateBuilder(this.matcher,urlMatcherFactory);this.stateQueue=new stateQueueManager_1.StateQueueManager(this.states,this.builder,urlRouterProvider);var rootStateDef={name:'',url:'^',views:null,params:{'#':{value:null,type:'hash'}},abstract:true};var _root=this._root=this.stateQueue.register(rootStateDef);_root.navigable=null;}StateRegistry.prototype.root=function(){return this._root;};StateRegistry.prototype.register=function(stateDefinition){return this.stateQueue.register(stateDefinition);};StateRegistry.prototype.get=function(stateOrName,base){var _this=this;if(arguments.length===0)return Object.keys(this.states).map(function(name){return _this.states[name].self;});var found=this.matcher.find(stateOrName,base);return found&&found.self||null;};StateRegistry.prototype.decorator=function(name,func){return this.builder.builder(name,func);};return StateRegistry;}();exports.StateRegistry=StateRegistry; /***/}, /* 37 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module state */ /** */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var queue_1=__webpack_require__(8);var coreservices_1=__webpack_require__(6);var pathFactory_1=__webpack_require__(38);var node_1=__webpack_require__(39);var transitionService_1=__webpack_require__(43);var rejectFactory_1=__webpack_require__(10);var targetState_1=__webpack_require__(27);var transitionManager_1=__webpack_require__(26);var param_1=__webpack_require__(21);var glob_1=__webpack_require__(7);var common_2=__webpack_require__(3);var common_3=__webpack_require__(3);var StateService=function(){function StateService($view,$urlRouter,$transitions,stateRegistry,stateProvider,globals){this.$view=$view;this.$urlRouter=$urlRouter;this.$transitions=$transitions;this.stateRegistry=stateRegistry;this.stateProvider=stateProvider;this.globals=globals;this.rejectFactory=new rejectFactory_1.RejectFactory();var getters=['current','$current','params','transition'];var boundFns=Object.keys(StateService.prototype).filter(function(key){return getters.indexOf(key)===-1;});common_3.bindFunctions(StateService.prototype,this,this,boundFns);}Object.defineProperty(StateService.prototype,"transition",{get:function get(){return this.globals.transition;},enumerable:true,configurable:true});Object.defineProperty(StateService.prototype,"params",{get:function get(){return this.globals.params;},enumerable:true,configurable:true});Object.defineProperty(StateService.prototype,"current",{get:function get(){return this.globals.current;},enumerable:true,configurable:true});Object.defineProperty(StateService.prototype,"$current",{get:function get(){return this.globals.$current;},enumerable:true,configurable:true}); /**
		     * Invokes the onInvalid callbacks, in natural order.  Each callback's return value is checked in sequence
		     * until one of them returns an instance of TargetState.   The results of the callbacks are wrapped
		     * in $q.when(), so the callbacks may return promises.
		     *
		     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and
		     * the result returned.
		     */StateService.prototype._handleInvalidTargetState=function(fromPath,$to$){var _this=this;var latestThing=function latestThing(){return _this.globals.transitionHistory.peekTail();};var latest=latestThing();var $from$=pathFactory_1.PathFactory.makeTargetState(fromPath);var callbackQueue=new queue_1.Queue([].concat(this.stateProvider.invalidCallbacks));var rejectFactory=this.rejectFactory;var $q=coreservices_1.services.$q,$injector=coreservices_1.services.$injector;var invokeCallback=function invokeCallback(callback){return $q.when($injector.invoke(callback,null,{$to$:$to$,$from$:$from$}));};var checkForRedirect=function checkForRedirect(result){if(!(result instanceof targetState_1.TargetState)){return;}var target=result; // Recreate the TargetState, in case the state is now defined.
	target=_this.target(target.identifier(),target.params(),target.options());if(!target.valid())return rejectFactory.invalid(target.error());if(latestThing()!==latest)return rejectFactory.superseded();return _this.transitionTo(target.identifier(),target.params(),target.options());};function invokeNextCallback(){var nextCallback=callbackQueue.dequeue();if(nextCallback===undefined)return rejectFactory.invalid($to$.error());return invokeCallback(nextCallback).then(checkForRedirect).then(function(result){return result||invokeNextCallback();});}return invokeNextCallback();}; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#reload
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * A method that force reloads the current state, or a partial state hierarchy. All resolves are re-resolved,
		     * controllers reinstantiated, and events re-fired.
		     *
		     * @example
		     * <pre>
		     * let app angular.module('app', ['ui.router']);
		     *
		     * app.controller('ctrl', function ($scope, $state) {
		     *   $scope.reload = function(){
		     *     $state.reload();
		     *   }
		     * });
		     * </pre>
		     *
		     * `reload()` is just an alias for:
		     * <pre>
		     * $state.transitionTo($state.current, $stateParams, {
		     *   reload: true, inherit: false, notify: true
		     * });
		     * </pre>
		     *
		     * @param {string=|object=} reloadState - A state name or a state object, which is the root of the resolves to be re-resolved.
		     * @example
		     * <pre>
		     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
		     * //and current state is 'contacts.detail.item'
		     * let app angular.module('app', ['ui.router']);
		     *
		     * app.controller('ctrl', function ($scope, $state) {
		     *   $scope.reload = function(){
		     *     //will reload 'contact.detail' and nested 'contact.detail.item' states
		     *     $state.reload('contact.detail');
		     *   }
		     * });
		     * </pre>
		     *
		     * @returns {promise} A promise representing the state of the new transition. See
		     * {@link ui.router.state.$state#methods_go $state.go}.
		     */StateService.prototype.reload=function(reloadState){return this.transitionTo(this.current,this.params,{reload:predicates_1.isDefined(reloadState)?reloadState:true,inherit:false,notify:false});};; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#go
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * Convenience method for transitioning to a new state. `$state.go` calls
		     * `$state.transitionTo` internally but automatically sets options to
		     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`.
		     * This allows you to easily use an absolute or relative to path and specify
		     * only the parameters you'd like to update (while letting unspecified parameters
		     * inherit from the currently active ancestor states).
		     *
		     * @example
		     * <pre>
		     * let app = angular.module('app', ['ui.router']);
		     *
		     * app.controller('ctrl', function ($scope, $state) {
		     *   $scope.changeState = function () {
		     *     $state.go('contact.detail');
		     *   };
		     * });
		     * </pre>
		     * <img src='../ngdoc_assets/StateGoExamples.png'/>
		     *
		     * @param {string} to Absolute state name or relative state path. Some examples:
		     *
		     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
		     * - `$state.go('^')` - will go to a parent state
		     * - `$state.go('^.sibling')` - will go to a sibling state
		     * - `$state.go('.child.grandchild')` - will go to grandchild state
		     *
		     * @param {object=} params A map of the parameters that will be sent to the state,
		     * will populate $stateParams. Any parameters that are not specified will be inherited from currently
		     * defined parameters. This allows, for example, going to a sibling state that shares parameters
		     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
		     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
		     * will get you all current parameters, etc.
		     * @param {object=} options Options object. The options are:
		     *
		     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
		     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
		     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
		     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
		     *    defines which state to be relative from.
		     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
		     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params
		     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
		     *    use this when you want to force a reload when *everything* is the same, including search params.
		     *
		     * @returns {promise} A promise representing the state of the new transition.
		     *
		     * Possible success values:
		     *
		     * - $state.current
		     *
		     * <br/>Possible rejection values:
		     *
		     * - 'transition superseded' - when a newer transition has been started after this one
		     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
		     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
		     *   when a `$stateNotFound` `event.retry` promise errors.
		     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
		     * - *resolve error* - when an error has occurred with a `resolve`
		     *
		     */StateService.prototype.go=function(to,params,options){var defautGoOpts={relative:this.$current,inherit:true};var transOpts=common_1.defaults(options,defautGoOpts,transitionService_1.defaultTransOpts);return this.transitionTo(to,params,transOpts);};; /** Factory method for creating a TargetState */StateService.prototype.target=function(identifier,params,options){if(options===void 0){options={};} // If we're reloading, find the state object to reload from
	if(predicates_1.isObject(options.reload)&&!options.reload.name)throw new Error('Invalid reload state object');options.reloadState=options.reload===true?this.stateRegistry.root():this.stateRegistry.matcher.find(options.reload,options.relative);if(options.reload&&!options.reloadState)throw new Error("No such reload state '"+(predicates_1.isString(options.reload)?options.reload:options.reload.name)+"'");var stateDefinition=this.stateRegistry.matcher.find(identifier,options.relative);return new targetState_1.TargetState(identifier,stateDefinition,params,options);};; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#transitionTo
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
		     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
		     *
		     * @example
		     * <pre>
		     * let app = angular.module('app', ['ui.router']);
		     *
		     * app.controller('ctrl', function ($scope, $state) {
		     *   $scope.changeState = function () {
		     *     $state.transitionTo('contact.detail');
		     *   };
		     * });
		     * </pre>
		     *
		     * @param {string} to State name.
		     * @param {object=} toParams A map of the parameters that will be sent to the state,
		     * will populate $stateParams.
		     * @param {object=} options Options object. The options are:
		     *
		     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
		     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
		     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
		     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'),
		     *    defines which state to be relative from.
		     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
		     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params
		     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
		     *    use this when you want to force a reload when *everything* is the same, including search params.
		     *
		     * @returns {promise} A promise representing the state of the new transition. See
		     * {@link ui.router.state.$state#methods_go $state.go}.
		     */StateService.prototype.transitionTo=function(to,toParams,options){var _this=this;if(toParams===void 0){toParams={};}if(options===void 0){options={};}var transHistory=this.globals.transitionHistory;options=common_1.defaults(options,transitionService_1.defaultTransOpts);options=common_1.extend(options,{current:transHistory.peekTail.bind(transHistory)});var ref=this.target(to,toParams,options);var latestSuccess=this.globals.successfulTransitions.peekTail();var rootPath=function rootPath(){return pathFactory_1.PathFactory.bindTransNodesToPath([new node_1.Node(_this.stateRegistry.root())]);};var currentPath=latestSuccess?latestSuccess.treeChanges().to:rootPath();if(!ref.exists())return this._handleInvalidTargetState(currentPath,ref);if(!ref.valid())return coreservices_1.services.$q.reject(ref.error());var transition=this.$transitions.create(currentPath,ref);var tMgr=new transitionManager_1.TransitionManager(transition,this.$transitions,this.$urlRouter,this.$view,this,this.globals);var transitionPromise=tMgr.runTransition(); // Return a promise for the transition, which also has the transition object on it.
	return common_1.extend(transitionPromise,{transition:transition});};; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#is
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
		     * but only checks for the full state name. If params is supplied then it will be
		     * tested for strict equality against the current active params object, so all params
		     * must match with none missing and no extras.
		     *
		     * @example
		     * <pre>
		     * $state.$current.name = 'contacts.details.item';
		     *
		     * // absolute name
		     * $state.is('contact.details.item'); // returns true
		     * $state.is(contactDetailItemStateObject); // returns true
		     *
		     * // relative name (. and ^), typically from a template
		     * // E.g. from the 'contacts.details' template
		     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
		     * </pre>
		     *
		     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
		     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
		     * to test against the current active state.
		     * @param {object=} options An options object.  The options are:
		     *
		     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
		     * test relative to `options.relative` state (or name).
		     *
		     * @returns {boolean} Returns true if it is the state.
		     */StateService.prototype.is=function(stateOrName,params,options){options=common_1.defaults(options,{relative:this.$current});var state=this.stateRegistry.matcher.find(stateOrName,options.relative);if(!predicates_1.isDefined(state))return undefined;if(this.$current!==state)return false;return predicates_1.isDefined(params)&&params!==null?param_1.Param.equals(state.parameters(),this.params,params):true;};; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#includes
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * A method to determine if the current active state is equal to or is the child of the
		     * state stateName. If any params are passed then they will be tested for a match as well.
		     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
		     *
		     * @example
		     * Partial and relative names
		     * <pre>
		     * $state.$current.name = 'contacts.details.item';
		     *
		     * // Using partial names
		     * $state.includes("contacts"); // returns true
		     * $state.includes("contacts.details"); // returns true
		     * $state.includes("contacts.details.item"); // returns true
		     * $state.includes("contacts.list"); // returns false
		     * $state.includes("about"); // returns false
		     *
		     * // Using relative names (. and ^), typically from a template
		     * // E.g. from the 'contacts.details' template
		     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
		     * </pre>
		     *
		     * Basic globbing patterns
		     * <pre>
		     * $state.$current.name = 'contacts.details.item.url';
		     *
		     * $state.includes("*.details.*.*"); // returns true
		     * $state.includes("*.details.**"); // returns true
		     * $state.includes("**.item.**"); // returns true
		     * $state.includes("*.details.item.url"); // returns true
		     * $state.includes("*.details.*.url"); // returns true
		     * $state.includes("*.details.*"); // returns false
		     * $state.includes("item.**"); // returns false
		     * </pre>
		     *
		     * @param {string} stateOrName A partial name, relative name, or glob pattern
		     * to be searched for within the current state name.
		     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
		     * that you'd like to test against the current active state.
		     * @param {object=} options An options object.  The options are:
		     *
		     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
		     * .includes will test relative to `options.relative` state (or name).
		     *
		     * @returns {boolean} Returns true if it does include the state
		     */StateService.prototype.includes=function(stateOrName,params,options){options=common_1.defaults(options,{relative:this.$current});var glob=predicates_1.isString(stateOrName)&&glob_1.Glob.fromString(stateOrName);if(glob){if(!glob.matches(this.$current.name))return false;stateOrName=this.$current.name;}var state=this.stateRegistry.matcher.find(stateOrName,options.relative),include=this.$current.includes;if(!predicates_1.isDefined(state))return undefined;if(!predicates_1.isDefined(include[state.name]))return false; // @TODO Replace with Param.equals() ?
	return params?common_2.equalForKeys(param_1.Param.values(state.parameters(),params),this.params,Object.keys(params)):true;};; /**
		     * @ngdoc function
		     * @name ui.router.state.$state#href
		     * @methodOf ui.router.state.$state
		     *
		     * @description
		     * A url generation method that returns the compiled url for the given state populated with the given params.
		     *
		     * @example
		     * <pre>
		     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
		     * </pre>
		     *
		     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
		     * @param {object=} params An object of parameter values to fill the state's required parameters.
		     * @param {object=} options Options object. The options are:
		     *
		     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
		     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
		     *    ancestor with a valid url).
		     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
		     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'),
		     *    defines which state to be relative from.
		     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
		     *
		     * @returns {string} compiled state url
		     */StateService.prototype.href=function(stateOrName,params,options){var defaultHrefOpts={lossy:true,inherit:true,absolute:false,relative:this.$current};options=common_1.defaults(options,defaultHrefOpts);var state=this.stateRegistry.matcher.find(stateOrName,options.relative);if(!predicates_1.isDefined(state))return null;if(options.inherit)params=this.params.$inherit(params||{},this.$current,state);var nav=state&&options.lossy?state.navigable:state;if(!nav||nav.url===undefined||nav.url===null){return null;}return this.$urlRouter.href(nav.url,param_1.Param.values(state.parameters(),params),{absolute:options.absolute});};;StateService.prototype.get=function(stateOrName,base){if(arguments.length===0)return this.stateRegistry.get();return this.stateRegistry.get(stateOrName,base||this.$current);};return StateService;}();exports.StateService=StateService; /***/}, /* 38 */ /***/function(module,exports,__webpack_require__){ /** @module path */ /** for typedoc */"use strict";var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var module_1=__webpack_require__(17);var node_1=__webpack_require__(39);var module_2=__webpack_require__(40); /**
		 * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
		 */var PathFactory=function(){function PathFactory(){} /** Given a Node[], create an TargetState */PathFactory.makeTargetState=function(path){var state=common_1.tail(path).state;return new module_1.TargetState(state,state,path.map(hof_1.prop("paramValues")).reduce(common_1.mergeR,{}));};PathFactory.buildPath=function(targetState){var toParams=targetState.params();return targetState.$state().path.map(function(state){return new node_1.Node(state).applyRawParams(toParams);});}; /** Given a fromPath: Node[] and a TargetState, builds a toPath: Node[] */PathFactory.buildToPath=function(fromPath,targetState){var toPath=PathFactory.buildPath(targetState);if(targetState.options().inherit){return PathFactory.inheritParams(fromPath,toPath,Object.keys(targetState.params()));}return toPath;};PathFactory.applyViewConfigs=function($view,path){return path.map(function(node){return common_1.extend(node,{views:common_1.values(node.state.views||{}).map(function(view){return $view.createViewConfig(node,view);})});});}; /**
		     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
		     *
		     * For a parameter in a node to be inherited from the from path:
		     * - The toPath's node must have a matching node in the fromPath (by state).
		     * - The parameter name must not be found in the toKeys parameter array.
		     *
		     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
		     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
		     * it is not inherited from the fromPath.
		     */PathFactory.inheritParams=function(fromPath,toPath,toKeys){if(toKeys===void 0){toKeys=[];}function nodeParamVals(path,state){var node=common_1.find(path,hof_1.propEq('state',state));return common_1.extend({},node&&node.paramValues);} /**
		         * Given an Node "toNode", return a new Node with param values inherited from the
		         * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
		         */var makeInheritedParamsNode=hof_1.curry(function(_fromPath,_toKeys,toNode){ // All param values for the node (may include default key/vals, when key was not found in toParams)
	var toParamVals=common_1.extend({},toNode&&toNode.paramValues); // limited to only those keys found in toParams
	var incomingParamVals=common_1.pick(toParamVals,_toKeys);toParamVals=common_1.omit(toParamVals,_toKeys);var fromParamVals=nodeParamVals(_fromPath,toNode.state)||{}; // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
	var ownParamVals=common_1.extend(toParamVals,fromParamVals,incomingParamVals);return new node_1.Node(toNode.state).applyRawParams(ownParamVals);}); // The param keys specified by the incoming toParams
	return toPath.map(makeInheritedParamsNode(fromPath,toKeys));}; /**
		     * Given a path, upgrades the path to a Node[].  Each node is assigned a ResolveContext
		     * and ParamValues object which is bound to the whole path, but closes over the subpath from root to the node.
		     * The views are also added to the node.
		     */PathFactory.bindTransNodesToPath=function(resolvePath){var resolveContext=new module_2.ResolveContext(resolvePath); // let paramValues = new ParamValues(resolvePath);
	// Attach bound resolveContext and paramValues to each node
	// Attach views to each node
	resolvePath.forEach(function(node){node.resolveContext=resolveContext.isolateRootTo(node.state);node.resolveInjector=new module_2.ResolveInjector(node.resolveContext,node.state);node.resolves['$stateParams']=new module_2.Resolvable("$stateParams",function(){return node.paramValues;},node.paramValues);});return resolvePath;}; /**
		     * Computes the tree changes (entering, exiting) between a fromPath and toPath.
		     */PathFactory.treeChanges=function(fromPath,toPath,reloadState){var keep=0,max=Math.min(fromPath.length,toPath.length);var staticParams=function staticParams(state){return state.parameters({inherit:false}).filter(hof_1.not(hof_1.prop('dynamic'))).map(hof_1.prop('id'));};var nodesMatch=function nodesMatch(node1,node2){return node1.equals(node2,staticParams(node1.state));};while(keep<max&&fromPath[keep].state!==reloadState&&nodesMatch(fromPath[keep],toPath[keep])){keep++;} /** Given a retained node, return a new node which uses the to node's param values */function applyToParams(retainedNode,idx){var cloned=node_1.Node.clone(retainedNode);cloned.paramValues=toPath[idx].paramValues;return cloned;}var from,retained,exiting,entering,to; // intermediate vars
	var retainedWithToParams,enteringResolvePath,toResolvePath;from=fromPath;retained=from.slice(0,keep);exiting=from.slice(keep); // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
	retainedWithToParams=retained.map(applyToParams);enteringResolvePath=toPath.slice(keep); // "toResolvePath" is "retainedWithToParams" concat "enteringResolvePath".
	toResolvePath=retainedWithToParams.concat(enteringResolvePath); // "to: is "toResolvePath" with ParamValues/ResolveContext added to each node and bound to the path context
	to=PathFactory.bindTransNodesToPath(toResolvePath); // "entering" is the tail of "to"
	entering=to.slice(keep);return {from:from,to:to,retained:retained,exiting:exiting,entering:entering};};PathFactory.bindTransitionResolve=function(treeChanges,transition){var rootNode=treeChanges.to[0];rootNode.resolves['$transition$']=new module_2.Resolvable('$transition$',function(){return transition;},transition);}; /**
		     * Find a subpath of a path that stops at the node for a given state
		     *
		     * Given an array of nodes, returns a subset of the array starting from the first node, up to the
		     * node whose state matches `stateName`
		     *
		     * @param path a path of [[Node]]s
		     * @param state the [[State]] to stop at
		     */PathFactory.subPath=function(path,state){var node=common_1.find(path,function(_node){return _node.state===state;});var elementIdx=path.indexOf(node);if(elementIdx===-1)throw new Error("The path does not contain the state: "+state);return path.slice(0,elementIdx+1);}; /** Gets the raw parameter values from a path */PathFactory.paramValues=function(path){return path.reduce(function(acc,node){return common_1.extend(acc,node.paramValues);},{});};return PathFactory;}();exports.PathFactory=PathFactory; /***/}, /* 39 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module path */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var module_1=__webpack_require__(40);var Node=function(){function Node(state){if(state instanceof Node){var node=state;this.state=node.state;this.paramSchema=node.paramSchema.slice();this.paramValues=common_1.extend({},node.paramValues);this.resolves=common_1.extend({},node.resolves);this.views=node.views&&node.views.slice();this.resolveContext=node.resolveContext;this.resolveInjector=node.resolveInjector;}else {this.state=state;this.paramSchema=state.parameters({inherit:false});this.paramValues={};this.resolves=common_1.mapObj(state.resolve,function(fn,name){return new module_1.Resolvable(name,fn);});}}Node.prototype.applyRawParams=function(params){var getParamVal=function getParamVal(paramDef){return [paramDef.id,paramDef.value(params[paramDef.id])];};this.paramValues=this.paramSchema.reduce(function(memo,pDef){return common_1.applyPairs(memo,getParamVal(pDef));},{});return this;};Node.prototype.parameter=function(name){return common_1.find(this.paramSchema,hof_1.propEq("id",name));};Node.prototype.equals=function(node,keys){var _this=this;if(keys===void 0){keys=this.paramSchema.map(hof_1.prop('id'));}var paramValsEq=function paramValsEq(key){return _this.parameter(key).type.equals(_this.paramValues[key],node.paramValues[key]);};return this.state===node.state&&keys.map(paramValsEq).reduce(common_1.allTrueR,true);};Node.clone=function(node){return new Node(node);}; /**
		     * Returns a new path which is a subpath of the first path. The new path starts from root and contains any nodes
		     * that match the nodes in the second path. Nodes are compared using their state property.
		     * @param first {Node[]}
		     * @param second {Node[]}
		     * @returns {Node[]}
		     */Node.matching=function(first,second){var matchedCount=first.reduce(function(prev,node,i){return prev===i&&i<second.length&&node.state===second[i].state?i+1:prev;},0);return first.slice(0,matchedCount);};return Node;}();exports.Node=Node; /***/}, /* 40 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module resolve */ /** for typedoc */__export(__webpack_require__(31));__export(__webpack_require__(32));__export(__webpack_require__(41));__export(__webpack_require__(42)); /***/}, /* 41 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module resolve */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var trace_1=__webpack_require__(12);var coreservices_1=__webpack_require__(6);var interface_1=__webpack_require__(31);var common_2=__webpack_require__(3);var pathFactory_1=__webpack_require__(38); // TODO: make this configurable
	var defaultResolvePolicy=interface_1.ResolvePolicy[interface_1.ResolvePolicy.LAZY];var ResolveContext=function(){function ResolveContext(_path){this._path=_path;common_1.extend(this,{_nodeFor:function _nodeFor(state){return common_1.find(this._path,hof_1.propEq('state',state));},_pathTo:function _pathTo(state){return pathFactory_1.PathFactory.subPath(this._path,state);}});} /**
		     * Gets the available Resolvables for the last element of this path.
		     *
		     * @param state the State (within the ResolveContext's Path) for which to get resolvables
		     * @param options
		     *
		     * options.omitOwnLocals: array of property names
		     *   Omits those Resolvables which are found on the last element of the path.
		     *
		     *   This will hide a deepest-level resolvable (by name), potentially exposing a parent resolvable of
		     *   the same name further up the state tree.
		     *
		     *   This is used by Resolvable.resolve() in order to provide the Resolvable access to all the other
		     *   Resolvables at its own PathElement level, yet disallow that Resolvable access to its own injectable Resolvable.
		     *
		     *   This is also used to allow a state to override a parent state's resolve while also injecting
		     *   that parent state's resolve:
		     *
		     *   state({ name: 'G', resolve: { _G: function() { return "G"; } } });
		     *   state({ name: 'G.G2', resolve: { _G: function(_G) { return _G + "G2"; } } });
		     *   where injecting _G into a controller will yield "GG2"
		     */ResolveContext.prototype.getResolvables=function(state,options){options=common_1.defaults(options,{omitOwnLocals:[]});var path=state?this._pathTo(state):this._path;var last=common_1.tail(path);return path.reduce(function(memo,node){var omitProps=node===last?options.omitOwnLocals:[];var filteredResolvables=common_1.omit(node.resolves,omitProps);return common_1.extend(memo,filteredResolvables);},{});}; /** Inspects a function `fn` for its dependencies.  Returns an object containing any matching Resolvables */ResolveContext.prototype.getResolvablesForFn=function(fn){var deps=coreservices_1.services.$injector.annotate(fn,coreservices_1.services.$injector.strictDi);return common_1.pick(this.getResolvables(),deps);};ResolveContext.prototype.isolateRootTo=function(state){return new ResolveContext(this._pathTo(state));};ResolveContext.prototype.addResolvables=function(resolvables,state){common_1.extend(this._nodeFor(state).resolves,resolvables);}; /** Gets the resolvables declared on a particular state */ResolveContext.prototype.getOwnResolvables=function(state){return common_1.extend({},this._nodeFor(state).resolves);}; // Returns a promise for an array of resolved path Element promises
	ResolveContext.prototype.resolvePath=function(options){var _this=this;if(options===void 0){options={};}trace_1.trace.traceResolvePath(this._path,options);var promiseForNode=function promiseForNode(node){return _this.resolvePathElement(node.state,options);};return coreservices_1.services.$q.all(common_1.map(this._path,promiseForNode)).then(function(all){return all.reduce(common_2.mergeR,{});});}; // returns a promise for all the resolvables on this PathElement
	// options.resolvePolicy: only return promises for those Resolvables which are at 
	// the specified policy, or above.  i.e., options.resolvePolicy === 'lazy' will
	// resolve both 'lazy' and 'eager' resolves.
	ResolveContext.prototype.resolvePathElement=function(state,options){var _this=this;if(options===void 0){options={};} // The caller can request the path be resolved for a given policy and "below" 
	var policy=options&&options.resolvePolicy;var policyOrdinal=interface_1.ResolvePolicy[policy||defaultResolvePolicy]; // Get path Resolvables available to this element
	var resolvables=this.getOwnResolvables(state);var matchesRequestedPolicy=function matchesRequestedPolicy(resolvable){return getPolicy(state.resolvePolicy,resolvable)>=policyOrdinal;};var matchingResolves=common_1.filter(resolvables,matchesRequestedPolicy);var getResolvePromise=function getResolvePromise(resolvable){return resolvable.get(_this.isolateRootTo(state),options);};var resolvablePromises=common_1.map(matchingResolves,getResolvePromise);trace_1.trace.traceResolvePathElement(this,matchingResolves,options);return coreservices_1.services.$q.all(resolvablePromises);}; /**
		     * Injects a function given the Resolvables available in the path, from the first node
		     * up to the node for the given state.
		     *
		     * First it resolves all the resolvable depencies.  When they are done resolving, it invokes
		     * the function.
		     *
		     * @return a promise for the return value of the function.
		     *
		     * @param fn: the function to inject (i.e., onEnter, onExit, controller)
		     * @param locals: are the angular $injector-style locals to inject
		     * @param options: options (TODO: document)
		     */ResolveContext.prototype.invokeLater=function(fn,locals,options){var _this=this;if(locals===void 0){locals={};}if(options===void 0){options={};}var resolvables=this.getResolvablesForFn(fn);trace_1.trace.tracePathElementInvoke(common_1.tail(this._path),fn,Object.keys(resolvables),common_1.extend({when:"Later"},options));var getPromise=function getPromise(resolvable){return resolvable.get(_this,options);};var promises=common_1.map(resolvables,getPromise);return coreservices_1.services.$q.all(promises).then(function(){try{return _this.invokeNow(fn,locals,options);}catch(error){return coreservices_1.services.$q.reject(error);}});}; /**
		     * Immediately injects a function with the dependent Resolvables available in the path, from
		     * the first node up to the node for the given state.
		     *
		     * If a Resolvable is not yet resolved, then null is injected in place of the resolvable.
		     *
		     * @return the return value of the function.
		     *
		     * @param fn: the function to inject (i.e., onEnter, onExit, controller)
		     * @param locals: are the angular $injector-style locals to inject
		     * @param options: options (TODO: document)
		     */ // Injects a function at this PathElement level with available Resolvables
	// Does not wait until all Resolvables have been resolved; you must call PathElement.resolve() (or manually resolve each dep) first
	ResolveContext.prototype.invokeNow=function(fn,locals,options){if(options===void 0){options={};}var resolvables=this.getResolvablesForFn(fn);trace_1.trace.tracePathElementInvoke(common_1.tail(this._path),fn,Object.keys(resolvables),common_1.extend({when:"Now  "},options));var resolvedLocals=common_1.map(resolvables,hof_1.prop("data"));return coreservices_1.services.$injector.invoke(fn,options.bind||null,common_1.extend({},locals,resolvedLocals));};return ResolveContext;}();exports.ResolveContext=ResolveContext; /**
		 * Given a state's resolvePolicy attribute and a resolvable from that state, returns the policy ordinal for the Resolvable
		 * Use the policy declared for the Resolve. If undefined, use the policy declared for the State.  If
		 * undefined, use the system defaultResolvePolicy.
		 *
		 * @param stateResolvePolicyConf The raw resolvePolicy declaration on the state object; may be a String or Object
		 * @param resolvable The resolvable to compute the policy for
		 */function getPolicy(stateResolvePolicyConf,resolvable){ // Normalize the configuration on the state to either state-level (a string) or resolve-level (a Map of string:string)
	var stateLevelPolicy=predicates_1.isString(stateResolvePolicyConf)?stateResolvePolicyConf:null;var resolveLevelPolicies=predicates_1.isObject(stateResolvePolicyConf)?stateResolvePolicyConf:{};var policyName=resolveLevelPolicies[resolvable.name]||stateLevelPolicy||defaultResolvePolicy;return interface_1.ResolvePolicy[policyName];} /***/}, /* 42 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module resolve */ /** for typedoc */var common_1=__webpack_require__(3);var ResolveInjector=function(){function ResolveInjector(_resolveContext,_state){this._resolveContext=_resolveContext;this._state=_state;} /** Returns a promise to invoke an annotated function in the resolve context */ResolveInjector.prototype.invokeLater=function(injectedFn,locals){return this._resolveContext.invokeLater(injectedFn,locals);}; /** Invokes an annotated function in the resolve context */ResolveInjector.prototype.invokeNow=function(injectedFn,locals){return this._resolveContext.invokeNow(null,injectedFn,locals);}; /** Returns the a promise for locals (realized Resolvables) that a function wants */ResolveInjector.prototype.getLocals=function(injectedFn){var _this=this;var resolve=function resolve(r){return r.get(_this._resolveContext);};return common_1.map(this._resolveContext.getResolvablesForFn(injectedFn),resolve);};return ResolveInjector;}();exports.ResolveInjector=ResolveInjector; /***/}, /* 43 */ /***/function(module,exports,__webpack_require__){"use strict";var transition_1=__webpack_require__(11);var hookRegistry_1=__webpack_require__(15); /**
		 * The default transition options.
		 * Include this object when applying custom defaults:
		 * let reloadOpts = { reload: true, notify: true }
		 * let options = defaults(theirOpts, customDefaults, defaultOptions);
		 */exports.defaultTransOpts={location:true,relative:null,inherit:false,notify:true,reload:false,custom:{},current:function current(){return null;}}; /**
		 * This class provides services related to Transitions.
		 *
		 * Most importantly, it allows global Transition Hooks to be registered, and has a factory function
		 * for creating new Transitions.
		 */var TransitionService=function(){function TransitionService($view){this.$view=$view;this._defaultErrorHandler=function $defaultErrorHandler($error$){if($error$ instanceof Error){console.error($error$);}};hookRegistry_1.HookRegistry.mixin(new hookRegistry_1.HookRegistry(),this);}TransitionService.prototype.defaultErrorHandler=function(handler){return this._defaultErrorHandler=handler||this._defaultErrorHandler;}; /**
		     * Creates a new [[Transition]] object
		     *
		     * This is a factory function for creating new Transition objects.
		     *
		     * @param fromPath
		     * @param targetState
		     * @returns {Transition}
		     */TransitionService.prototype.create=function(fromPath,targetState){return new transition_1.Transition(fromPath,targetState,this);};return TransitionService;}();exports.TransitionService=TransitionService; /***/}, /* 44 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module path */ /** for typedoc */__export(__webpack_require__(39));__export(__webpack_require__(38)); /***/}, /* 45 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module url */ /** for typedoc */__export(__webpack_require__(46));__export(__webpack_require__(22));__export(__webpack_require__(47));__export(__webpack_require__(48)); /***/}, /* 46 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module url */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(20);var predicates_2=__webpack_require__(4);var param_1=__webpack_require__(21);var common_2=__webpack_require__(3);var common_3=__webpack_require__(3);function quoteRegExp(string,param){var surroundPattern=['',''],result=string.replace(/[\\\[\]\^$*+?.()|{}]/g,"\\$&");if(!param)return result;switch(param.squash){case false:surroundPattern=['(',')'+(param.isOptional?'?':'')];break;case true:result=result.replace(/\/$/,'');surroundPattern=['(?:\/(',')|\/)?'];break;default:surroundPattern=["("+param.squash+"|",')?'];break;}return result+surroundPattern[0]+param.type.pattern.source+surroundPattern[1];}var memoizeTo=function memoizeTo(obj,prop,fn){return obj[prop]=obj[prop]||fn();}; /**
		 * @ngdoc object
		 * @name ui.router.util.type:UrlMatcher
		 *
		 * @description
		 * Matches URLs against patterns and extracts named parameters from the path or the search
		 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
		 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
		 * do not influence whether or not a URL is matched, but their values are passed through into
		 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
		 *
		 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
		 * syntax, which optionally allows a regular expression for the parameter to be specified:
		 *
		 * * `':'` name - colon placeholder
		 * * `'*'` name - catch-all placeholder
		 * * `'{' name '}'` - curly placeholder
		 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
		 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
		 *
		 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
		 * must be unique within the pattern (across both path and search parameters). For colon
		 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
		 * number of characters other than '/'. For catch-all placeholders the path parameter matches
		 * any number of characters.
		 *
		 * Examples:
		 *
		 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
		 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
		 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
		 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
		 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
		 * * `'/user/{id:[^/]*}'` - Same as the previous example.
		 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
		 *   parameter consists of 1 to 8 hex digits.
		 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
		 *   path into the parameter 'path'.
		 * * `'/files/*path'` - ditto.
		 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
		 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
		 *
		 * @param {string} pattern  The pattern to compile into a matcher.
		 * @param {Object} config  A configuration object hash
		 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
		 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
		 *
		 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
		 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
		 *   non-null) will start with this prefix.
		 *
		 * @property {string} pattern  The pattern that was passed into the constructor
		 *
		 * @returns {Object}  New `UrlMatcher` object
		 */var UrlMatcher=function(){function UrlMatcher(pattern,config){var _this=this;this.pattern=pattern;this.config=config;this._cache={path:[],pattern:null};this._children=[];this._params=[];this._segments=[];this._compiled=[];this.config=common_1.defaults(this.config,{params:{},strict:true,caseInsensitive:false,paramMap:common_1.identity}); // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
	//   '*' name
	//   ':' name
	//   '{' name '}'
	//   '{' name ':' regexp '}'
	// The regular expression is somewhat complicated due to the need to allow curly braces
	// inside the regular expression. The placeholder regexp breaks down as follows:
	//    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
	//    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
	//    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
	//    [^{}\\]+                       - anything other than curly braces or backslash
	//    \\.                            - a backslash escape
	//    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
	var placeholder=/([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,searchPlaceholder=/([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,last=0,m,patterns=[];var checkParamErrors=function checkParamErrors(id){if(!UrlMatcher.nameValidator.test(id))throw new Error("Invalid parameter name '"+id+"' in pattern '"+pattern+"'");if(common_1.find(_this._params,hof_1.propEq('id',id)))throw new Error("Duplicate parameter name '"+id+"' in pattern '"+pattern+"'");}; // Split into static segments separated by path parameter placeholders.
	// The number of segments is always 1 more than the number of parameters.
	var matchDetails=function matchDetails(m,isSearch){ // IE[78] returns '' for unmatched groups instead of null
	var id=m[2]||m[3],regexp=isSearch?m[4]:m[4]||(m[1]==='*'?'.*':null);return {id:id,regexp:regexp,cfg:_this.config.params[id],segment:pattern.substring(last,m.index),type:!regexp?null:module_1.paramTypes.type(regexp||"string")||common_1.inherit(module_1.paramTypes.type("string"),{pattern:new RegExp(regexp,_this.config.caseInsensitive?'i':undefined)})};};var p,segment;while(m=placeholder.exec(pattern)){p=matchDetails(m,false);if(p.segment.indexOf('?')>=0)break; // we're into the search part
	checkParamErrors(p.id);this._params.push(module_1.Param.fromPath(p.id,p.type,this.config.paramMap(p.cfg,false)));this._segments.push(p.segment);patterns.push([p.segment,common_1.tail(this._params)]);last=placeholder.lastIndex;}segment=pattern.substring(last); // Find any search parameter names and remove them from the last segment
	var i=segment.indexOf('?');if(i>=0){var search=segment.substring(i);segment=segment.substring(0,i);if(search.length>0){last=0;while(m=searchPlaceholder.exec(search)){p=matchDetails(m,true);checkParamErrors(p.id);this._params.push(module_1.Param.fromSearch(p.id,p.type,this.config.paramMap(p.cfg,true)));last=placeholder.lastIndex;}}}this._segments.push(segment);common_1.extend(this,{_compiled:patterns.map(function(pattern){return quoteRegExp.apply(null,pattern);}).concat(quoteRegExp(segment)),prefix:this._segments[0]});Object.freeze(this);} /**
		     * @ngdoc function
		     * @name ui.router.util.type:UrlMatcher#append
		     * @methodOf ui.router.util.type:UrlMatcher
		     *
		     * @description
		     * @TODO
		     *
		     * @example
		     * @TODO
		     *
		     * @param {UrlMatcher} url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
		     */UrlMatcher.prototype.append=function(url){this._children.push(url);common_1.forEach(url._cache,function(val,key){return url._cache[key]=predicates_1.isArray(val)?[]:null;});url._cache.path=this._cache.path.concat(this);return url;};UrlMatcher.prototype.isRoot=function(){return this._cache.path.length===0;};UrlMatcher.prototype.toString=function(){return this.pattern;}; /**
		     * @ngdoc function
		     * @name ui.router.util.type:UrlMatcher#exec
		     * @methodOf ui.router.util.type:UrlMatcher
		     *
		     * @description
		     * Tests the specified path against this matcher, and returns an object containing the captured
		     * parameter values, or null if the path does not match. The returned object contains the values
		     * of any search parameters that are mentioned in the pattern, but their value may be null if
		     * they are not present in `search`. This means that search parameters are always treated
		     * as optional.
		     *
		     * @example
		     * <pre>
		     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
		     *   x: '1', q: 'hello'
		     * });
		     * // returns { id: 'bob', q: 'hello', r: null }
		     * </pre>
		     *
		     * @param {string} path  The URL path to match, e.g. `$location.path()`.
		     * @param {Object} search  URL search parameters, e.g. `$location.search()`.
		     * @param {string} hash  URL hash e.g. `$location.hash()`.
		     * @param {Object} options
		     * @returns {Object}  The captured parameter values.
		     */UrlMatcher.prototype.exec=function(path,search,hash,options){var _this=this;if(search===void 0){search={};}if(options===void 0){options={};}var match=memoizeTo(this._cache,'pattern',function(){return new RegExp(['^',common_1.unnest(_this._cache.path.concat(_this).map(hof_1.prop('_compiled'))).join(''),_this.config.strict===false?'\/?':'','$'].join(''),_this.config.caseInsensitive?'i':undefined);}).exec(path);if(!match)return null; //options = defaults(options, { isolate: false });
	var allParams=this.parameters(),pathParams=allParams.filter(function(param){return !param.isSearch();}),searchParams=allParams.filter(function(param){return param.isSearch();}),nPathSegments=this._cache.path.concat(this).map(function(urlm){return urlm._segments.length-1;}).reduce(function(a,x){return a+x;}),values={};if(nPathSegments!==match.length-1)throw new Error("Unbalanced capture group in route '"+this.pattern+"'");function decodePathArray(string){var reverseString=function reverseString(str){return str.split("").reverse().join("");};var unquoteDashes=function unquoteDashes(str){return str.replace(/\\-/g,"-");};var split=reverseString(string).split(/-(?!\\)/);var allReversed=common_1.map(split,reverseString);return common_1.map(allReversed,unquoteDashes).reverse();}for(var i=0;i<nPathSegments;i++){var param=pathParams[i];var value=match[i+1]; // if the param value matches a pre-replace pair, replace the value before decoding.
	for(var j=0;j<param.replace.length;j++){if(param.replace[j].from===value)value=param.replace[j].to;}if(value&&param.array===true)value=decodePathArray(value);if(predicates_2.isDefined(value))value=param.type.decode(value);values[param.id]=param.value(value);}common_1.forEach(searchParams,function(param){var value=search[param.id];for(var j=0;j<param.replace.length;j++){if(param.replace[j].from===value)value=param.replace[j].to;}if(predicates_2.isDefined(value))value=param.type.decode(value);values[param.id]=param.value(value);});if(hash)values["#"]=hash;return values;}; /**
		     * @ngdoc function
		     * @name ui.router.util.type:UrlMatcher#parameters
		     * @methodOf ui.router.util.type:UrlMatcher
		     *
		     * @description
		     * Returns the names of all path and search parameters of this pattern in order of appearance.
		     *
		     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
		     *    pattern has no parameters, an empty array is returned.
		     */UrlMatcher.prototype.parameters=function(opts){if(opts===void 0){opts={};}if(opts.inherit===false)return this._params;return common_1.unnest(this._cache.path.concat(this).map(hof_1.prop('_params')));};UrlMatcher.prototype.parameter=function(id,opts){if(opts===void 0){opts={};}var parent=common_1.tail(this._cache.path);return common_1.find(this._params,hof_1.propEq('id',id))||opts.inherit!==false&&parent&&parent.parameter(id)||null;}; /**
		     * @ngdoc function
		     * @name ui.router.util.type:UrlMatcher#validates
		     * @methodOf ui.router.util.type:UrlMatcher
		     *
		     * @description
		     * Checks an object hash of parameters to validate their correctness according to the parameter
		     * types of this `UrlMatcher`.
		     *
		     * @param {Object} params The object hash of parameters to validate.
		     * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
		     */UrlMatcher.prototype.validates=function(params){var _this=this;var validParamVal=function validParamVal(param,val){return !param||param.validates(val);};return common_1.pairs(params||{}).map(function(_a){var key=_a[0],val=_a[1];return validParamVal(_this.parameter(key),val);}).reduce(common_1.allTrueR,true);}; /**
		     * @ngdoc function
		     * @name ui.router.util.type:UrlMatcher#format
		     * @methodOf ui.router.util.type:UrlMatcher
		     *
		     * @description
		     * Creates a URL that matches this pattern by substituting the specified values
		     * for the path and search parameters. Null values for path parameters are
		     * treated as empty strings.
		     *
		     * @example
		     * <pre>
		     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
		     * // returns '/user/bob?q=yes'
		     * </pre>
		     *
		     * @param {Object} values  the values to substitute for the parameters in this pattern.
		     * @returns {string}  the formatted URL (path and optionally search part).
		     */UrlMatcher.prototype.format=function(values){if(values===void 0){values={};}if(!this.validates(values))return null; // Build the full path of UrlMatchers (including all parent UrlMatchers)
	var urlMatchers=this._cache.path.slice().concat(this); // Extract all the static segments and Params into an ordered array
	var pathSegmentsAndParams=urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_2.unnestR,[]); // Extract the query params into a separate array
	var queryParams=urlMatchers.map(UrlMatcher.queryParams).reduce(common_2.unnestR,[]); /**
		         * Given a Param,
		         * Applies the parameter value, then returns details about it
		         */function getDetails(param){ // Normalize to typed value
	var value=param.value(values[param.id]);var isDefaultValue=param.isDefaultValue(value); // Check if we're in squash mode for the parameter
	var squash=isDefaultValue?param.squash:false; // Allow the Parameter's Type to encode the value
	var encoded=param.type.encode(value);return {param:param,value:value,isDefaultValue:isDefaultValue,squash:squash,encoded:encoded};} // Build up the path-portion from the list of static segments and parameters
	var pathString=pathSegmentsAndParams.reduce(function(acc,x){ // The element is a static segment (a raw string); just append it
	if(predicates_1.isString(x))return acc+x; // Otherwise, it's a Param.  Fetch details about the parameter value
	var _a=getDetails(x),squash=_a.squash,encoded=_a.encoded,param=_a.param; // If squash is === true, try to remove a slash from the path
	if(squash===true)return acc.match(/\/$/)?acc.slice(0,-1):acc; // If squash is a string, use the string for the param value
	if(predicates_1.isString(squash))return acc+squash;if(squash!==false)return acc; // ?
	if(encoded==null)return acc; // If this parameter value is an array, encode the value using encodeDashes
	if(predicates_1.isArray(encoded))return acc+common_1.map(encoded,UrlMatcher.encodeDashes).join("-"); // If the parameter type is "raw", then do not encodeURIComponent
	if(param.type.raw)return acc+encoded; // Encode the value
	return acc+encodeURIComponent(encoded);},""); // Build the query string by applying parameter values (array or regular)
	// then mapping to key=value, then flattening and joining using "&"
	var queryString=queryParams.map(function(param){var _a=getDetails(param),squash=_a.squash,encoded=_a.encoded,isDefaultValue=_a.isDefaultValue;if(encoded==null||isDefaultValue&&squash!==false)return;if(!predicates_1.isArray(encoded))encoded=[encoded];if(encoded.length===0)return;if(!param.type.raw)encoded=common_1.map(encoded,encodeURIComponent);return encoded.map(function(val){return param.id+"="+val;});}).filter(common_1.identity).reduce(common_2.unnestR,[]).join("&"); // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
	return pathString+(queryString?"?"+queryString:"")+(values["#"]?"#"+values["#"]:"");};UrlMatcher.encodeDashes=function(str){return encodeURIComponent(str).replace(/-/g,function(c){return "%5C%"+c.charCodeAt(0).toString(16).toUpperCase();});}; /** Given a matcher, return an array with the matcher's path segments and path params, in order */UrlMatcher.pathSegmentsAndParams=function(matcher){var staticSegments=matcher._segments;var pathParams=matcher._params.filter(function(p){return p.location===param_1.DefType.PATH;});return common_3.arrayTuples(staticSegments,pathParams.concat(undefined)).reduce(common_2.unnestR,[]).filter(function(x){return x!==""&&predicates_2.isDefined(x);});}; /** Given a matcher, return an array with the matcher's query params */UrlMatcher.queryParams=function(matcher){return matcher._params.filter(function(p){return p.location===param_1.DefType.SEARCH;});};UrlMatcher.nameValidator=/^\w+([-.]+\w+)*(?:\[\])?$/;return UrlMatcher;}();exports.UrlMatcher=UrlMatcher; /***/}, /* 47 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module url */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(45);var module_2=__webpack_require__(20);function getDefaultConfig(){return {strict:module_1.matcherConfig.strictMode(),caseInsensitive:module_1.matcherConfig.caseInsensitive()};} /**
		 * Factory for [[UrlMatcher]] instances.
		 *
		 * The factory is available to ng1 services as
		 * `$urlMatcherFactor` or ng1 providers as `$urlMatcherFactoryProvider`.
		 */var UrlMatcherFactory=function(){function UrlMatcherFactory(){common_1.extend(this,{UrlMatcher:module_1.UrlMatcher,Param:module_2.Param});} /**
		     * Defines whether URL matching should be case sensitive (the default behavior), or not.
		     *
		     * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
		     * @returns the current value of caseInsensitive
		     */UrlMatcherFactory.prototype.caseInsensitive=function(value){return module_1.matcherConfig.caseInsensitive(value);}; /**
		     * Defines whether URLs should match trailing slashes, or not (the default behavior).
		     *
		     * @param value `false` to match trailing slashes in URLs, otherwise `true`.
		     * @returns the current value of strictMode
		     */UrlMatcherFactory.prototype.strictMode=function(value){return module_1.matcherConfig.strictMode(value);}; /**
		     * Sets the default behavior when generating or matching URLs with default parameter values.
		     *
		     * @param value A string that defines the default parameter URL squashing behavior.
		     *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
		     *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
		     *             parameter is surrounded by slashes, squash (remove) one slash from the URL
		     *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
		     *             the parameter value from the URL and replace it with this string.
		     * @returns the current value of defaultSquashPolicy
		     */UrlMatcherFactory.prototype.defaultSquashPolicy=function(value){return module_1.matcherConfig.defaultSquashPolicy(value);}; /**
		     * Creates a [[UrlMatcher]] for the specified pattern.
		     *
		     * @param pattern  The URL pattern.
		     * @param config  The config object hash.
		     * @returns The UrlMatcher.
		     */UrlMatcherFactory.prototype.compile=function(pattern,config){return new module_1.UrlMatcher(pattern,common_1.extend(getDefaultConfig(),config));}; /**
		     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
		     *
		     * @param object  The object to perform the type check against.
		     * @returns `true` if the object matches the `UrlMatcher` interface, by
		     *          implementing all the same methods.
		     */UrlMatcherFactory.prototype.isMatcher=function(object){ // TODO: typeof?
	if(!predicates_1.isObject(object))return false;var result=true;common_1.forEach(module_1.UrlMatcher.prototype,function(val,name){if(predicates_1.isFunction(val))result=result&&predicates_1.isDefined(object[name])&&predicates_1.isFunction(object[name]);});return result;};; /**
		     * Registers a custom [[Type]] object that can be used to generate URLs with typed parameters.
		     *
		     * @param name  The type name.
		     * @param definition The type definition. See [[Type]] for information on the values accepted.
		     * @param definitionFn A function that is injected before the app
		     *        runtime starts.  The result of this function is merged into the existing `definition`.
		     *        See [[Type]] for information on the values accepted.
		     *
		     * @returns - if a type was registered: the [[UrlMatcherFactory]]
		     *   - if only the `name` parameter was specified: the currently registered [[Type]] object, or undefined
		     *
		     * ---
		     *
		     * This is a simple example of a custom type that encodes and decodes items from an
		     * array, using the array index as the URL-encoded value:
		     *
		     * @example
		     * ```
		     *
		     * var list = ['John', 'Paul', 'George', 'Ringo'];
		     *
		     * $urlMatcherFactoryProvider.type('listItem', {
		     *   encode: function(item) {
		     *     // Represent the list item in the URL using its corresponding index
		     *     return list.indexOf(item);
		     *   },
		     *   decode: function(item) {
		     *     // Look up the list item by index
		     *     return list[parseInt(item, 10)];
		     *   },
		     *   is: function(item) {
		     *     // Ensure the item is valid by checking to see that it appears
		     *     // in the list
		     *     return list.indexOf(item) > -1;
		     *   }
		     * });
		     *
		     * $stateProvider.state('list', {
		     *   url: "/list/{item:listItem}",
		     *   controller: function($scope, $stateParams) {
		     *     console.log($stateParams.item);
		     *   }
		     * });
		     *
		     * // ...
		     *
		     * // Changes URL to '/list/3', logs "Ringo" to the console
		     * $state.go('list', { item: "Ringo" });
		     * ```
		     */UrlMatcherFactory.prototype.type=function(name,definition,definitionFn){var type=module_2.paramTypes.type(name,definition,definitionFn);return !predicates_1.isDefined(definition)?type:this;};; /** @hidden */UrlMatcherFactory.prototype.$get=function(){module_2.paramTypes.enqueue=false;module_2.paramTypes._flushTypeQueue();return this;};;return UrlMatcherFactory;}();exports.UrlMatcherFactory=UrlMatcherFactory; /***/}, /* 48 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module url */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var coreservices_1=__webpack_require__(6);var $location=coreservices_1.services.location; // Returns a string that is a prefix of all strings matching the RegExp
	function regExpPrefix(re){var prefix=/^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);return prefix!=null?prefix[1].replace(/\\(.)/g,"$1"):'';} // Interpolates matched values into a String.replace()-style pattern
	function interpolate(pattern,match){return pattern.replace(/\$(\$|\d{1,2})/,function(m,what){return match[what==='$'?0:Number(what)];});}function handleIfMatch($injector,$stateParams,handler,match){if(!match)return false;var result=$injector.invoke(handler,handler,{$match:match,$stateParams:$stateParams});return predicates_1.isDefined(result)?result:true;}function appendBasePath(url,isHtml5,absolute){var baseHref=coreservices_1.services.locationConfig.baseHref();if(baseHref==='/')return url;if(isHtml5)return baseHref.slice(0,-1)+url;if(absolute)return baseHref.slice(1)+url;return url;} // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
	function update(rules,otherwiseFn,evt){if(evt&&evt.defaultPrevented)return;function check(rule){var handled=rule(coreservices_1.services.$injector,$location);if(!handled)return false;if(predicates_1.isString(handled)){$location.replace();$location.url(handled);}return true;}var n=rules.length,i;for(i=0;i<n;i++){if(check(rules[i]))return;} // always check otherwise last to allow dynamic updates to the set of rules
	if(otherwiseFn)check(otherwiseFn);} /**
		 * @ngdoc object
		 * @name ui.router.router.$urlRouterProvider
		 *
		 * @requires ui.router.util.$urlMatcherFactoryProvider
		 * @requires $locationProvider
		 *
		 * @description
		 * `$urlRouterProvider` has the responsibility of watching `$location`.
		 * When `$location` changes it runs through a list of rules one by one until a
		 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify
		 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
		 *
		 * There are several methods on `$urlRouterProvider` that make it useful to use directly
		 * in your module config.
		 */var UrlRouterProvider=function(){function UrlRouterProvider($urlMatcherFactory,$stateParams){this.$urlMatcherFactory=$urlMatcherFactory;this.$stateParams=$stateParams; /** @hidden */this.rules=[]; /** @hidden */this.otherwiseFn=null; /** @hidden */this.interceptDeferred=false;} /**
		     * @ngdoc function
		     * @name ui.router.router.$urlRouterProvider#rule
		     * @methodOf ui.router.router.$urlRouterProvider
		     *
		     * @description
		     * Defines rules that are used by `$urlRouterProvider` to find matches for
		     * specific URLs.
		     *
		     * @example
		     * <pre>
		     * var app = angular.module('app', ['ui.router.router']);
		     *
		     * app.config(function ($urlRouterProvider) {
		     *   // Here's an example of how you might allow case insensitive urls
		     *   $urlRouterProvider.rule(function ($injector, $location) {
		     *     var path = $location.path(),
		     *         normalized = path.toLowerCase();
		     *
		     *     if (path !== normalized) {
		     *       return normalized;
		     *     }
		     *   });
		     * });
		     * </pre>
		     *
		     * @param {function} rule Handler function that takes `$injector` and `$location`
		     * services as arguments. You can use them to return a valid path as a string.
		     *
		     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
		     */UrlRouterProvider.prototype.rule=function(rule){if(!predicates_1.isFunction(rule))throw new Error("'rule' must be a function");this.rules.push(rule);return this;};; /**
		     * @ngdoc object
		     * @name ui.router.router.$urlRouterProvider#otherwise
		     * @methodOf ui.router.router.$urlRouterProvider
		     *
		     * @description
		     * Defines a path that is used when an invalid route is requested.
		     *
		     * @example
		     * <pre>
		     * var app = angular.module('app', ['ui.router.router']);
		     *
		     * app.config(function ($urlRouterProvider) {
		     *   // if the path doesn't match any of the urls you configured
		     *   // otherwise will take care of routing the user to the
		     *   // specified url
		     *   $urlRouterProvider.otherwise('/index');
		     *
		     *   // Example of using function rule as param
		     *   $urlRouterProvider.otherwise(function ($injector, $location) {
		     *     return '/a/valid/url';
		     *   });
		     * });
		     * </pre>
		     *
		     * @param {string|function} rule The url path you want to redirect to or a function
		     * rule that returns the url path. The function version is passed two params:
		     * `$injector` and `$location` services, and must return a url string.
		     *
		     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
		     */UrlRouterProvider.prototype.otherwise=function(rule){if(!predicates_1.isFunction(rule)&&!predicates_1.isString(rule))throw new Error("'rule' must be a string or function");this.otherwiseFn=predicates_1.isString(rule)?function(){return rule;}:rule;return this;};; /**
		     * @ngdoc function
		     * @name ui.router.router.$urlRouterProvider#when
		     * @methodOf ui.router.router.$urlRouterProvider
		     *
		     * @description
		     * Registers a handler for a given url matching.
		     *
		     * If the handler is a string, it is
		     * treated as a redirect, and is interpolated according to the syntax of match
		     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
		     *
		     * If the handler is a function, it is injectable. It gets invoked if `$location`
		     * matches. You have the option of inject the match object as `$match`.
		     *
		     * The handler can return
		     *
		     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
		     *   will continue trying to find another one that matches.
		     * - **string** which is treated as a redirect and passed to `$location.url()`
		     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
		     *
		     * @example
		     * <pre>
		     * var app = angular.module('app', ['ui.router.router']);
		     *
		     * app.config(function ($urlRouterProvider) {
		     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
		     *     if ($state.$current.navigable !== state ||
		     *         !equalForKeys($match, $stateParams) {
		     *      $state.transitionTo(state, $match, false);
		     *     }
		     *   });
		     * });
		     * </pre>
		     *
		     * @param {string|object} what The incoming path that you want to redirect.
		     * @param {string|function} handler The path you want to redirect your user to.
		     */UrlRouterProvider.prototype.when=function(what,handler){var _a=this,$urlMatcherFactory=_a.$urlMatcherFactory,$stateParams=_a.$stateParams;var redirect,handlerIsString=predicates_1.isString(handler); // @todo Queue this
	if(predicates_1.isString(what))what=$urlMatcherFactory.compile(what);if(!handlerIsString&&!predicates_1.isFunction(handler)&&!predicates_1.isArray(handler))throw new Error("invalid 'handler' in when()");var strategies={matcher:function matcher(_what,_handler){if(handlerIsString){redirect=$urlMatcherFactory.compile(_handler);_handler=['$match',redirect.format.bind(redirect)];}return common_1.extend(function(){return handleIfMatch(coreservices_1.services.$injector,$stateParams,_handler,_what.exec($location.path(),$location.search(),$location.hash()));},{prefix:predicates_1.isString(_what.prefix)?_what.prefix:''});},regex:function regex(_what,_handler){if(_what.global||_what.sticky)throw new Error("when() RegExp must not be global or sticky");if(handlerIsString){redirect=_handler;_handler=['$match',function($match){return interpolate(redirect,$match);}];}return common_1.extend(function(){return handleIfMatch(coreservices_1.services.$injector,$stateParams,_handler,_what.exec($location.path()));},{prefix:regExpPrefix(_what)});}};var check={matcher:$urlMatcherFactory.isMatcher(what),regex:what instanceof RegExp};for(var n in check){if(check[n])return this.rule(strategies[n](what,handler));}throw new Error("invalid 'what' in when()");};; /**
		     * @ngdoc function
		     * @name ui.router.router.$urlRouterProvider#deferIntercept
		     * @methodOf ui.router.router.$urlRouterProvider
		     *
		     * @description
		     * Disables (or enables) deferring location change interception.
		     *
		     * If you wish to customize the behavior of syncing the URL (for example, if you wish to
		     * defer a transition but maintain the current URL), call this method at configuration time.
		     * Then, at run time, call `$urlRouter.listen()` after you have configured your own
		     * `$locationChangeSuccess` event handler.
		     *
		     * @example
		     * <pre>
		     * var app = angular.module('app', ['ui.router.router']);
		     *
		     * app.config(function ($urlRouterProvider) {
		     *
		     *   // Prevent $urlRouter from automatically intercepting URL changes;
		     *   // this allows you to configure custom behavior in between
		     *   // location changes and route synchronization:
		     *   $urlRouterProvider.deferIntercept();
		     *
		     * }).run(function ($rootScope, $urlRouter, UserService) {
		     *
		     *   $rootScope.$on('$locationChangeSuccess', function(e) {
		     *     // UserService is an example service for managing user state
		     *     if (UserService.isLoggedIn()) return;
		     *
		     *     // Prevent $urlRouter's default handler from firing
		     *     e.preventDefault();
		     *
		     *     UserService.handleLogin().then(function() {
		     *       // Once the user has logged in, sync the current URL
		     *       // to the router:
		     *       $urlRouter.sync();
		     *     });
		     *   });
		     *
		     *   // Configures $urlRouter's listener *after* your custom listener
		     *   $urlRouter.listen();
		     * });
		     * </pre>
		     *
		     * @param {boolean} defer Indicates whether to defer location change interception. Passing
		     *        no parameter is equivalent to `true`.
		     */UrlRouterProvider.prototype.deferIntercept=function(defer){if(defer===undefined)defer=true;this.interceptDeferred=defer;};;return UrlRouterProvider;}();exports.UrlRouterProvider=UrlRouterProvider;var UrlRouter=function(){function UrlRouter(urlRouterProvider){this.urlRouterProvider=urlRouterProvider;common_1.bindFunctions(UrlRouter.prototype,this,this);} /**
		     * @ngdoc function
		     * @name ui.router.router.$urlRouter#sync
		     * @methodOf ui.router.router.$urlRouter
		     *
		     * @description
		     * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
		     * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
		     * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
		     * with the transition by calling `$urlRouter.sync()`.
		     *
		     * @example
		     * <pre>
		     * angular.module('app', ['ui.router'])
		     *   .run(function($rootScope, $urlRouter) {
		     *     $rootScope.$on('$locationChangeSuccess', function(evt) {
		     *       // Halt state change from even starting
		     *       evt.preventDefault();
		     *       // Perform custom logic
		     *       var meetsRequirement = ...
		     *       // Continue with the update and state transition if logic allows
		     *       if (meetsRequirement) $urlRouter.sync();
		     *     });
		     * });
		     * </pre>
		     */UrlRouter.prototype.sync=function(){update(this.urlRouterProvider.rules,this.urlRouterProvider.otherwiseFn);};UrlRouter.prototype.listen=function(){var _this=this;return this.listener=this.listener||$location.onChange(function(evt){return update(_this.urlRouterProvider.rules,_this.urlRouterProvider.otherwiseFn,evt);});};UrlRouter.prototype.update=function(read){if(read){this.location=$location.url();return;}if($location.url()===this.location)return;$location.url(this.location);$location.replace();};UrlRouter.prototype.push=function(urlMatcher,params,options){$location.url(urlMatcher.format(params||{}));if(options&&options.replace)$location.replace();}; /**
		     * @ngdoc function
		     * @name ui.router.router.$urlRouter#href
		     * @methodOf ui.router.router.$urlRouter
		     *
		     * @description
		     * A URL generation method that returns the compiled URL for a given
		     * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
		     *
		     * @example
		     * <pre>
		     * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
		     *   person: "bob"
		     * });
		     * // $bob == "/about/bob";
		     * </pre>
		     *
		     * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
		     * @param {object=} params An object of parameter values to fill the matcher's required parameters.
		     * @param {object=} options Options object. The options are:
		     *
		     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
		     *
		     * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
		     */UrlRouter.prototype.href=function(urlMatcher,params,options){if(!urlMatcher.validates(params))return null;var url=urlMatcher.format(params);options=options||{};var cfg=coreservices_1.services.locationConfig;var isHtml5=cfg.html5Mode();if(!isHtml5&&url!==null){url="#"+cfg.hashPrefix()+url;}url=appendBasePath(url,isHtml5,options.absolute);if(!options.absolute||!url){return url;}var slash=!isHtml5&&url?'/':'',port=cfg.port();port=port===80||port===443?'':':'+port;return [cfg.protocol(),'://',cfg.host(),port,slash,url].join('');};return UrlRouter;}();exports.UrlRouter=UrlRouter; /***/}, /* 49 */ /***/function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m){if(!exports.hasOwnProperty(p))exports[p]=m[p];}} /** @module view */ /** for typedoc */__export(__webpack_require__(50)); /***/}, /* 50 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module view */ /** for typedoc */var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(2);var match=function match(obj1){var keys=[];for(var _i=1;_i<arguments.length;_i++){keys[_i-1]=arguments[_i];}return function(obj2){return keys.reduce(function(memo,key){return memo&&obj1[key]===obj2[key];},true);};}; /**
		 * The View service
		 */var ViewService=function(){function ViewService(){var _this=this;this.uiViews=[];this.viewConfigs=[];this._viewConfigFactories={};this.sync=function(){var uiViewsByFqn=_this.uiViews.map(function(uiv){return [uiv.fqn,uiv];}).reduce(common_1.applyPairs,{}); /**
		             * Given a ui-view and a ViewConfig, determines if they "match".
		             *
		             * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
		             * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
		             *
		             * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
		             * can be a segmented ui-view path, describing a portion of a ui-view fqn.
		             *
		             * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
		             * - the ui-view's name matches the ViewConfig's target name
		             * - the ui-view's context matches the ViewConfig's anchor
		             *
		             * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
		             * - There exists a parent ui-view where:
		             *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
		             *    - the parent ui-view's context matches the ViewConfig's anchor
		             * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
		             *
		             * Example:
		             *
		             * DOM:
		             * <div ui-view>                        <!-- created in the root context (name: "") -->
		             *   <div ui-view="foo">                <!-- created in the context named: "A"      -->
		             *     <div ui-view>                    <!-- created in the context named: "A.B"    -->
		             *       <div ui-view="bar">            <!-- created in the context named: "A.B.C"  -->
		             *       </div>
		             *     </div>
		             *   </div>
		             * </div>
		             *
		             * uiViews: [
		             *  { fqn: "$default",                  creationContext: { name: "" } },
		             *  { fqn: "$default.foo",              creationContext: { name: "A" } },
		             *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
		             *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
		             * ]
		             *
		             * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
		             *
		             * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
		             * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
		             * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
		             * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
		             *
		             * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
		             * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
		             * - There exists a parent ui-view (which has fqn: "$default.foo") where:
		             *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
		             *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
		             * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
		             *   the tail of the ui-view's fqn "default.bar"
		             */var matches=function matches(uiView){return function(viewConfig){ // Split names apart from both viewConfig and uiView into segments
	var vc=viewConfig.viewDecl;var vcSegments=vc.$uiViewName.split(".");var uivSegments=uiView.fqn.split("."); // Check if the tails of the segment arrays match. ex, these arrays' tails match:
	// vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
	if(!common_1.equals(vcSegments,uivSegments.slice(0-vcSegments.length)))return false; // Now check if the fqn ending at the first segment of the viewConfig matches the context:
	// ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
	var negOffset=1-vcSegments.length||undefined;var fqnToFirstSegment=uivSegments.slice(0,negOffset).join(".");var uiViewContext=uiViewsByFqn[fqnToFirstSegment].creationContext;return vc.$uiViewContextAnchor===(uiViewContext&&uiViewContext.name);};}; // Return the number of dots in the fully qualified name
	function uiViewDepth(uiView){return uiView.fqn.split(".").length;} // Return the ViewConfig's context's depth in the context tree.
	function viewConfigDepth(config){var context=config.viewDecl.$context,count=0;while(++count&&context.parent){context=context.parent;}return count;} // Given a depth function, returns a compare function which can return either ascending or descending order
	var depthCompare=hof_1.curry(function(depthFn,posNeg,left,right){return posNeg*(depthFn(left)-depthFn(right));});var matchingConfigPair=function matchingConfigPair(uiView){var matchingConfigs=_this.viewConfigs.filter(matches(uiView));if(matchingConfigs.length>1)matchingConfigs.sort(depthCompare(viewConfigDepth,-1)); // descending
	return [uiView,matchingConfigs[0]];};var configureUiView=function configureUiView(_a){var uiView=_a[0],viewConfig=_a[1]; // If a parent ui-view is reconfigured, it could destroy child ui-views.
	// Before configuring a child ui-view, make sure it's still in the active uiViews array.
	if(_this.uiViews.indexOf(uiView)!==-1)uiView.configUpdated(viewConfig);};_this.uiViews.sort(depthCompare(uiViewDepth,1)).map(matchingConfigPair).forEach(configureUiView);};}ViewService.prototype.rootContext=function(context){return this._rootContext=context||this._rootContext;};;ViewService.prototype.viewConfigFactory=function(viewType,factory){this._viewConfigFactories[viewType]=factory;};ViewService.prototype.createViewConfig=function(node,decl){var cfgFactory=this._viewConfigFactories[decl.$type];if(!cfgFactory)throw new Error("ViewService: No view config factory registered for type "+decl.$type);return cfgFactory(node,decl);}; /**
		     * De-registers a ViewConfig.
		     *
		     * @param viewConfig The ViewConfig view to deregister.
		     */ViewService.prototype.deactivateViewConfig=function(viewConfig){module_1.trace.traceViewServiceEvent("<- Removing",viewConfig);common_1.removeFrom(this.viewConfigs,viewConfig);};;ViewService.prototype.activateViewConfig=function(viewConfig){module_1.trace.traceViewServiceEvent("-> Registering",viewConfig);this.viewConfigs.push(viewConfig);};; /**
		     * Allows a `ui-view` element to register its canonical name with a callback that allows it to
		     * be updated with a template, controller, and local variables.
		     *
		     * @param {String} name The fully-qualified name of the `ui-view` object being registered.
		     * @param {Function} configUpdatedCallback A callback that receives updates to the content & configuration
		     *                   of the view.
		     * @return {Function} Returns a de-registration function used when the view is destroyed.
		     */ViewService.prototype.registerUiView=function(uiView){module_1.trace.traceViewServiceUiViewEvent("-> Registering",uiView);var uiViews=this.uiViews;var fqnMatches=function fqnMatches(uiv){return uiv.fqn===uiView.fqn;};if(uiViews.filter(fqnMatches).length)module_1.trace.traceViewServiceUiViewEvent("!!!! duplicate uiView named:",uiView);uiViews.push(uiView);this.sync();return function(){var idx=uiViews.indexOf(uiView);if(idx<=0){module_1.trace.traceViewServiceUiViewEvent("Tried removing non-registered uiView",uiView);return;}module_1.trace.traceViewServiceUiViewEvent("<- Deregistering",uiView);common_1.removeFrom(uiViews)(uiView);};};; /**
		     * Returns the list of views currently available on the page, by fully-qualified name.
		     *
		     * @return {Array} Returns an array of fully-qualified view names.
		     */ViewService.prototype.available=function(){return this.uiViews.map(hof_1.prop("fqn"));}; /**
		     * Returns the list of views on the page containing loaded content.
		     *
		     * @return {Array} Returns an array of fully-qualified view names.
		     */ViewService.prototype.active=function(){return this.uiViews.filter(hof_1.prop("$config")).map(hof_1.prop("name"));}; /**
		     * Normalizes a view's name from a state.views configuration block.
		     *
		     * @param context the context object (state declaration) that the view belongs to
		     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
		     *
		     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets
		     */ViewService.normalizeUiViewTarget=function(context,rawViewName){if(rawViewName===void 0){rawViewName="";} // TODO: Validate incoming view name with a regexp to allow:
	// ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
	// "@" , "$default@^" , "!$default.$default" , "!foo.bar"
	var viewAtContext=rawViewName.split("@");var uiViewName=viewAtContext[0]||"$default"; // default to unnamed view
	var uiViewContextAnchor=predicates_1.isString(viewAtContext[1])?viewAtContext[1]:"^"; // default to parent context
	// Handle relative view-name sugar syntax.
	// Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
	var relativeViewNameSugar=/^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);if(relativeViewNameSugar){ // Clobbers existing contextAnchor (rawViewName validation will fix this)
	uiViewContextAnchor=relativeViewNameSugar[1]; // set anchor to "^.^.^"
	uiViewName=relativeViewNameSugar[2]; // set view-name to "foo.bar"
	}if(uiViewName.charAt(0)==='!'){uiViewName=uiViewName.substr(1);uiViewContextAnchor=""; // target absolutely from root
	} // handle parent relative targeting "^.^.^"
	var relativeMatch=/^(\^(?:\.\^)*)$/;if(relativeMatch.exec(uiViewContextAnchor)){var anchor=uiViewContextAnchor.split(".").reduce(function(anchor,x){return anchor.parent;},context);uiViewContextAnchor=anchor.name;}return {uiViewName:uiViewName,uiViewContextAnchor:uiViewContextAnchor};};return ViewService;}();exports.ViewService=ViewService; /***/}, /* 51 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module core */ /** */var urlMatcherFactory_1=__webpack_require__(47);var urlRouter_1=__webpack_require__(48);var state_1=__webpack_require__(18);var urlRouter_2=__webpack_require__(48);var transitionService_1=__webpack_require__(43);var view_1=__webpack_require__(50);var stateRegistry_1=__webpack_require__(36);var stateService_1=__webpack_require__(37);var globals_1=__webpack_require__(52); /**
		 * The master class used to instantiate an instance of UI-Router.
		 *
		 * This class instantiates and wires the global UI-Router services.
		 *
		 * After instantiating a new instance of the Router class, configure it for your app.  For instance, register
		 * your app states with the [[stateRegistry]] (and set url options using ...).  Then, tell UI-Router to monitor
		 * the URL by calling `urlRouter.listen()` ([[URLRouter.listen]])
		 */var UIRouter=function(){function UIRouter(){this.viewService=new view_1.ViewService();this.transitionService=new transitionService_1.TransitionService(this.viewService);this.globals=new globals_1.UIRouterGlobals(this.transitionService);this.urlMatcherFactory=new urlMatcherFactory_1.UrlMatcherFactory();this.urlRouterProvider=new urlRouter_1.UrlRouterProvider(this.urlMatcherFactory,this.globals.params);this.urlRouter=new urlRouter_2.UrlRouter(this.urlRouterProvider);this.stateRegistry=new stateRegistry_1.StateRegistry(this.urlMatcherFactory,this.urlRouterProvider); /** @hidden TODO: move this to ng1.ts */this.stateProvider=new state_1.StateProvider(this.stateRegistry);this.stateService=new stateService_1.StateService(this.viewService,this.urlRouter,this.transitionService,this.stateRegistry,this.stateProvider,this.globals);this.viewService.rootContext(this.stateRegistry.root());this.globals.$current=this.stateRegistry.root();this.globals.current=this.globals.$current.self;}return UIRouter;}();exports.UIRouter=UIRouter; /***/}, /* 52 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module core */ /** */var stateParams_1=__webpack_require__(25);var queue_1=__webpack_require__(8);var common_1=__webpack_require__(3); /**
		 * Global mutable state
		 *
		 * This is where we hold the global mutable state such as current state, current
		 * params, current transition, last successful transition, last attempted transition, etc.
		 */var UIRouterGlobals=function(){function UIRouterGlobals(transitionService){var _this=this; /**
		         * Current parameter values
		         *
		         * The parameter values from the latest successful transition
		         */this.params=new stateParams_1.StateParams(); /**
		         * The transition history
		         *
		         * This queue's size is limited to a maximum number (default: 1)
		         */this.transitionHistory=new queue_1.Queue([],1); /**
		         * The history of successful transitions
		         *
		         * This queue's size is limited to a maximum number (default: 1)
		         */this.successfulTransitions=new queue_1.Queue([],1);var beforeNewTransition=function beforeNewTransition($transition$){_this.transition=$transition$;_this.transitionHistory.enqueue($transition$);var updateGlobalState=function updateGlobalState(){_this.successfulTransitions.enqueue($transition$);_this.$current=$transition$.$to();_this.current=_this.$current.self;common_1.copy($transition$.params(),_this.params);};$transition$.onSuccess({},updateGlobalState,{priority:10000});var clearCurrentTransition=function clearCurrentTransition(){if(_this.transition===$transition$)_this.transition=null;};$transition$.promise.then(clearCurrentTransition,clearCurrentTransition);};transitionService.onBefore({},['$transition$',beforeNewTransition]);}return UIRouterGlobals;}();exports.UIRouterGlobals=UIRouterGlobals; /***/}, /* 53 */ /***/function(module,exports,__webpack_require__){ /**
		 * # UI-Router for Angular 1
		 *
		 * - Provides an implementation for the [[CoreServices]] API, based on angular 1 services.
		 * - Also registers some services with the angular 1 injector.
		 * - Creates and bootstraps a new [[UIRouter]] object.  Ties it to the the angular 1 lifecycle.
		 *
		 * @module ng1
		 * @preferred
		 */"use strict"; /** for typedoc */var router_1=__webpack_require__(51);var coreservices_1=__webpack_require__(6);var common_1=__webpack_require__(3);var hof_1=__webpack_require__(5);var predicates_1=__webpack_require__(4);var module_1=__webpack_require__(44);var module_2=__webpack_require__(40);var module_3=__webpack_require__(17);var trace_1=__webpack_require__(12);var viewsBuilder_1=__webpack_require__(54);var templateFactory_1=__webpack_require__(55); /** @hidden */var app=angular.module("ui.router.angular1",[]); /**
		 * @ngdoc overview
		 * @name ui.router.util
		 *
		 * @description
		 * # ui.router.util sub-module
		 *
		 * This module is a dependency of other sub-modules. Do not include this module as a dependency
		 * in your angular app (use {@link ui.router} module instead).
		 *
		 */angular.module('ui.router.util',['ng','ui.router.init']); /**
		 * @ngdoc overview
		 * @name ui.router.router
		 *
		 * @requires ui.router.util
		 *
		 * @description
		 * # ui.router.router sub-module
		 *
		 * This module is a dependency of other sub-modules. Do not include this module as a dependency
		 * in your angular app (use {@link ui.router} module instead).
		 */angular.module('ui.router.router',['ui.router.util']); /**
		 * @ngdoc overview
		 * @name ui.router.state
		 *
		 * @requires ui.router.router
		 * @requires ui.router.util
		 *
		 * @description
		 * # ui.router.state sub-module
		 *
		 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
		 * in your angular app (use {@link ui.router} module instead).
		 *
		 */angular.module('ui.router.state',['ui.router.router','ui.router.util','ui.router.angular1']); /**
		 * @ngdoc overview
		 * @name ui.router
		 *
		 * @requires ui.router.state
		 *
		 * @description
		 * # ui.router
		 *
		 * ## The main module for ui.router
		 * There are several sub-modules included with the ui.router module, however only this module is needed
		 * as a dependency within your angular app. The other modules are for organization purposes.
		 *
		 * The modules are:
		 * * ui.router - the main "umbrella" module
		 * * ui.router.router -
		 *
		 * *You'll need to include **only** this module as the dependency within your angular app.*
		 *
		 * <pre>
		 * <!doctype html>
		 * <html ng-app="myApp">
		 * <head>
		 *   <script src="js/angular.js"></script>
		 *   <!-- Include the ui-router script -->
		 *   <script src="js/angular-ui-router.min.js"></script>
		 *   <script>
		 *     // ...and add 'ui.router' as a dependency
		 *     var myApp = angular.module('myApp', ['ui.router']);
		 *   </script>
		 * </head>
		 * <body>
		 * </body>
		 * </html>
		 * </pre>
		 */angular.module('ui.router',['ui.router.init','ui.router.state','ui.router.angular1']);angular.module('ui.router.compat',['ui.router']); /**
		 * Annotates a controller expression (may be a controller function(), a "controllername",
		 * or "controllername as name")
		 *
		 * - Temporarily decorates $injector.instantiate.
		 * - Invokes $controller() service
		 *   - Calls $injector.instantiate with controller constructor
		 * - Annotate constructor
		 * - Undecorate $injector
		 *
		 * returns an array of strings, which are the arguments of the controller expression
		 */function annotateController(controllerExpression){var $injector=coreservices_1.services.$injector;var $controller=$injector.get("$controller");var oldInstantiate=$injector.instantiate;try{var deps_1;$injector.instantiate=function fakeInstantiate(constructorFunction){$injector.instantiate=oldInstantiate; // Un-decorate ASAP
	deps_1=$injector.annotate(constructorFunction);};$controller(controllerExpression,{$scope:{}});return deps_1;}finally {$injector.instantiate=oldInstantiate;}}exports.annotateController=annotateController;runBlock.$inject=['$injector','$q'];function runBlock($injector,$q){coreservices_1.services.$injector=$injector;coreservices_1.services.$q=$q;}app.run(runBlock);var router=null;ng1UIRouter.$inject=['$locationProvider']; /** This angular 1 provider instantiates a Router and exposes its services via the angular injector */function ng1UIRouter($locationProvider){ // Create a new instance of the Router when the ng1UIRouterProvider is initialized
	router=new router_1.UIRouter(); // Apply ng1 `views` builder to the StateBuilder
	router.stateRegistry.decorator("views",viewsBuilder_1.ng1ViewsBuilder);router.viewService.viewConfigFactory('ng1',viewsBuilder_1.ng1ViewConfigFactory); // Bind LocationConfig.hashPrefix to $locationProvider.hashPrefix
	common_1.bindFunctions($locationProvider,coreservices_1.services.locationConfig,$locationProvider,['hashPrefix']); // Create a LocationService.onChange registry
	var urlListeners=[];coreservices_1.services.location.onChange=function(callback){urlListeners.push(callback);return function(){return common_1.removeFrom(urlListeners)(callback);};};this.$get=$get;$get.$inject=['$location','$browser','$sniffer','$rootScope','$http','$templateCache'];function $get($location,$browser,$sniffer,$rootScope,$http,$templateCache){ // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange
	$rootScope.$on("$locationChangeSuccess",function(evt){return urlListeners.forEach(function(fn){return fn(evt);});}); // Bind LocationConfig.html5Mode to $locationProvider.html5Mode and $sniffer.history
	coreservices_1.services.locationConfig.html5Mode=function(){var html5Mode=$locationProvider.html5Mode();html5Mode=predicates_1.isObject(html5Mode)?html5Mode.enabled:html5Mode;return html5Mode&&$sniffer.history;};coreservices_1.services.template.get=function(url){return $http.get(url,{cache:$templateCache,headers:{Accept:'text/html'}}).then(hof_1.prop("data"));}; // Bind these LocationService functions to $location
	common_1.bindFunctions($location,coreservices_1.services.location,$location,["replace","url","path","search","hash"]); // Bind these LocationConfig functions to $location
	common_1.bindFunctions($location,coreservices_1.services.locationConfig,$location,['port','protocol','host']); // Bind these LocationConfig functions to $browser
	common_1.bindFunctions($browser,coreservices_1.services.locationConfig,$browser,['baseHref']);return router;}}var resolveFactory=function resolveFactory(){return { /**
		     * This emulates most of the behavior of the ui-router 0.2.x $resolve.resolve() service API.
		     * @param invocables an object, with keys as resolve names and values as injectable functions
		     * @param locals key/value pre-resolved data (locals)
		     * @param parent a promise for a "parent resolve"
		     */resolve:function resolve(invocables,locals,parent){if(locals===void 0){locals={};}var parentNode=new module_1.Node(new module_3.State({params:{}}));var node=new module_1.Node(new module_3.State({params:{}}));var context=new module_2.ResolveContext([parentNode,node]);context.addResolvables(module_2.Resolvable.makeResolvables(invocables),node.state);var resolveData=function resolveData(parentLocals){var rewrap=function rewrap(_locals){return module_2.Resolvable.makeResolvables(common_1.map(_locals,function(local){return function(){return local;};}));};context.addResolvables(rewrap(parentLocals),parentNode.state);context.addResolvables(rewrap(locals),node.state);return context.resolvePath();};return parent?parent.then(resolveData):resolveData({});}};};function $stateParamsFactory(ng1UIRouter){return ng1UIRouter.globals.params;} // The 'ui.router' ng1 module depends on 'ui.router.init' module.
	angular.module('ui.router.init',[]).provider("ng1UIRouter",ng1UIRouter); // This effectively calls $get() to init when we enter runtime
	angular.module('ui.router.init').run(['ng1UIRouter',function(ng1UIRouter){}]); // $urlMatcherFactory service and $urlMatcherFactoryProvider
	angular.module('ui.router.util').provider('$urlMatcherFactory',['ng1UIRouterProvider',function(){return router.urlMatcherFactory;}]);angular.module('ui.router.util').run(['$urlMatcherFactory',function($urlMatcherFactory){}]); // $urlRouter service and $urlRouterProvider
	function getUrlRouterProvider(){router.urlRouterProvider["$get"]=function(){router.urlRouter.update(true);if(!this.interceptDeferred)router.urlRouter.listen();return router.urlRouter;};return router.urlRouterProvider;}angular.module('ui.router.router').provider('$urlRouter',['ng1UIRouterProvider',getUrlRouterProvider]);angular.module('ui.router.router').run(['$urlRouter',function($urlRouter){}]); // $state service and $stateProvider
	// $urlRouter service and $urlRouterProvider
	function getStateProvider(){router.stateProvider["$get"]=function(){ // Autoflush once we are in runtime
	router.stateRegistry.stateQueue.autoFlush(router.stateService);return router.stateService;};return router.stateProvider;}angular.module('ui.router.state').provider('$state',['ng1UIRouterProvider',getStateProvider]);angular.module('ui.router.state').run(['$state',function($state){}]); // $stateParams service
	angular.module('ui.router.state').factory('$stateParams',['ng1UIRouter',function(ng1UIRouter){return ng1UIRouter.globals.params;}]); // $transitions service and $transitionsProvider
	function getTransitionsProvider(){loadAllControllerLocals.$inject=['$transition$'];function loadAllControllerLocals($transition$){var loadLocals=function loadLocals(vc){var node=common_1.find($transition$.treeChanges().to,hof_1.propEq('state',vc.viewDecl.$context)); // Temporary fix; This whole callback should be nuked when fixing #2662
	if(!node)return coreservices_1.services.$q.when();var resolveCtx=node.resolveContext;var controllerDeps=annotateController(vc.controller);var resolvables=resolveCtx.getResolvables();function $loadControllerLocals(){}$loadControllerLocals.$inject=controllerDeps.filter(function(dep){return resolvables.hasOwnProperty(dep);}); // Load any controller resolves that aren't already loaded
	return resolveCtx.invokeLater($loadControllerLocals).then(function(){return vc.locals=common_1.map(resolvables,function(res){return res.data;});});};var loadAllLocals=$transition$.views("entering").filter(function(vc){return !!vc.controller;}).map(loadLocals);return coreservices_1.services.$q.all(loadAllLocals).then(common_1.noop);}router.transitionService.onFinish({},loadAllControllerLocals);router.transitionService["$get"]=function(){return router.transitionService;};return router.transitionService;}angular.module('ui.router.state').provider('$transitions',['ng1UIRouterProvider',getTransitionsProvider]); // $templateFactory service
	angular.module('ui.router.util').factory('$templateFactory',['ng1UIRouter',function(){return new templateFactory_1.TemplateFactory();}]); // The $view service
	angular.module('ui.router').factory('$view',function(){return router.viewService;}); // The old $resolve service
	angular.module('ui.router').factory('$resolve',resolveFactory); // $trace service
	angular.module("ui.router").service("$trace",function(){return trace_1.trace;});watchDigests.$inject=['$rootScope'];function watchDigests($rootScope){$rootScope.$watch(function(){trace_1.trace.approximateDigests++;});}exports.watchDigests=watchDigests;angular.module("ui.router").run(watchDigests); /***/}, /* 54 */ /***/function(module,exports,__webpack_require__){"use strict";var common_1=__webpack_require__(3);var strings_1=__webpack_require__(9);var view_1=__webpack_require__(50);var predicates_1=__webpack_require__(4);var coreservices_1=__webpack_require__(6);var trace_1=__webpack_require__(12);var templateFactory_1=__webpack_require__(55);exports.ng1ViewConfigFactory=function(node,view){return new Ng1ViewConfig(node,view);}; /**
		 * This is a [[StateBuilder.builder]] function for angular1 `views`.
		 *
		 * When the [[StateBuilder]] builds a [[State]] object from a raw [[StateDeclaration]], this builder
		 * handles the `views` property with logic specific to angular-ui-router (ng1).
		 *
		 * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
		 * and applies the state-level configuration to a view named `$default`.
		 */function ng1ViewsBuilder(state){var tplKeys=['templateProvider','templateUrl','template','notify','async'],ctrlKeys=['controller','controllerProvider','controllerAs','resolveAs'],compKeys=['component','bindings'],nonCompKeys=tplKeys.concat(ctrlKeys),allKeys=compKeys.concat(nonCompKeys);var views={},viewsObject=state.views||{"$default":common_1.pick(state,allKeys)};common_1.forEach(viewsObject,function(config,name){ // Account for views: { "": { template... } }
	name=name||"$default"; // Account for views: { header: "headerComponent" }
	if(predicates_1.isString(config))config={component:config};if(!Object.keys(config).length)return; // Configure this view for routing to an angular 1.5+ style .component (or any directive, really)
	if(config.component){if(nonCompKeys.map(function(key){return predicates_1.isDefined(config[key]);}).reduce(common_1.anyTrueR,false)){throw new Error("Cannot combine: "+compKeys.join("|")+" with: "+nonCompKeys.join("|")+" in stateview: 'name@"+state.name+"'");} // Dynamically build a template like "<component-name input1='$resolve.foo'></component-name>"
	config.templateProvider=['$injector',function($injector){var resolveFor=function resolveFor(key){return config.bindings&&config.bindings[key]||key;};var prefix=angular.version.minor>=3?"::":"";var attrs=getComponentInputs($injector,config.component).map(function(key){return strings_1.kebobString(key)+"='"+prefix+"$resolve."+resolveFor(key)+"'";}).join(" ");var kebobName=strings_1.kebobString(config.component);return "<"+kebobName+" "+attrs+"></"+kebobName+">";}];}config.resolveAs=config.resolveAs||'$resolve';config.$type="ng1";config.$context=state;config.$name=name;var normalized=view_1.ViewService.normalizeUiViewTarget(config.$context,config.$name);config.$uiViewName=normalized.uiViewName;config.$uiViewContextAnchor=normalized.uiViewContextAnchor;views[name]=config;});return views;}exports.ng1ViewsBuilder=ng1ViewsBuilder; // for ng 1.2 style, process the scope: { input: "=foo" } object
	var scopeBindings=function scopeBindings(bindingsObj){return Object.keys(bindingsObj||{}).map(function(key){return [key,/^[=<](.*)/.exec(bindingsObj[key])];}).filter(function(tuple){return predicates_1.isDefined(tuple[1]);}).map(function(tuple){return tuple[1][1]||tuple[0];});}; // for ng 1.3+ bindToController or 1.5 component style, process a $$bindings object
	var bindToCtrlBindings=function bindToCtrlBindings(bindingsObj){return Object.keys(bindingsObj||{}).filter(function(key){return !!/[=<]/.exec(bindingsObj[key].mode);}).map(function(key){return bindingsObj[key].attrName;});}; // Given a directive definition, find its object input attributes
	// Use different properties, depending on the type of directive (component, bindToController, normal)
	var getBindings=function getBindings(def){if(predicates_1.isObject(def.bindToController))return scopeBindings(def.bindToController);if(def.$$bindings&&def.$$bindings.bindToController)return bindToCtrlBindings(def.$$bindings.bindToController);if(def.$$isolateBindings)return bindToCtrlBindings(def.$$isolateBindings);return scopeBindings(def.scope);}; // Gets all the directive(s)' inputs ('=' and '<')
	function getComponentInputs($injector,name){var cmpDefs=$injector.get(name+"Directive"); // could be multiple
	if(!cmpDefs||!cmpDefs.length)throw new Error("Unable to find component named '"+name+"'");return cmpDefs.map(getBindings).reduce(common_1.unnestR,[]);}var Ng1ViewConfig=function(){function Ng1ViewConfig(node,viewDecl){this.node=node;this.viewDecl=viewDecl;this.loaded=false;}Ng1ViewConfig.prototype.load=function(){var _this=this;var $q=coreservices_1.services.$q;if(!this.hasTemplate())throw new Error("No template configuration specified for '"+this.viewDecl.$uiViewName+"@"+this.viewDecl.$uiViewContextAnchor+"'");var injector=this.node.resolveContext;var params=this.node.paramValues;var promises={template:$q.when(this.getTemplate(params,new templateFactory_1.TemplateFactory(),injector)),controller:$q.when(this.getController(injector))};return $q.all(promises).then(function(results){trace_1.trace.traceViewServiceEvent("Loaded",_this);_this.controller=results.controller;_this.template=results.template;});}; /**
		     * Checks a view configuration to ensure that it specifies a template.
		     *
		     * @return {boolean} Returns `true` if the configuration contains a valid template, otherwise `false`.
		     */Ng1ViewConfig.prototype.hasTemplate=function(){return !!(this.viewDecl.template||this.viewDecl.templateUrl||this.viewDecl.templateProvider);};Ng1ViewConfig.prototype.getTemplate=function(params,$factory,injector){return $factory.fromConfig(this.viewDecl,params,injector.invokeLater.bind(injector));}; /**
		     * Gets the controller for a view configuration.
		     *
		     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
		     */Ng1ViewConfig.prototype.getController=function(injector){ //* @param {Object} locals A context object from transition.context() to invoke a function in the correct context
	var provider=this.viewDecl.controllerProvider;return predicates_1.isInjectable(provider)?injector.invokeLater(provider,{}):this.viewDecl.controller;};return Ng1ViewConfig;}();exports.Ng1ViewConfig=Ng1ViewConfig; /***/}, /* 55 */ /***/function(module,exports,__webpack_require__){"use strict"; /** @module view */ /** for typedoc */var predicates_1=__webpack_require__(4);var coreservices_1=__webpack_require__(6); /**
		 * Service which manages loading of templates from a ViewConfig.
		 */var TemplateFactory=function(){function TemplateFactory(){} /**
		     * Creates a template from a configuration object.
		     *
		     * @param config Configuration object for which to load a template.
		     * The following properties are search in the specified order, and the first one
		     * that is defined is used to create the template:
		     *
		     * @param params  Parameters to pass to the template function.
		     * @param injectFn Function to which an injectable function may be passed.
		     *        If templateProvider is defined, this injectFn will be used to invoke it.
		     *
		     * @return {string|object}  The template html as a string, or a promise for
		     * that string,or `null` if no template is configured.
		     */TemplateFactory.prototype.fromConfig=function(config,params,injectFn){return predicates_1.isDefined(config.template)?this.fromString(config.template,params):predicates_1.isDefined(config.templateUrl)?this.fromUrl(config.templateUrl,params):predicates_1.isDefined(config.templateProvider)?this.fromProvider(config.templateProvider,params,injectFn):null;};; /**
		     * Creates a template from a string or a function returning a string.
		     *
		     * @param template html template as a string or function that returns an html template as a string.
		     * @param params Parameters to pass to the template function.
		     *
		     * @return {string|object} The template html as a string, or a promise for that
		     * string.
		     */TemplateFactory.prototype.fromString=function(template,params){return predicates_1.isFunction(template)?template(params):template;};; /**
		     * Loads a template from the a URL via `$http` and `$templateCache`.
		     *
		     * @param {string|Function} url url of the template to load, or a function
		     * that returns a url.
		     * @param {Object} params Parameters to pass to the url function.
		     * @return {string|Promise.<string>} The template html as a string, or a promise
		     * for that string.
		     */TemplateFactory.prototype.fromUrl=function(url,params){if(predicates_1.isFunction(url))url=url(params);if(url==null)return null;return coreservices_1.services.template.get(url);};; /**
		     * Creates a template by invoking an injectable provider function.
		     *
		     * @param provider Function to invoke via `locals`
		     * @param {Function} injectFn a function used to invoke the template provider
		     * @return {string|Promise.<string>} The template html as a string, or a promise
		     * for that string.
		     */TemplateFactory.prototype.fromProvider=function(provider,params,injectFn){return injectFn(provider);};;return TemplateFactory;}();exports.TemplateFactory=TemplateFactory; /***/}, /* 56 */ /***/function(module,exports,__webpack_require__){"use strict"; /**
		 * These are the UI-Router angular 1 directives.
		 *
		 * These directives are used in templates to create viewports and navigate to states
		 *
		 * @preferred @module ng1_directives
		 */ /** for typedoc */var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var hof_1=__webpack_require__(5); /** @hidden */function parseStateRef(ref,current){var preparsed=ref.match(/^\s*({[^}]*})\s*$/),parsed;if(preparsed)ref=current+'('+preparsed[1]+')';parsed=ref.replace(/\n/g," ").match(/^([^(]+?)\s*(\((.*)\))?$/);if(!parsed||parsed.length!==4)throw new Error("Invalid state ref '"+ref+"'");return {state:parsed[1],paramExpr:parsed[3]||null};} /** @hidden */function stateContext(el){var $uiView=el.parent().inheritedData('$uiView');var context=hof_1.parse('$cfg.node.state')($uiView);return context&&context.name?context:undefined;} /** @hidden */function getTypeInfo(el){ // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
	var isSvg=Object.prototype.toString.call(el.prop('href'))==='[object SVGAnimatedString]';var isForm=el[0].nodeName==="FORM";return {attr:isForm?"action":isSvg?'xlink:href':'href',isAnchor:el.prop("tagName").toUpperCase()==="A",clickable:!isForm};} /** @hidden */function clickHook(el,$state,$timeout,type,current){return function(e){var button=e.which||e.button,target=current();if(!(button>1||e.ctrlKey||e.metaKey||e.shiftKey||el.attr('target'))){ // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
	var transition=$timeout(function(){$state.go(target.state,target.params,target.options);});e.preventDefault(); // if the state has no URL, ignore one preventDefault from the <a> directive.
	var ignorePreventDefaultCount=type.isAnchor&&!target.href?1:0;e.preventDefault=function(){if(ignorePreventDefaultCount--<=0)$timeout.cancel(transition);};}};} /** @hidden */function defaultOpts(el,$state){return {relative:stateContext(el)||$state.$current,inherit:true};} /**
		 * `ui-sref`: A directive for linking to a state
		 *
		 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
		 * URL, the directive will automatically generate & update the `href` attribute via
		 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
		 * the link will trigger a state transition with optional parameters.
		 *
		 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
		 * handled natively by the browser.
		 *
		 * You can also use relative state paths within ui-sref, just like the relative
		 * paths passed to `$state.go()`. You just need to be aware that the path is relative
		 * to the state that the link lives in, in other words the state that loaded the
		 * template containing the link.
		 *
		 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
		 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
		 * and `reload`.
		 *
		 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
		 * following template:
		 *
		 * @example
		 * ```html
		 *
		 * <pre>
		 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
		 *
		 * <ul>
		 *     <li ng-repeat="contact in contacts">
		 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
		 *     </li>
		 * </ul>
		 * </pre>
		 * ```
		 *
		 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
		 *
		 * ```html
		 *
		 * <pre>
		 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
		 *
		 * <ul>
		 *     <li ng-repeat="contact in contacts">
		 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
		 *     </li>
		 *     <li ng-repeat="contact in contacts">
		 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
		 *     </li>
		 *     <li ng-repeat="contact in contacts">
		 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
		 *     </li>
		 * </ul>
		 *
		 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
		 * </pre>
		 * ```
		 *
		 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
		 * @param {Object} ui-sref-opts options to pass to [[StateService.go]]
		 */var uiSrefNg1=['$state','$timeout',function $StateRefDirective($state,$timeout){return {restrict:'A',require:['?^uiSrefActive','?^uiSrefActiveEq'],link:function link(scope,element,attrs,uiSrefActive){var ref=parseStateRef(attrs.uiSref,$state.current.name);var def={state:ref.state,href:null,params:null,options:null};var type=getTypeInfo(element);var active=uiSrefActive[1]||uiSrefActive[0];var unlinkInfoFn=null;def.options=common_1.extend(defaultOpts(element,$state),attrs.uiSrefOpts?scope.$eval(attrs.uiSrefOpts):{});var update=function update(val){if(val)def.params=angular.copy(val);def.href=$state.href(ref.state,def.params,def.options);if(unlinkInfoFn)unlinkInfoFn();if(active)unlinkInfoFn=active.$$addStateInfo(ref.state,def.params);if(def.href!==null)attrs.$set(type.attr,def.href);};if(ref.paramExpr){scope.$watch(ref.paramExpr,function(val){if(val!==def.params)update(val);},true);def.params=angular.copy(scope.$eval(ref.paramExpr));}update();if(!type.clickable)return;element.bind("click",clickHook(element,$state,$timeout,type,function(){return def;}));}};}]; /**
		 * `ui-state`: A dynamic version of `ui-sref`
		 *
		 * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
		 * params and override options.
		 *
		 * @example
		 * ```html
		 *
		 * <li ng-repeat="nav in navlinks">
		 *   <a ui-state="nav.statename">{{nav.description}}</a>
		 * </li>
		 *
		 * @param {string} ui-state 'stateName' can be any valid absolute or relative state
		 * @param {Object} ui-state-params params to pass to [[StateService.href]]
		 * @param {Object} ui-state-opts options to pass to [[StateService.go]]
		 */var uiStateNg1=['$state','$timeout',function $StateRefDynamicDirective($state,$timeout){return {restrict:'A',require:['?^uiSrefActive','?^uiSrefActiveEq'],link:function link(scope,element,attrs,uiSrefActive){var type=getTypeInfo(element);var active=uiSrefActive[1]||uiSrefActive[0];var group=[attrs.uiState,attrs.uiStateParams||null,attrs.uiStateOpts||null];var watch='['+group.map(function(val){return val||'null';}).join(', ')+']';var def={state:null,params:null,options:null,href:null};var unlinkInfoFn=null;function runStateRefLink(group){def.state=group[0];def.params=group[1];def.options=group[2];def.href=$state.href(def.state,def.params,def.options);if(unlinkInfoFn)unlinkInfoFn();if(active)unlinkInfoFn=active.$$addStateInfo(def.state,def.params);if(def.href)attrs.$set(type.attr,def.href);}scope.$watch(watch,runStateRefLink,true);runStateRefLink(scope.$eval(watch));if(!type.clickable)return;element.bind("click",clickHook(element,$state,$timeout,type,function(){return def;}));}};}]; /**
		 * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active
		 *
		 * A directive working alongside ui-sref to add classes to an element when the
		 * related ui-sref directive's state is active, and removing them when it is inactive.
		 * The primary use-case is to simplify the special appearance of navigation menus
		 * relying on `ui-sref`, by having the "active" state's menu button appear different,
		 * distinguishing it from the inactive menu items.
		 *
		 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
		 * ui-sref-active found at the same level or above the ui-sref will be used.
		 *
		 * Will activate when the ui-sref's target state or any child state is active. If you
		 * need to activate only when the ui-sref target state is active and *not* any of
		 * it's children, then you will use ui-sref-active-eq
		 *
		 * Given the following template:
		 * @example
		 * ```html
		 *
		 * <pre>
		 * <ul>
		 *   <li ui-sref-active="active" class="item">
		 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
		 *   </li>
		 * </ul>
		 * </pre>
		 * ```
		 *
		 *
		 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
		 * the resulting HTML will appear as (note the 'active' class):
		 *
		 * ```html
		 *
		 * <pre>
		 * <ul>
		 *   <li ui-sref-active="active" class="item active">
		 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
		 *   </li>
		 * </ul>
		 * </pre>
		 * ```
		 *
		 * The class name is interpolated **once** during the directives link time (any further changes to the
		 * interpolated value are ignored).
		 *
		 * Multiple classes may be specified in a space-separated format:
		 *
		 * ```html
		 * <pre>
		 * <ul>
		 *   <li ui-sref-active='class1 class2 class3'>
		 *     <a ui-sref="app.user">link</a>
		 *   </li>
		 * </ul>
		 * </pre>
		 * ```
		 *
		 * It is also possible to pass ui-sref-active an expression that evaluates
		 * to an object hash, whose keys represent active class names and whose
		 * values represent the respective state names/globs.
		 * ui-sref-active will match if the current active state **includes** any of
		 * the specified state names/globs, even the abstract ones.
		 *
		 * Given the following template, with "admin" being an abstract state:
		 * @example
		 * ```html
		 *
		 * <pre>
		 * <div ui-sref-active="{'active': 'admin.*'}">
		 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
		 * </div>
		 * </pre>
		 * ```
		 *
		 * When the current state is "admin.roles" the "active" class will be applied
		 * to both the <div> and <a> elements. It is important to note that the state
		 * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
		 */var uiSrefActiveNg1=['$state','$stateParams','$interpolate','$transitions',function $StateRefActiveDirective($state,$stateParams,$interpolate,$transitions){return {restrict:"A",controller:['$scope','$element','$attrs','$timeout',function($scope,$element,$attrs,$timeout){var states=[],activeClasses={},activeEqClass,uiSrefActive; // There probably isn't much point in $observing this
	// uiSrefActive and uiSrefActiveEq share the same directive object with some
	// slight difference in logic routing
	activeEqClass=$interpolate($attrs.uiSrefActiveEq||'',false)($scope);try{uiSrefActive=$scope.$eval($attrs.uiSrefActive);}catch(e){}uiSrefActive=uiSrefActive||$interpolate($attrs.uiSrefActive||'',false)($scope);if(predicates_1.isObject(uiSrefActive)){common_1.forEach(uiSrefActive,function(stateOrName,activeClass){if(predicates_1.isString(stateOrName)){var ref=parseStateRef(stateOrName,$state.current.name);addState(ref.state,$scope.$eval(ref.paramExpr),activeClass);}});} // Allow uiSref to communicate with uiSrefActive[Equals]
	this.$$addStateInfo=function(newState,newParams){ // we already got an explicit state provided by ui-sref-active, so we
	// shadow the one that comes from ui-sref
	if(predicates_1.isObject(uiSrefActive)&&states.length>0){return;}var deregister=addState(newState,newParams,uiSrefActive);update();return deregister;};$scope.$on('$stateChangeSuccess',update);var updateAfterTransition=['$transition$',function($transition$){$transition$.promise.then(update);}];var deregisterFn=$transitions.onStart({},updateAfterTransition);$scope.$on('$destroy',deregisterFn);function addState(stateName,stateParams,activeClass){var state=$state.get(stateName,stateContext($element));var stateHash=createStateHash(stateName,stateParams);var stateInfo={state:state||{name:stateName},params:stateParams,hash:stateHash};states.push(stateInfo);activeClasses[stateHash]=activeClass;return function removeState(){var idx=states.indexOf(stateInfo);if(idx!==-1)states.splice(idx,1);};} /**
		                     * @param {string} state
		                     * @param {Object|string} [params]
		                     * @return {string}
		                     */function createStateHash(state,params){if(!predicates_1.isString(state)){throw new Error('state should be a string');}if(predicates_1.isObject(params)){return state+common_1.toJson(params);}params=$scope.$eval(params);if(predicates_1.isObject(params)){return state+common_1.toJson(params);}return state;} // Update route state
	function update(){for(var i=0;i<states.length;i++){if(anyMatch(states[i].state,states[i].params)){addClass($element,activeClasses[states[i].hash]);}else {removeClass($element,activeClasses[states[i].hash]);}if(exactMatch(states[i].state,states[i].params)){addClass($element,activeEqClass);}else {removeClass($element,activeEqClass);}}}function addClass(el,className){$timeout(function(){el.addClass(className);});}function removeClass(el,className){el.removeClass(className);}function anyMatch(state,params){return $state.includes(state.name,params);}function exactMatch(state,params){return $state.is(state.name,params);}update();}]};}];angular.module('ui.router.state').directive('uiSref',uiSrefNg1).directive('uiSrefActive',uiSrefActiveNg1).directive('uiSrefActiveEq',uiSrefActiveNg1).directive('uiState',uiStateNg1); /***/}, /* 57 */ /***/function(module,exports){ /** @module state */ /** for typedoc */"use strict"; /**
		 * @ngdoc filter
		 * @name ui.router.state.filter:isState
		 *
		 * @requires ui.router.state.$state
		 *
		 * @description
		 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
		 */$IsStateFilter.$inject=['$state'];function $IsStateFilter($state){var isFilter=function isFilter(state,params,options){return $state.is(state,params,options);};isFilter.$stateful=true;return isFilter;}exports.$IsStateFilter=$IsStateFilter; /**
		 * @ngdoc filter
		 * @name ui.router.state.filter:includedByState
		 *
		 * @requires ui.router.state.$state
		 *
		 * @description
		 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
		 */$IncludedByStateFilter.$inject=['$state'];function $IncludedByStateFilter($state){var includesFilter=function includesFilter(state,params,options){return $state.includes(state,params,options);};includesFilter.$stateful=true;return includesFilter;}exports.$IncludedByStateFilter=$IncludedByStateFilter;angular.module('ui.router.state').filter('isState',$IsStateFilter).filter('includedByState',$IncludedByStateFilter); /***/}, /* 58 */ /***/function(module,exports,__webpack_require__){ /** @module ng1_directives */ /** for typedoc */"use strict";var common_1=__webpack_require__(3);var predicates_1=__webpack_require__(4);var trace_1=__webpack_require__(12);var rejectFactory_1=__webpack_require__(10);var hof_1=__webpack_require__(5);var strings_1=__webpack_require__(9); /**
		 * `ui-view`: A viewport directive which is filled in by a view from the active state.
		 *
		 * @param {string=} name A view name. The name should be unique amongst the other views in the
		 * same state. You can have views of the same name that live in different states.
		 *
		 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
		 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
		 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
		 * scroll ui-view elements into view when they are populated during a state activation.
		 *
		 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
		 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
		 *
		 * @param {string=} onload Expression to evaluate whenever the view updates.
		 *
		 * A view can be unnamed or named.
		 * @example
		 * ```html
		 *
		 * <!-- Unnamed -->
		 * <div ui-view></div>
		 *
		 * <!-- Named -->
		 * <div ui-view="viewName"></div>
		 * ```
		 *
		 * You can only have one unnamed view within any template (or root html). If you are only using a
		 * single view and it is unnamed then you can populate it like so:
		 * ```
		 *
		 * <div ui-view></div>
		 * $stateProvider.state("home", {
		 *   template: "<h1>HELLO!</h1>"
		 * })
		 * ```
		 *
		 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
		 * config property, by name, in this case an empty name:
		 * ```js
		 *
		 * $stateProvider.state("home", {
		 *   views: {
		 *     "": {
		 *       template: "<h1>HELLO!</h1>"
		 *     }
		 *   }
		 * })
		 * ```
		 *
		 * But typically you'll only use the views property if you name your view or have more than one view
		 * in the same template. There's not really a compelling reason to name a view if its the only one,
		 * but you could if you wanted, like so:
		 *
		 * ```html
		 *
		 * <div ui-view="main"></div>
		 * ```
		 *
		 * ```js
		 *
		 * $stateProvider.state("home", {
		 *   views: {
		 *     "main": {
		 *       template: "<h1>HELLO!</h1>"
		 *     }
		 *   }
		 * })
		 * ```
		 *
		 * Really though, you'll use views to set up multiple views:
		 * ```html
		 *
		 * <div ui-view></div>
		 * <div ui-view="chart"></div>
		 * <div ui-view="data"></div>
		 * ```
		 *
		 * ```js
		 * $stateProvider.state("home", {
		 *   views: {
		 *     "": {
		 *       template: "<h1>HELLO!</h1>"
		 *     },
		 *     "chart": {
		 *       template: "<chart_thing/>"
		 *     },
		 *     "data": {
		 *       template: "<data_thing/>"
		 *     }
		 *   }
		 * })
		 * ```
		 *
		 * Examples for `autoscroll`:
		 *
		 * ```html
		 *
		 * <!-- If autoscroll present with no expression,
		 *      then scroll ui-view into view -->
		 * <ui-view autoscroll/>
		 *
		 * <!-- If autoscroll present with valid expression,
		 *      then scroll ui-view into view if expression evaluates to true -->
		 * <ui-view autoscroll='true'/>
		 * <ui-view autoscroll='false'/>
		 * <ui-view autoscroll='scopeVariable'/>
		 * ```
		 *
		 * Resolve data:
		 *
		 * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
		 * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
		 *
		 * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
		 * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
		 * depends on `$resolve` data.
		 *
		 * @example
		 * ```js
		 *
		 * $stateProvider.state('home', {
		 *   template: '<my-component user="$resolve.user"></my-component>',
		 *   resolve: {
		 *     user: function(UserService) { return UserService.fetchUser(); }
		 *   }
		 * });
		 * ```
		 */var uiViewNg1=['$view','$animate','$uiViewScroll','$interpolate','$q',function $ViewDirective($view,$animate,$uiViewScroll,$interpolate,$q){function getRenderer(attrs,scope){return {enter:function enter(element,target,cb){if(angular.version.minor>2){$animate.enter(element,null,target).then(cb);}else {$animate.enter(element,null,target,cb);}},leave:function leave(element,cb){if(angular.version.minor>2){$animate.leave(element).then(cb);}else {$animate.leave(element,cb);}}};}function configsEqual(config1,config2){return config1===config2;}var rootData={$cfg:{viewDecl:{$context:$view.rootContext()}},$uiView:{}};var directive={count:0,restrict:'ECA',terminal:true,priority:400,transclude:'element',compile:function compile(tElement,tAttrs,$transclude){return function(scope,$element,attrs){var previousEl,currentEl,currentScope,unregister,onloadExp=attrs.onload||'',autoScrollExp=attrs.autoscroll,renderer=getRenderer(attrs,scope),viewConfig=undefined,inherited=$element.inheritedData('$uiView')||rootData,name=$interpolate(attrs.uiView||attrs.name||'')(scope)||'$default';var activeUIView={id:directive.count++,name:name,fqn:inherited.$uiView.fqn?inherited.$uiView.fqn+"."+name:name,config:null,configUpdated:configUpdatedCallback,get creationContext(){return hof_1.parse('$cfg.viewDecl.$context')(inherited);}};trace_1.trace.traceUiViewEvent("Linking",activeUIView);function configUpdatedCallback(config){if(configsEqual(viewConfig,config))return;trace_1.trace.traceUiViewConfigUpdated(activeUIView,config&&config.viewDecl&&config.viewDecl.$context);viewConfig=config;updateView(config);}$element.data('$uiView',{$uiView:activeUIView});updateView();unregister=$view.registerUiView(activeUIView);scope.$on("$destroy",function(){trace_1.trace.traceUiViewEvent("Destroying/Unregistering",activeUIView);unregister();});function cleanupLastView(){if(previousEl){trace_1.trace.traceUiViewEvent("Removing (previous) el",previousEl.data('$uiView'));previousEl.remove();previousEl=null;}if(currentScope){trace_1.trace.traceUiViewEvent("Destroying scope",activeUIView);currentScope.$destroy();currentScope=null;}if(currentEl){var _viewData_1=currentEl.data('$uiView');trace_1.trace.traceUiViewEvent("Animate out",_viewData_1);renderer.leave(currentEl,function(){_viewData_1.$$animLeave.resolve();previousEl=null;});previousEl=currentEl;currentEl=null;}}function updateView(config){var newScope=scope.$new();trace_1.trace.traceUiViewScopeCreated(activeUIView,newScope);var animEnter=$q.defer(),animLeave=$q.defer();var $uiViewData={$cfg:config,$uiView:activeUIView,$animEnter:animEnter.promise,$animLeave:animLeave.promise,$$animLeave:animLeave};var cloned=$transclude(newScope,function(clone){renderer.enter(clone.data('$uiView',$uiViewData),$element,function onUiViewEnter(){animEnter.resolve();if(currentScope)currentScope.$emit('$viewContentAnimationEnded');if(predicates_1.isDefined(autoScrollExp)&&!autoScrollExp||scope.$eval(autoScrollExp)){$uiViewScroll(clone);}});cleanupLastView();});currentEl=cloned;currentScope=newScope; /**
		                         * @ngdoc event
		                         * @name ui.router.state.directive:ui-view#$viewContentLoaded
		                         * @eventOf ui.router.state.directive:ui-view
		                         * @eventType emits on ui-view directive scope
		                         * @description           *
		                         * Fired once the view is **loaded**, *after* the DOM is rendered.
		                         *
		                         * @param {Object} event Event object.
		                         */currentScope.$emit('$viewContentLoaded',config||viewConfig);currentScope.$eval(onloadExp);}};}};return directive;}];$ViewDirectiveFill.$inject=['$compile','$controller','$transitions','$view','$timeout']; /** @hidden */function $ViewDirectiveFill($compile,$controller,$transitions,$view,$timeout){var getControllerAs=hof_1.parse('viewDecl.controllerAs');var getResolveAs=hof_1.parse('viewDecl.resolveAs');var getResolveContext=hof_1.parse('node.resolveContext');return {restrict:'ECA',priority:-400,compile:function compile(tElement){var initial=tElement.html();return function(scope,$element){var data=$element.data('$uiView');if(!data)return;var cfg=data.$cfg||{viewDecl:{}};$element.html(cfg.template||initial);trace_1.trace.traceUiViewFill(data.$uiView,$element.html());var link=$compile($element.contents());var controller=cfg.controller;var controllerAs=getControllerAs(cfg);var resolveAs=getResolveAs(cfg);var resolveCtx=getResolveContext(cfg);var locals=resolveCtx&&common_1.map(resolveCtx.getResolvables(),function(r){return r.data;});scope[resolveAs]=locals;if(controller){var controllerInstance=$controller(controller,common_1.extend({},locals,{$scope:scope,$element:$element}));if(controllerAs){scope[controllerAs]=controllerInstance;scope[controllerAs][resolveAs]=locals;} // TODO: Use $view service as a central point for registering component-level hooks
	// Then, when a component is created, tell the $view service, so it can invoke hooks
	// $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
	// scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
	$element.data('$ngControllerController',controllerInstance);$element.children().data('$ngControllerController',controllerInstance);registerControllerCallbacks($transitions,controllerInstance,scope,cfg);} // Wait for the component to appear in the DOM
	if(cfg.viewDecl.component){var cmp_1=cfg.viewDecl.component;var kebobName_1=strings_1.kebobString(cmp_1);var getComponentController=function getComponentController(){var directiveEl=[].slice.call($element[0].children).filter(function(el){return el&&el.tagName&&el.tagName.toLowerCase()===kebobName_1;});return directiveEl&&angular.element(directiveEl).data("$"+cmp_1+"Controller");};var deregisterWatch_1=scope.$watch(getComponentController,function(ctrlInstance){if(!ctrlInstance)return;registerControllerCallbacks($transitions,ctrlInstance,scope,cfg);deregisterWatch_1();});}link(scope);};}};} /** @hidden */var hasComponentImpl=typeof angular.module('ui.router')['component']==='function'; /** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */function registerControllerCallbacks($transitions,controllerInstance,$scope,cfg){ // Call $onInit() ASAP
	if(predicates_1.isFunction(controllerInstance.$onInit)&&!(cfg.viewDecl.component&&hasComponentImpl))controllerInstance.$onInit();var hookOptions={bind:controllerInstance}; // Add component-level hook for onParamsChange
	if(predicates_1.isFunction(controllerInstance.uiOnParamsChanged)){ // Fire callback on any successful transition
	var paramsUpdated_1=function paramsUpdated_1($transition$){var ctx=cfg.node.resolveContext;var viewCreationTrans=ctx.getResolvables()['$transition$'].data; // Exit early if the $transition$ is the same as the view was created within.
	// Exit early if the $transition$ will exit the state the view is for.
	if($transition$===viewCreationTrans||$transition$.exiting().indexOf(cfg.node.state.self)!==-1)return;var toParams=$transition$.params("to");var fromParams=$transition$.params("from");var toSchema=$transition$.treeChanges().to.map(function(node){return node.paramSchema;}).reduce(common_1.unnestR,[]);var fromSchema=$transition$.treeChanges().from.map(function(node){return node.paramSchema;}).reduce(common_1.unnestR,[]); // Find the to params that have different values than the from params
	var changedToParams=toSchema.filter(function(param){var idx=fromSchema.indexOf(param);return idx===-1||!fromSchema[idx].type.equals(toParams[param.id],fromParams[param.id]);}); // Only trigger callback if a to param has changed or is new
	if(changedToParams.length){var changedKeys_1=changedToParams.map(function(x){return x.id;}); // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
	controllerInstance.uiOnParamsChanged(common_1.filter(toParams,function(val,key){return changedKeys_1.indexOf(key)!==-1;}),$transition$);}};$scope.$on('$destroy',$transitions.onSuccess({},['$transition$',paramsUpdated_1]),hookOptions); // Fire callback on any IGNORED transition
	var onDynamic=function onDynamic($error$,$transition$){if($error$.type===rejectFactory_1.RejectType.IGNORED)paramsUpdated_1($transition$);};$scope.$on('$destroy',$transitions.onError({},['$error$','$transition$',onDynamic]),hookOptions);} // Add component-level hook for uiCanExit
	if(predicates_1.isFunction(controllerInstance.uiCanExit)){var criteria={exiting:cfg.node.state.name};$scope.$on('$destroy',$transitions.onBefore(criteria,controllerInstance.uiCanExit,hookOptions));}}angular.module('ui.router.state').directive('uiView',uiViewNg1);angular.module('ui.router.state').directive('uiView',$ViewDirectiveFill); /***/}, /* 59 */ /***/function(module,exports){"use strict"; /**
		 * @ngdoc object
		 * @name ui.router.state.$uiViewScrollProvider
		 *
		 * @description
		 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
		 */function $ViewScrollProvider(){var useAnchorScroll=false; /**
		     * @ngdoc function
		     * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
		     * @methodOf ui.router.state.$uiViewScrollProvider
		     *
		     * @description
		     * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
		     * scrolling based on the url anchor.
		     */this.useAnchorScroll=function(){useAnchorScroll=true;}; /**
		     * @ngdoc object
		     * @name ui.router.state.$uiViewScroll
		     *
		     * @requires $anchorScroll
		     * @requires $timeout
		     *
		     * @description
		     * When called with a jqLite element, it scrolls the element into view (after a
		     * `$timeout` so the DOM has time to refresh).
		     *
		     * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
		     * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
		     */this.$get=['$anchorScroll','$timeout',function($anchorScroll,$timeout){if(useAnchorScroll){return $anchorScroll;}return function($element){return $timeout(function(){$element[0].scrollIntoView();},0,false);};}];}angular.module('ui.router.state').provider('$uiViewScroll',$ViewScrollProvider); /***/} /******/]));});; //# sourceMappingURL=angular-ui-router.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)(module)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	// var angular = require('angular');
	// require('angular-ui-router');

	var gVersion = "0.0.1R6";

	function redirectNonSSL(url) {
	    if (typeof url !== 'undefined' && url.trim().indexOf('localhost') == -1 && url.trim().startsWith('http://')) {
	        if (window.location.protocol != "https:") window.location.href = "https:" + window.location.href.substring(window.location.protocol.length);
	    }
	}
	function handleSSL(url) {
	    if (typeof url !== 'undefined' && url.trim().indexOf('localhost') == -1 && url.trim().startsWith('http://')) {
	        var ret = url.trim().replace('http://', 'https://');
	        console.log('url changed to SSL-based -> [' + ret + ']');
	        return ret;
	    } else {
	        return url;
	    }
	}

	redirectNonSSL(window.location.origin);
	console.log('redirectNonSSL invoked');

	//console.log("app.js 2 $state:");
	//console.log($state);

	//=== JWT and navigations stuff
	angular.module('myApp', ['ui.router']).config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {
	    $urlRouterProvider.otherwise('/home');

	    $stateProvider.state('home', {
	        url: '/home',
	        templateUrl: '../react/fusrstart.html',
	        controller: ["$scope", "$stateParams", "$state", function controller($scope, $stateParams, $state) {
	            window.$state = $state; //TODO how do we avoid global here???!!!
	            if (typeof SRStart !== 'undefined') {
	                ReactDOM.render(React.createElement(SRStart, { $state: $state }), document.getElementById('sr-start'));
	            }
	        }]
	    }).state('update', {
	        url: '/update/{id:int}',
	        templateUrl: '../react/fusrupdate.html',
	        controller: ["$scope", "$stateParams", "$state", function controller($scope, $stateParams, $state) {
	            //$scope.inboxId = $stateParams.inboxId;
	            //console.log('app.js $stateProvider update: ', $stateParams);
	            var id = $stateParams.id; //$stateParams.obj.id;
	            //console.log('app.js id = [' + id + ']');
	            ReactDOM.render(React.createElement(SRUpdate, { $state: $state, id: id }), document.getElementById('sr-update'));
	        }],
	        params: {
	            obj: null
	        }
	    }).state('create', {
	        url: '/create',
	        templateUrl: '../react/fusrcreate.html',
	        controller: ["$scope", "$stateParams", "$state", function controller($scope, $stateParams, $state) {
	            //$scope.inboxId = $stateParams.inboxId;
	            ReactDOM.render(React.createElement(SRCreate, { $state: $state }), document.getElementById('sr-create'));
	        }]
	    });
	}]).controller('MainCtrl', ['mainService', '$scope', '$http', '$state', function (mainService, $scope, $http, $compile, $state) {
	    $scope.version = gVersion;
	    $scope.status = 'Please sign in';
	    $scope.greeting = 'Welcome!';
	    $scope.token = null;
	    $scope.error = null;
	    $scope.roleUser = false;
	    $scope.roleAdmin = false;
	    $scope.roleFoo = false;

	    $scope.login = function () {
	        $scope.status = "Logging in ...";
	        $scope.error = null;
	        mainService.login($scope.userName, $scope.passWord).then(function (token) {
	            $scope.token = token;
	            $http.defaults.headers.common.Authorization = 'Bearer ' + token;
	            $scope.checkRoles();
	        }, function (error) {
	            $scope.status = "Invalid login. Please try again.";
	            $scope.error = error;
	            $scope.userName = '';
	            $scope.passWord = '';
	        });
	    };

	    $scope.checkRoles = function () {
	        mainService.hasRole('user').then(function (user) {
	            $scope.roleUser = user;
	        });
	        mainService.hasRole('admin').then(function (admin) {
	            $scope.roleAdmin = admin;
	        });
	        mainService.hasRole('foo').then(function (foo) {
	            $scope.roleFoo = foo;
	        });
	    };

	    $scope.logout = function () {
	        $scope.userName = '';
	        $scope.token = null;
	        $http.defaults.headers.common.Authorization = '';
	        location.href = "index.html";
	        // Clear the JWT token.
	        localStorage.removeItem('userJWTToken');
	    };

	    $scope.loggedIn = function () {
	        var token = $scope.token;
	        if (token !== null) {
	            // Save the JWT token.
	            localStorage.setItem('userJWTToken', token);
	            location.href = "app.html";
	        }
	        return token !== null;
	    };

	    $scope.enter = function () {
	        location.href = 'app.html';
	    };
	}]).service('mainService', ['$http', function ($http) {
	    return {
	        login: function login(username, pwd) {
	            return $http.post('/api/user/login', { name: username, password: pwd }).then(function (response) {
	                return response.data.token;
	            });
	        },

	        hasRole: function hasRole(role) {
	            return $http.get('/api/jwt/role/' + role).then(function (response) {
	                console.log(response);
	                return response.data;
	            });
	        }
	    };
	}]);

	// Common directive for Focus
	angular.module('myApp').directive('focus', ['$timeout', function ($timeout) {
	    return {
	        scope: {
	            trigger: '@focus'
	        },
	        link: function link(scope, element) {
	            scope.$watch('trigger', function (value) {
	                if (value === "true") {
	                    $timeout(function () {
	                        element[0].focus();
	                    });
	                }
	            });
	        }
	    };
	}]);

	window.onerror = function (msg, url, line, col, error) {
	    // Note that col & error are new to the HTML 5 spec and may not be
	    // supported in every browser.  It worked for me in Chrome.
	    var extra = !col ? '' : '\ncolumn: ' + col;
	    extra += !error ? '' : '\nerror: ' + error;

	    // You can view the information in an alert to see things working like this:
	    // alert("n/ng/app.js onerror: " + msg + "\nurl: " + url + "\nline: " + line + extra);
	    console.error("n/ng/app.js onerror: " + msg + "\nurl: " + url + "\nline: " + line + extra);

	    // TODO: Report this error via ajax so you can keep track
	    //       of what pages have JS issues

	    var suppressErrorAlert = true;
	    // If you return true, then error alerts (like in older versions of
	    // Internet Explorer) will be suppressed.
	    return suppressErrorAlert;
	};

	// angular.bootstrap(document, ['myApp']);

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDVhZjc0ZGEzNWU3MTk3YmFiZDQiLCJ3ZWJwYWNrOi8vLy4vZW50cnkuanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL2Jvd2VyX2NvbXBvbmVudHMvbWlsbGlncmFtL2Rpc3QvbWlsbGlncmFtLmNzcz8xN2NjIiwid2VicGFjazovLy8uLi9qcy9ib3dlcl9jb21wb25lbnRzL21pbGxpZ3JhbS9kaXN0L21pbGxpZ3JhbS5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL2pzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItdWktcm91dGVyL3JlbGVhc2UvYW5ndWxhci11aS1yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbmcvYXBwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUN0Q0EscUJBQVE7QUFDUixLQUFJLFVBQVUsb0JBQVE7QUFDdEIscUJBQVE7QUFDUixxQkFBUTtBQUNSLFNBQVEsSUFBSSx5Qjs7Ozs7O0FDSlo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVSxFQUFF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TUFBTSxLQUFLLG1CQUFtQixFQUFDLE1BQU0sVUFBVSxVQUFVLE9BQU0sZUFBYzt3QkFDekUsU0FBUyxLQUl4QixNQUpRO2NBRHVFLEVBQTNFO1VBREk7O21DQU1XO29CQUNSLE1BQU0sSUFBSSxtQkFBbUIsTUFBTSxlQUFjO3lCQUM1QyxJQUNSO3dCQUFPLFNBQVMsS0FEaEI7Y0FEMkMsRUFBL0M7VUFETTtPQVBkO0VBRDhCOzs7QUFrQnRDLFNBQVEsT0FBTyxTQUFTLFVBQVUsU0FBUyxDQUFDLHNCQUM5QjtZQUVGO2dCQUNJO3NCQUVKOzs2QkFBZ0IsT0FBTzttQkFDYixPQUFPLHFCQUFxQixPQUM5QjtxQkFBSSxVQUFVOzBDQUVOO2lDQUFRLEdBQUc7c0JBRE4sRUFBVDs7Y0FGZ0IsRUFBeEI7VUFERTtPQUpWO0VBREo7O0FBa0JKLFFBQU8sb0JBQW1CLEtBQUssS0FBSyxNQUFNLEtBQUs7OztTQUd2QyxRQUFRLENBQUMsTUFBTSxLQUFLLGVBQ3hCO2NBQVMsQ0FBQyxRQUFRLEtBQUssY0FBYzs7OztBQURyQyxZQUtBLENBQVEsTUFBTSwwQkFBMEIsTUFBTSxZQUFZLE1BQU0sYUFBYSxPQUFPOzs7OztTQUtoRixxQkFBcUI7OztZQUdsQjtFQWhCTSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDQ1YWY3NGRhMzVlNzE5N2JhYmQ0XG4gKiovIiwicmVxdWlyZShcIi4uL2pzL2Jvd2VyX2NvbXBvbmVudHMvbWlsbGlncmFtL2Rpc3QvbWlsbGlncmFtLmNzc1wiKTtcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xucmVxdWlyZSgnYW5ndWxhci11aS1yb3V0ZXInKTtcbnJlcXVpcmUoJy4uL25nL2FwcC5qcycpO1xuY29uc29sZS5sb2coJ2VudHJ5LmpzOiBhcHAgYm9vdGVkIScpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbnRyeS5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL3JlYWN0L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbWlsbGlncmFtLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9yZWFjdC9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vcmVhY3Qvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9taWxsaWdyYW0uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL3JlYWN0L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbWlsbGlncmFtLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9qcy9ib3dlcl9jb21wb25lbnRzL21pbGxpZ3JhbS9kaXN0L21pbGxpZ3JhbS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9yZWFjdC9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIE1pbGxpZ3JhbSB2MS4xLjBcXG4gKiBodHRwOi8vbWlsbGlncmFtLmdpdGh1Yi5pb1xcbiAqXFxuICogQ29weXJpZ2h0IChjKSAyMDE2IENKIFBhdG9pbG9cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4qL1xcblxcblxcbmh0bWwge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZvbnQtc2l6ZTogNjIuNSU7XFxufVxcblxcbmJvZHkge1xcbiAgY29sb3I6ICM2MDZjNzY7XFxuICBmb250LWZhbWlseTogXFxcIlJvYm90b1xcXCIsIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIFxcXCJIZWx2ZXRpY2FcXFwiLCBcXFwiQXJpYWxcXFwiLCBzYW5zLXNlcmlmO1xcbiAgZm9udC1zaXplOiAxLjZlbTtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICBsZXR0ZXItc3BhY2luZzogMC4wMWVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNjtcXG59XFxuXFxuKixcXG4qOmFmdGVyLFxcbio6YmVmb3JlIHtcXG4gIGJveC1zaXppbmc6IGluaGVyaXQ7XFxufVxcblxcbmJsb2NrcXVvdGUge1xcbiAgYm9yZGVyLWxlZnQ6IDAuM3JlbSBzb2xpZCAjZDFkMWQxO1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBwYWRkaW5nOiAxcmVtIDEuNXJlbTtcXG59XFxuYmxvY2txdW90ZSAqOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4uYnV0dG9uLFxcbmJ1dHRvbixcXG5pbnB1dFt0eXBlPSdidXR0b24nXSxcXG5pbnB1dFt0eXBlPSdyZXNldCddLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5YjRkY2E7XFxuICBib3JkZXI6IDAuMXJlbSBzb2xpZCAjOWI0ZGNhO1xcbiAgYm9yZGVyLXJhZGl1czogMC40cmVtO1xcbiAgY29sb3I6ICNmZmY7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LXNpemU6IDEuMXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICBoZWlnaHQ6IDMuOHJlbTtcXG4gIGxldHRlci1zcGFjaW5nOiAwLjFyZW07XFxuICBsaW5lLWhlaWdodDogMy44cmVtO1xcbiAgcGFkZGluZzogMCAzcmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxufVxcbi5idXR0b246aG92ZXIsIC5idXR0b246Zm9jdXMsXFxuYnV0dG9uOmhvdmVyLFxcbmJ1dHRvbjpmb2N1cyxcXG5pbnB1dFt0eXBlPSdidXR0b24nXTpob3ZlcixcXG5pbnB1dFt0eXBlPSdidXR0b24nXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSdyZXNldCddOmhvdmVyLFxcbmlucHV0W3R5cGU9J3Jlc2V0J106Zm9jdXMsXFxuaW5wdXRbdHlwZT0nc3VibWl0J106aG92ZXIsXFxuaW5wdXRbdHlwZT0nc3VibWl0J106Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzYwNmM3NjtcXG4gIGJvcmRlci1jb2xvcjogIzYwNmM3NjtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgb3V0bGluZTogMDtcXG59XFxuLmJ1dHRvbi5idXR0b24tZGlzYWJsZWQsIC5idXR0b25bZGlzYWJsZWRdLFxcbmJ1dHRvbi5idXR0b24tZGlzYWJsZWQsXFxuYnV0dG9uW2Rpc2FibGVkXSxcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tZGlzYWJsZWQsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ11bZGlzYWJsZWRdLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLWRpc2FibGVkLFxcbmlucHV0W3R5cGU9J3Jlc2V0J11bZGlzYWJsZWRdLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1kaXNhYmxlZCxcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXVtkaXNhYmxlZF0ge1xcbiAgb3BhY2l0eTogMC41O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4uYnV0dG9uLmJ1dHRvbi1kaXNhYmxlZDpob3ZlciwgLmJ1dHRvbi5idXR0b24tZGlzYWJsZWQ6Zm9jdXMsIC5idXR0b25bZGlzYWJsZWRdOmhvdmVyLCAuYnV0dG9uW2Rpc2FibGVkXTpmb2N1cyxcXG5idXR0b24uYnV0dG9uLWRpc2FibGVkOmhvdmVyLFxcbmJ1dHRvbi5idXR0b24tZGlzYWJsZWQ6Zm9jdXMsXFxuYnV0dG9uW2Rpc2FibGVkXTpob3ZlcixcXG5idXR0b25bZGlzYWJsZWRdOmZvY3VzLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddLmJ1dHRvbi1kaXNhYmxlZDpob3ZlcixcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tZGlzYWJsZWQ6Zm9jdXMsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ11bZGlzYWJsZWRdOmhvdmVyLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddW2Rpc2FibGVkXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSdyZXNldCddLmJ1dHRvbi1kaXNhYmxlZDpob3ZlcixcXG5pbnB1dFt0eXBlPSdyZXNldCddLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5pbnB1dFt0eXBlPSdyZXNldCddW2Rpc2FibGVkXTpob3ZlcixcXG5pbnB1dFt0eXBlPSdyZXNldCddW2Rpc2FibGVkXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXS5idXR0b24tZGlzYWJsZWQ6aG92ZXIsXFxuaW5wdXRbdHlwZT0nc3VibWl0J10uYnV0dG9uLWRpc2FibGVkOmZvY3VzLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddW2Rpc2FibGVkXTpob3ZlcixcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXVtkaXNhYmxlZF06Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzliNGRjYTtcXG4gIGJvcmRlci1jb2xvcjogIzliNGRjYTtcXG59XFxuLmJ1dHRvbi5idXR0b24tb3V0bGluZSxcXG5idXR0b24uYnV0dG9uLW91dGxpbmUsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLW91dGxpbmUsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tb3V0bGluZSxcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXS5idXR0b24tb3V0bGluZSB7XFxuICBjb2xvcjogIzliNGRjYTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG4uYnV0dG9uLmJ1dHRvbi1vdXRsaW5lOmhvdmVyLCAuYnV0dG9uLmJ1dHRvbi1vdXRsaW5lOmZvY3VzLFxcbmJ1dHRvbi5idXR0b24tb3V0bGluZTpob3ZlcixcXG5idXR0b24uYnV0dG9uLW91dGxpbmU6Zm9jdXMsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLW91dGxpbmU6aG92ZXIsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLW91dGxpbmU6Zm9jdXMsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tb3V0bGluZTpob3ZlcixcXG5pbnB1dFt0eXBlPSdyZXNldCddLmJ1dHRvbi1vdXRsaW5lOmZvY3VzLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1vdXRsaW5lOmhvdmVyLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1vdXRsaW5lOmZvY3VzIHtcXG4gIGNvbG9yOiAjNjA2Yzc2O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItY29sb3I6ICM2MDZjNzY7XFxufVxcbi5idXR0b24uYnV0dG9uLW91dGxpbmUuYnV0dG9uLWRpc2FibGVkOmhvdmVyLCAuYnV0dG9uLmJ1dHRvbi1vdXRsaW5lLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cywgLmJ1dHRvbi5idXR0b24tb3V0bGluZVtkaXNhYmxlZF06aG92ZXIsIC5idXR0b24uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmZvY3VzLFxcbmJ1dHRvbi5idXR0b24tb3V0bGluZS5idXR0b24tZGlzYWJsZWQ6aG92ZXIsXFxuYnV0dG9uLmJ1dHRvbi1vdXRsaW5lLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5idXR0b24uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmhvdmVyLFxcbmJ1dHRvbi5idXR0b24tb3V0bGluZVtkaXNhYmxlZF06Zm9jdXMsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLW91dGxpbmUuYnV0dG9uLWRpc2FibGVkOmhvdmVyLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddLmJ1dHRvbi1vdXRsaW5lLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tb3V0bGluZVtkaXNhYmxlZF06aG92ZXIsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmZvY3VzLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLW91dGxpbmUuYnV0dG9uLWRpc2FibGVkOmhvdmVyLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLW91dGxpbmUuYnV0dG9uLWRpc2FibGVkOmZvY3VzLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmhvdmVyLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmZvY3VzLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1vdXRsaW5lLmJ1dHRvbi1kaXNhYmxlZDpob3ZlcixcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXS5idXR0b24tb3V0bGluZS5idXR0b24tZGlzYWJsZWQ6Zm9jdXMsXFxuaW5wdXRbdHlwZT0nc3VibWl0J10uYnV0dG9uLW91dGxpbmVbZGlzYWJsZWRdOmhvdmVyLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1vdXRsaW5lW2Rpc2FibGVkXTpmb2N1cyB7XFxuICBjb2xvcjogIzliNGRjYTtcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG59XFxuLmJ1dHRvbi5idXR0b24tY2xlYXIsXFxuYnV0dG9uLmJ1dHRvbi1jbGVhcixcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tY2xlYXIsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tY2xlYXIsXFxuaW5wdXRbdHlwZT0nc3VibWl0J10uYnV0dG9uLWNsZWFyIHtcXG4gIGNvbG9yOiAjOWI0ZGNhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG4uYnV0dG9uLmJ1dHRvbi1jbGVhcjpob3ZlciwgLmJ1dHRvbi5idXR0b24tY2xlYXI6Zm9jdXMsXFxuYnV0dG9uLmJ1dHRvbi1jbGVhcjpob3ZlcixcXG5idXR0b24uYnV0dG9uLWNsZWFyOmZvY3VzLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddLmJ1dHRvbi1jbGVhcjpob3ZlcixcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tY2xlYXI6Zm9jdXMsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tY2xlYXI6aG92ZXIsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tY2xlYXI6Zm9jdXMsXFxuaW5wdXRbdHlwZT0nc3VibWl0J10uYnV0dG9uLWNsZWFyOmhvdmVyLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1jbGVhcjpmb2N1cyB7XFxuICBjb2xvcjogIzYwNmM3NjtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLmJ1dHRvbi5idXR0b24tY2xlYXIuYnV0dG9uLWRpc2FibGVkOmhvdmVyLCAuYnV0dG9uLmJ1dHRvbi1jbGVhci5idXR0b24tZGlzYWJsZWQ6Zm9jdXMsIC5idXR0b24uYnV0dG9uLWNsZWFyW2Rpc2FibGVkXTpob3ZlciwgLmJ1dHRvbi5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmZvY3VzLFxcbmJ1dHRvbi5idXR0b24tY2xlYXIuYnV0dG9uLWRpc2FibGVkOmhvdmVyLFxcbmJ1dHRvbi5idXR0b24tY2xlYXIuYnV0dG9uLWRpc2FibGVkOmZvY3VzLFxcbmJ1dHRvbi5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmhvdmVyLFxcbmJ1dHRvbi5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmZvY3VzLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddLmJ1dHRvbi1jbGVhci5idXR0b24tZGlzYWJsZWQ6aG92ZXIsXFxuaW5wdXRbdHlwZT0nYnV0dG9uJ10uYnV0dG9uLWNsZWFyLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5pbnB1dFt0eXBlPSdidXR0b24nXS5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmhvdmVyLFxcbmlucHV0W3R5cGU9J2J1dHRvbiddLmJ1dHRvbi1jbGVhcltkaXNhYmxlZF06Zm9jdXMsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tY2xlYXIuYnV0dG9uLWRpc2FibGVkOmhvdmVyLFxcbmlucHV0W3R5cGU9J3Jlc2V0J10uYnV0dG9uLWNsZWFyLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5pbnB1dFt0eXBlPSdyZXNldCddLmJ1dHRvbi1jbGVhcltkaXNhYmxlZF06aG92ZXIsXFxuaW5wdXRbdHlwZT0ncmVzZXQnXS5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmZvY3VzLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1jbGVhci5idXR0b24tZGlzYWJsZWQ6aG92ZXIsXFxuaW5wdXRbdHlwZT0nc3VibWl0J10uYnV0dG9uLWNsZWFyLmJ1dHRvbi1kaXNhYmxlZDpmb2N1cyxcXG5pbnB1dFt0eXBlPSdzdWJtaXQnXS5idXR0b24tY2xlYXJbZGlzYWJsZWRdOmhvdmVyLFxcbmlucHV0W3R5cGU9J3N1Ym1pdCddLmJ1dHRvbi1jbGVhcltkaXNhYmxlZF06Zm9jdXMge1xcbiAgY29sb3I6ICM5YjRkY2E7XFxufVxcblxcbmNvZGUge1xcbiAgYmFja2dyb3VuZDogI2Y0ZjVmNjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNHJlbTtcXG4gIGZvbnQtc2l6ZTogODYlO1xcbiAgcGFkZGluZzogMC4ycmVtIDAuNXJlbTtcXG4gIG1hcmdpbjogMCAwLjJyZW07XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG5wcmUge1xcbiAgYmFja2dyb3VuZDogI2Y0ZjVmNjtcXG4gIGJvcmRlci1sZWZ0OiAwLjNyZW0gc29saWQgIzliNGRjYTtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiTWVubG9cXFwiLCBcXFwiQ29uc29sYXNcXFwiLCBcXFwiQml0c3RyZWFtIFZlcmEgU2FucyBNb25vXFxcIiwgXFxcIkRlamFWdSBTYW5zIE1vbm9cXFwiLCBcXFwiTW9uYWNvXFxcIiwgbW9ub3NwYWNlO1xcbn1cXG5wcmUgPiBjb2RlIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMXJlbSAxLjVyZW07XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbn1cXG5cXG5ociB7XFxuICBib3JkZXI6IDA7XFxuICBib3JkZXItdG9wOiAwLjFyZW0gc29saWQgI2Y0ZjVmNjtcXG4gIG1hcmdpbi1ib3R0b206IDMuNXJlbTtcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxufVxcblxcbmlucHV0W3R5cGU9J2VtYWlsJ10sXFxuaW5wdXRbdHlwZT0nbnVtYmVyJ10sXFxuaW5wdXRbdHlwZT0ncGFzc3dvcmQnXSxcXG5pbnB1dFt0eXBlPSdzZWFyY2gnXSxcXG5pbnB1dFt0eXBlPSd0ZWwnXSxcXG5pbnB1dFt0eXBlPSd0ZXh0J10sXFxuaW5wdXRbdHlwZT0ndXJsJ10sXFxudGV4dGFyZWEsXFxuc2VsZWN0IHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiAwLjFyZW0gc29saWQgI2QxZDFkMTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNHJlbTtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxuICBoZWlnaHQ6IDMuOHJlbTtcXG4gIHBhZGRpbmc6IDAuNnJlbSAxcmVtO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbmlucHV0W3R5cGU9J2VtYWlsJ106Zm9jdXMsXFxuaW5wdXRbdHlwZT0nbnVtYmVyJ106Zm9jdXMsXFxuaW5wdXRbdHlwZT0ncGFzc3dvcmQnXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSdzZWFyY2gnXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSd0ZWwnXTpmb2N1cyxcXG5pbnB1dFt0eXBlPSd0ZXh0J106Zm9jdXMsXFxuaW5wdXRbdHlwZT0ndXJsJ106Zm9jdXMsXFxudGV4dGFyZWE6Zm9jdXMsXFxuc2VsZWN0OmZvY3VzIHtcXG4gIGJvcmRlcjogMC4xcmVtIHNvbGlkICM5YjRkY2E7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG5cXG5zZWxlY3Qge1xcbiAgcGFkZGluZzogMC42cmVtIDNyZW0gMC42cmVtIDFyZW07XFxuICBiYWNrZ3JvdW5kOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtQSE4yWnlBZ0lIaHRiRzV6T21SalBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaV3hsYldWdWRITXZNUzR4THlJZ0lDQjRiV3h1Y3pwall6MGlhSFIwY0RvdkwyTnlaV0YwYVhabFkyOXRiVzl1Y3k1dmNtY3Zibk1qSWlBZ0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SWdJQ0I0Yld4dWN6cHpkbWM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlBZ0lIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ0lDQjRiV3h1Y3pwemIyUnBjRzlrYVQwaWFIUjBjRG92TDNOdlpHbHdiMlJwTG5OdmRYSmpaV1p2Y21kbExtNWxkQzlFVkVRdmMyOWthWEJ2WkdrdE1DNWtkR1FpSUNBZ2VHMXNibk02YVc1cmMyTmhjR1U5SW1oMGRIQTZMeTkzZDNjdWFXNXJjMk5oY0dVdWIzSm5MMjVoYldWemNHRmpaWE12YVc1cmMyTmhjR1VpSUNBZ1pXNWhZbXhsTFdKaFkydG5jbTkxYm1ROUltNWxkeUF3SURBZ01qa2dNVFFpSUNBZ2FHVnBaMmgwUFNJeE5IQjRJaUFnSUdsa1BTSk1ZWGxsY2w4eElpQWdJSFpsY25OcGIyNDlJakV1TVNJZ0lDQjJhV1YzUW05NFBTSXdJREFnTWprZ01UUWlJQ0FnZDJsa2RHZzlJakk1Y0hnaUlDQWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0lnSUNCcGJtdHpZMkZ3WlRwMlpYSnphVzl1UFNJd0xqUTRMalFnY2prNU16a2lJQ0FnYzI5a2FYQnZaR2s2Wkc5amJtRnRaVDBpWTJGeVpYUXRaM0poZVM1emRtY2lQanh0WlhSaFpHRjBZU0FnSUNBZ2FXUTlJbTFsZEdGa1lYUmhNekF6T1NJK1BISmtaanBTUkVZK1BHTmpPbGR2Y21zZ0lDQWdJQ0FnSUNCeVpHWTZZV0p2ZFhROUlpSStQR1JqT21admNtMWhkRDVwYldGblpTOXpkbWNyZUcxc1BDOWtZenBtYjNKdFlYUStQR1JqT25SNWNHVWdJQ0FnSUNBZ0lDQWdJSEprWmpweVpYTnZkWEpqWlQwaWFIUjBjRG92TDNCMWNtd3ViM0puTDJSakwyUmpiV2wwZVhCbEwxTjBhV3hzU1cxaFoyVWlJQzgrUEM5all6cFhiM0pyUGp3dmNtUm1PbEpFUmo0OEwyMWxkR0ZrWVhSaFBqeGtaV1p6SUNBZ0lDQnBaRDBpWkdWbWN6TXdNemNpSUM4K1BITnZaR2x3YjJScE9tNWhiV1ZrZG1sbGR5QWdJQ0FnY0dGblpXTnZiRzl5UFNJalptWm1abVptSWlBZ0lDQWdZbTl5WkdWeVkyOXNiM0k5SWlNMk5qWTJOallpSUNBZ0lDQmliM0prWlhKdmNHRmphWFI1UFNJeElpQWdJQ0FnYjJKcVpXTjBkRzlzWlhKaGJtTmxQU0l4TUNJZ0lDQWdJR2R5YVdSMGIyeGxjbUZ1WTJVOUlqRXdJaUFnSUNBZ1ozVnBaR1YwYjJ4bGNtRnVZMlU5SWpFd0lpQWdJQ0FnYVc1cmMyTmhjR1U2Y0dGblpXOXdZV05wZEhrOUlqQWlJQ0FnSUNCcGJtdHpZMkZ3WlRwd1lXZGxjMmhoWkc5M1BTSXlJaUFnSUNBZ2FXNXJjMk5oY0dVNmQybHVaRzkzTFhkcFpIUm9QU0k1TURNaUlDQWdJQ0JwYm10elkyRndaVHAzYVc1a2IzY3RhR1ZwWjJoMFBTSTFPVFFpSUNBZ0lDQnBaRDBpYm1GdFpXUjJhV1YzTXpBek5TSWdJQ0FnSUhOb2IzZG5jbWxrUFNKMGNuVmxJaUFnSUNBZ2FXNXJjMk5oY0dVNmVtOXZiVDBpTVRJdU1UTTNPVE14SWlBZ0lDQWdhVzVyYzJOaGNHVTZZM2c5SWkwMExqRXhPVE14T0RKbExUQTRJaUFnSUNBZ2FXNXJjMk5oY0dVNlkzazlJamNpSUNBZ0lDQnBibXR6WTJGd1pUcDNhVzVrYjNjdGVEMGlOVEF5SWlBZ0lDQWdhVzVyYzJOaGNHVTZkMmx1Wkc5M0xYazlJak13TWlJZ0lDQWdJR2x1YTNOallYQmxPbmRwYm1SdmR5MXRZWGhwYldsNlpXUTlJakFpSUNBZ0lDQnBibXR6WTJGd1pUcGpkWEp5Wlc1MExXeGhlV1Z5UFNKTVlYbGxjbDh4SWo0OGFXNXJjMk5oY0dVNlozSnBaQ0FnSUNBZ0lDQjBlWEJsUFNKNGVXZHlhV1FpSUNBZ0lDQWdJR2xrUFNKbmNtbGtNekEwTVNJZ0x6NDhMM052Wkdsd2IyUnBPbTVoYldWa2RtbGxkejQ4Y0c5c2VXZHZiaUFnSUNBZ2NHOXBiblJ6UFNJd0xqRTFMREFnTVRRdU5Td3hOQzR6TlNBeU9DNDROU3d3SUNJZ0lDQWdJR2xrUFNKd2IyeDVaMjl1TXpBek15SWdJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RBdU16VTBNVEV6T0Rjc01Dd3dMREF1TkRnek1qa3hNU3c1TGpNeU5ERTFORFVzTXk0Mk1qUTVPVGt5S1NJZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lOa01XUXhaREU3Wm1sc2JDMXZjR0ZqYVhSNU9qRWlJQzgrUEM5emRtYyspIGNlbnRlciByaWdodCBuby1yZXBlYXQ7XFxufVxcbnNlbGVjdDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lJSE4wWVc1a1lXeHZibVU5SW01dklqOCtQSE4yWnlBZ0lIaHRiRzV6T21SalBTSm9kSFJ3T2k4dmNIVnliQzV2Y21jdlpHTXZaV3hsYldWdWRITXZNUzR4THlJZ0lDQjRiV3h1Y3pwall6MGlhSFIwY0RvdkwyTnlaV0YwYVhabFkyOXRiVzl1Y3k1dmNtY3Zibk1qSWlBZ0lIaHRiRzV6T25Ka1pqMGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNVGs1T1M4d01pOHlNaTF5WkdZdGMzbHVkR0Y0TFc1ekl5SWdJQ0I0Yld4dWN6cHpkbWM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlBZ0lIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ0lDQjRiV3h1Y3pwemIyUnBjRzlrYVQwaWFIUjBjRG92TDNOdlpHbHdiMlJwTG5OdmRYSmpaV1p2Y21kbExtNWxkQzlFVkVRdmMyOWthWEJ2WkdrdE1DNWtkR1FpSUNBZ2VHMXNibk02YVc1cmMyTmhjR1U5SW1oMGRIQTZMeTkzZDNjdWFXNXJjMk5oY0dVdWIzSm5MMjVoYldWemNHRmpaWE12YVc1cmMyTmhjR1VpSUNBZ1pXNWhZbXhsTFdKaFkydG5jbTkxYm1ROUltNWxkeUF3SURBZ01qa2dNVFFpSUNBZ2FHVnBaMmgwUFNJeE5IQjRJaUFnSUdsa1BTSk1ZWGxsY2w4eElpQWdJSFpsY25OcGIyNDlJakV1TVNJZ0lDQjJhV1YzUW05NFBTSXdJREFnTWprZ01UUWlJQ0FnZDJsa2RHZzlJakk1Y0hnaUlDQWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0lnSUNCcGJtdHpZMkZ3WlRwMlpYSnphVzl1UFNJd0xqUTRMalFnY2prNU16a2lJQ0FnYzI5a2FYQnZaR2s2Wkc5amJtRnRaVDBpWTJGeVpYUXVjM1puSWo0OGJXVjBZV1JoZEdFZ0lDQWdJR2xrUFNKdFpYUmhaR0YwWVRNd016a2lQanh5WkdZNlVrUkdQanhqWXpwWGIzSnJJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsSUNBZ0lDQWdJQ0FnSUNCeVpHWTZjbVZ6YjNWeVkyVTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlrWTIxcGRIbHdaUzlUZEdsc2JFbHRZV2RsSWlBdlBqd3ZZMk02VjI5eWF6NDhMM0prWmpwU1JFWStQQzl0WlhSaFpHRjBZVDQ4WkdWbWN5QWdJQ0FnYVdROUltUmxabk16TURNM0lpQXZQanh6YjJScGNHOWthVHB1WVcxbFpIWnBaWGNnSUNBZ0lIQmhaMlZqYjJ4dmNqMGlJMlptWm1abVppSWdJQ0FnSUdKdmNtUmxjbU52Ykc5eVBTSWpOalkyTmpZMklpQWdJQ0FnWW05eVpHVnliM0JoWTJsMGVUMGlNU0lnSUNBZ0lHOWlhbVZqZEhSdmJHVnlZVzVqWlQwaU1UQWlJQ0FnSUNCbmNtbGtkRzlzWlhKaGJtTmxQU0l4TUNJZ0lDQWdJR2QxYVdSbGRHOXNaWEpoYm1ObFBTSXhNQ0lnSUNBZ0lHbHVhM05qWVhCbE9uQmhaMlZ2Y0dGamFYUjVQU0l3SWlBZ0lDQWdhVzVyYzJOaGNHVTZjR0ZuWlhOb1lXUnZkejBpTWlJZ0lDQWdJR2x1YTNOallYQmxPbmRwYm1SdmR5MTNhV1IwYUQwaU9UQXpJaUFnSUNBZ2FXNXJjMk5oY0dVNmQybHVaRzkzTFdobGFXZG9kRDBpTlRrMElpQWdJQ0FnYVdROUltNWhiV1ZrZG1sbGR6TXdNelVpSUNBZ0lDQnphRzkzWjNKcFpEMGlkSEoxWlNJZ0lDQWdJR2x1YTNOallYQmxPbnB2YjIwOUlqRXlMakV6Tnprek1TSWdJQ0FnSUdsdWEzTmpZWEJsT21ONFBTSXROQzR4TVRrek1UZ3laUzB3T0NJZ0lDQWdJR2x1YTNOallYQmxPbU41UFNJM0lpQWdJQ0FnYVc1cmMyTmhjR1U2ZDJsdVpHOTNMWGc5SWpVd01pSWdJQ0FnSUdsdWEzTmpZWEJsT25kcGJtUnZkeTE1UFNJek1ESWlJQ0FnSUNCcGJtdHpZMkZ3WlRwM2FXNWtiM2N0YldGNGFXMXBlbVZrUFNJd0lpQWdJQ0FnYVc1cmMyTmhjR1U2WTNWeWNtVnVkQzFzWVhsbGNqMGlUR0Y1WlhKZk1TSStQR2x1YTNOallYQmxPbWR5YVdRZ0lDQWdJQ0FnZEhsd1pUMGllSGxuY21sa0lpQWdJQ0FnSUNCcFpEMGlaM0pwWkRNd05ERWlJQzgrUEM5emIyUnBjRzlrYVRwdVlXMWxaSFpwWlhjK1BIQnZiSGxuYjI0Z0lDQWdJSEJ2YVc1MGN6MGlNamd1T0RVc01DQXdMakUxTERBZ01UUXVOU3d4TkM0ek5TQWlJQ0FnSUNCcFpEMGljRzlzZVdkdmJqTXdNek1pSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbTFoZEhKcGVDZ3dMak0xTkRFeE16ZzNMREFzTUN3d0xqUTRNekk1TVRFc09TNHpNalF4TlRVekxETXVOakkxS1NJZ0lDQWdJSE4wZVd4bFBTSm1hV3hzT2lNNVlqUmtZMlk3Wm1sc2JDMXZjR0ZqYVhSNU9qRWlJQzgrUEM5emRtYyspO1xcbn1cXG5cXG50ZXh0YXJlYSB7XFxuICBwYWRkaW5nLWJvdHRvbTogMC42cmVtO1xcbiAgcGFkZGluZy10b3A6IDAuNnJlbTtcXG4gIG1pbi1oZWlnaHQ6IDYuNXJlbTtcXG59XFxuXFxubGFiZWwsXFxubGVnZW5kIHtcXG4gIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5pbnB1dFt0eXBlPSdjaGVja2JveCddLFxcbmlucHV0W3R5cGU9J3JhZGlvJ10ge1xcbiAgZGlzcGxheTogaW5saW5lO1xcbn1cXG5cXG4ubGFiZWwtaW5saW5lIHtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbn1cXG5cXG4uY29udGFpbmVyIHtcXG4gIG1hcmdpbjogMCBhdXRvO1xcbiAgbWF4LXdpZHRoOiAxMTJyZW07XFxuICBwYWRkaW5nOiAwIDJyZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnJvdyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmc6IDA7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLnJvdyAucm93LXdyYXAge1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4ucm93IC5yb3ctbm8tcGFkZGluZyB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4ucm93IC5yb3ctbm8tcGFkZGluZyA+IC5jb2x1bW4ge1xcbiAgcGFkZGluZzogMDtcXG59XFxuLnJvdyAucm93LXRvcCB7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG59XFxuLnJvdyAucm93LWJvdHRvbSB7XFxuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxufVxcbi5yb3cgLnJvdy1jZW50ZXIge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuLnJvdyAucm93LXN0cmV0Y2gge1xcbiAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxufVxcbi5yb3cgLnJvdy1iYXNlbGluZSB7XFxuICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XFxufVxcbi5yb3cgLmNvbHVtbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsZXg6IDE7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4ucm93IC5jb2x1bW4gLmNvbC10b3Age1xcbiAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcXG59XFxuLnJvdyAuY29sdW1uIC5jb2wtYm90dG9tIHtcXG4gIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbn1cXG4ucm93IC5jb2x1bW4gLmNvbC1jZW50ZXIge1xcbiAgYWxpZ24tc2VsZjogY2VudGVyO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC0xMCB7XFxuICBtYXJnaW4tbGVmdDogMTAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC0yMCB7XFxuICBtYXJnaW4tbGVmdDogMjAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC0yNSB7XFxuICBtYXJnaW4tbGVmdDogMjUlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC0zMywgLnJvdyAuY29sdW1uLmNvbHVtbi1vZmZzZXQtMzQge1xcbiAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC01MCB7XFxuICBtYXJnaW4tbGVmdDogNTAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC02NiwgLnJvdyAuY29sdW1uLmNvbHVtbi1vZmZzZXQtNjcge1xcbiAgbWFyZ2luLWxlZnQ6IDY2LjY2NjYlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC03NSB7XFxuICBtYXJnaW4tbGVmdDogNzUlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC04MCB7XFxuICBtYXJnaW4tbGVmdDogODAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLW9mZnNldC05MCB7XFxuICBtYXJnaW4tbGVmdDogOTAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLTEwIHtcXG4gIGZsZXg6IDAgMCAxMCU7XFxuICBtYXgtd2lkdGg6IDEwJTtcXG59XFxuLnJvdyAuY29sdW1uLmNvbHVtbi0yMCB7XFxuICBmbGV4OiAwIDAgMjAlO1xcbiAgbWF4LXdpZHRoOiAyMCU7XFxufVxcbi5yb3cgLmNvbHVtbi5jb2x1bW4tMjUge1xcbiAgZmxleDogMCAwIDI1JTtcXG4gIG1heC13aWR0aDogMjUlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLTMzLCAucm93IC5jb2x1bW4uY29sdW1uLTM0IHtcXG4gIGZsZXg6IDAgMCAzMy4zMzMzJTtcXG4gIG1heC13aWR0aDogMzMuMzMzMyU7XFxufVxcbi5yb3cgLmNvbHVtbi5jb2x1bW4tNDAge1xcbiAgZmxleDogMCAwIDQwJTtcXG4gIG1heC13aWR0aDogNDAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLTUwIHtcXG4gIGZsZXg6IDAgMCA1MCU7XFxuICBtYXgtd2lkdGg6IDUwJTtcXG59XFxuLnJvdyAuY29sdW1uLmNvbHVtbi02MCB7XFxuICBmbGV4OiAwIDAgNjAlO1xcbiAgbWF4LXdpZHRoOiA2MCU7XFxufVxcbi5yb3cgLmNvbHVtbi5jb2x1bW4tNjYsIC5yb3cgLmNvbHVtbi5jb2x1bW4tNjcge1xcbiAgZmxleDogMCAwIDY2LjY2NjYlO1xcbiAgbWF4LXdpZHRoOiA2Ni42NjY2JTtcXG59XFxuLnJvdyAuY29sdW1uLmNvbHVtbi03NSB7XFxuICBmbGV4OiAwIDAgNzUlO1xcbiAgbWF4LXdpZHRoOiA3NSU7XFxufVxcbi5yb3cgLmNvbHVtbi5jb2x1bW4tODAge1xcbiAgZmxleDogMCAwIDgwJTtcXG4gIG1heC13aWR0aDogODAlO1xcbn1cXG4ucm93IC5jb2x1bW4uY29sdW1uLTkwIHtcXG4gIGZsZXg6IDAgMCA5MCU7XFxuICBtYXgtd2lkdGg6IDkwJTtcXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDQwcmVtKSB7XFxuICAucm93IHtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgbWFyZ2luLWxlZnQ6IC0xcmVtO1xcbiAgICB3aWR0aDogY2FsYygxMDAlICsgMi4wcmVtKTtcXG4gIH1cXG4gIC5yb3cgLmNvbHVtbiB7XFxuICAgIG1hcmdpbi1ib3R0b206IGluaGVyaXQ7XFxuICAgIHBhZGRpbmc6IDAgMXJlbTtcXG4gIH1cXG59XFxuYSB7XFxuICBjb2xvcjogIzliNGRjYTtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuYTpob3ZlciB7XFxuICBjb2xvcjogIzYwNmM3NjtcXG59XFxuXFxuZGwsXFxub2wsXFxudWwge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG59XFxuZGwgdWwsXFxuZGwgb2wsXFxub2wgdWwsXFxub2wgb2wsXFxudWwgdWwsXFxudWwgb2wge1xcbiAgZm9udC1zaXplOiA5MCU7XFxuICBtYXJnaW46IDEuNXJlbSAwIDEuNXJlbSAzcmVtO1xcbn1cXG5cXG5kbCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG51bCB7XFxuICBsaXN0LXN0eWxlOiBjaXJjbGUgaW5zaWRlO1xcbn1cXG5cXG5vbCB7XFxuICBsaXN0LXN0eWxlOiBkZWNpbWFsIGluc2lkZTtcXG59XFxuXFxuZHQsXFxuZGQsXFxubGkge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuXFxuLmJ1dHRvbixcXG5idXR0b24ge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuXFxuaW5wdXQsXFxudGV4dGFyZWEsXFxuc2VsZWN0LFxcbmZpZWxkc2V0IHtcXG4gIG1hcmdpbi1ib3R0b206IDEuNXJlbTtcXG59XFxuXFxucHJlLFxcbmJsb2NrcXVvdGUsXFxuZGwsXFxuZmlndXJlLFxcbnRhYmxlLFxcbnAsXFxudWwsXFxub2wsXFxuZm9ybSB7XFxuICBtYXJnaW4tYm90dG9tOiAyLjVyZW07XFxufVxcblxcbnRhYmxlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG50aCxcXG50ZCB7XFxuICBib3JkZXItYm90dG9tOiAwLjFyZW0gc29saWQgI2UxZTFlMTtcXG4gIHBhZGRpbmc6IDEuMnJlbSAxLjVyZW07XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG50aDpmaXJzdC1jaGlsZCxcXG50ZDpmaXJzdC1jaGlsZCB7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxufVxcbnRoOmxhc3QtY2hpbGQsXFxudGQ6bGFzdC1jaGlsZCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwO1xcbn1cXG5cXG5wIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbiAgbWFyZ2luLXRvcDogMDtcXG59XFxuXFxuaDEge1xcbiAgZm9udC1zaXplOiA0cmVtO1xcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjFyZW07XFxuICBsaW5lLWhlaWdodDogMS4yO1xcbn1cXG5cXG5oMiB7XFxuICBmb250LXNpemU6IDMuNnJlbTtcXG4gIGxldHRlci1zcGFjaW5nOiAtMC4xcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMjU7XFxufVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogM3JlbTtcXG4gIGxldHRlci1zcGFjaW5nOiAtMC4xcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMztcXG59XFxuXFxuaDQge1xcbiAgZm9udC1zaXplOiAyLjRyZW07XFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDhyZW07XFxuICBsaW5lLWhlaWdodDogMS4zNTtcXG59XFxuXFxuaDUge1xcbiAgZm9udC1zaXplOiAxLjhyZW07XFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDVyZW07XFxuICBsaW5lLWhlaWdodDogMS41O1xcbn1cXG5cXG5oNiB7XFxuICBmb250LXNpemU6IDEuNnJlbTtcXG4gIGxldHRlci1zcGFjaW5nOiAwO1xcbiAgbGluZS1oZWlnaHQ6IDEuNDtcXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDQwcmVtKSB7XFxuICBoMSB7XFxuICAgIGZvbnQtc2l6ZTogNXJlbTtcXG4gIH1cXG5cXG4gIGgyIHtcXG4gICAgZm9udC1zaXplOiA0LjJyZW07XFxuICB9XFxuXFxuICBoMyB7XFxuICAgIGZvbnQtc2l6ZTogMy42cmVtO1xcbiAgfVxcblxcbiAgaDQge1xcbiAgICBmb250LXNpemU6IDNyZW07XFxuICB9XFxuXFxuICBoNSB7XFxuICAgIGZvbnQtc2l6ZTogMi40cmVtO1xcbiAgfVxcblxcbiAgaDYge1xcbiAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gIH1cXG59XFxuLmZsb2F0LXJpZ2h0IHtcXG4gIGZsb2F0OiByaWdodDtcXG59XFxuXFxuLmZsb2F0LWxlZnQge1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcblxcbi5jbGVhcmZpeCB7XFxuICAqem9vbTogMTtcXG59XFxuLmNsZWFyZml4OmFmdGVyLCAuY2xlYXJmaXg6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgZGlzcGxheTogdGFibGU7XFxufVxcbi5jbGVhcmZpeDphZnRlciB7XFxuICBjbGVhcjogYm90aDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuLi9qcy9ib3dlcl9jb21wb25lbnRzL21pbGxpZ3JhbS9kaXN0L21pbGxpZ3JhbS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9hbmd1bGFyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGFuZ3VsYXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9qcy9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvaW5kZXguanNcbiAqKi8iLCIvKiFcbiAqIFN0YXRlLWJhc2VkIHJvdXRpbmcgZm9yIEFuZ3VsYXJKU1xuICogQHZlcnNpb24gdjEuMC4wLWFscGhhLjNcbiAqIEBsaW5rIGh0dHA6Ly9hbmd1bGFyLXVpLmdpdGh1Yi5jb20vdWktcm91dGVyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSwgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJhbmd1bGFyLXVpLXJvdXRlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJhbmd1bGFyLXVpLXJvdXRlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJhbmd1bGFyLXVpLXJvdXRlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIE1haW4gZW50cnkgcG9pbnQgZm9yIGFuZ3VsYXIgMS54IGJ1aWxkXG5cdCAqIEBtb2R1bGUgbmcxXG5cdCAqL1xuXHQvKiogZm9yIHR5cGVkb2MgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcblx0ICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcblx0fVxuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MykpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFwidWkucm91dGVyXCI7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKiBAbW9kdWxlIGNvbW1vbiAqLyAvKiogKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcblx0ICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcblx0fVxuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oNDApKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oNDUpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg0OSkpO1xuXHR2YXIgcm91dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblx0ZXhwb3J0cy5VSVJvdXRlciA9IHJvdXRlcl8xLlVJUm91dGVyO1xuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0ZnVuY3Rpb24gX19leHBvcnQobSkge1xuXHQgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xuXHR9XG5cdC8qKiBAbW9kdWxlIGNvbW1vbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg1KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqXG5cdCAqIFJhbmRvbSB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBVSS1Sb3V0ZXIgY29kZVxuXHQgKlxuXHQgKiBAcHJlZmVycmVkIEBtb2R1bGUgY29tbW9uXG5cdCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgYW5ndWxhciA9IHdpbmRvdy5hbmd1bGFyIHx8IHt9O1xuXHRleHBvcnRzLmZyb21Kc29uID0gYW5ndWxhci5mcm9tSnNvbiB8fCBKU09OLnBhcnNlLmJpbmQoSlNPTik7XG5cdGV4cG9ydHMudG9Kc29uID0gYW5ndWxhci50b0pzb24gfHwgSlNPTi5zdHJpbmdpZnkuYmluZChKU09OKTtcblx0ZXhwb3J0cy5jb3B5ID0gYW5ndWxhci5jb3B5IHx8IF9jb3B5O1xuXHRleHBvcnRzLmZvckVhY2ggPSBhbmd1bGFyLmZvckVhY2ggfHwgX2ZvckVhY2g7XG5cdGV4cG9ydHMuZXh0ZW5kID0gYW5ndWxhci5leHRlbmQgfHwgX2V4dGVuZDtcblx0ZXhwb3J0cy5lcXVhbHMgPSBhbmd1bGFyLmVxdWFscyB8fCBfZXF1YWxzO1xuXHRleHBvcnRzLmlkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH07XG5cdGV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcblx0ZXhwb3J0cy5hYnN0cmFjdEtleSA9ICdhYnN0cmFjdCc7XG5cdC8qKlxuXHQgKiBCaW5kcyBhbmQgY29waWVzIGZ1bmN0aW9ucyBvbnRvIGFuIG9iamVjdFxuXHQgKlxuXHQgKiBUYWtlcyBmdW5jdGlvbnMgZnJvbSB0aGUgJ2Zyb20nIG9iamVjdCwgYmluZHMgdGhvc2UgZnVuY3Rpb25zIHRvIHRoZSBfdGhpcyBvYmplY3QsIGFuZCBwdXRzIHRoZSBib3VuZCBmdW5jdGlvbnNcblx0ICogb24gdGhlICd0bycgb2JqZWN0LlxuXHQgKlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhbiBuZXcgY2xhc3MgaW5zdGFuY2Ugd2hvc2UgZnVuY3Rpb25zIGFyZSBwcmVib3VuZCB0byB0aGUgbmV3J2Qgb2JqZWN0LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBcblx0ICpcblx0ICogY2xhc3MgRm9vIHtcblx0ICogICBjb25zdHJ1Y3RvcihkYXRhKSB7XG5cdCAqICAgICAvLyBCaW5kcyBhbGwgZnVuY3Rpb25zIGZyb20gRm9vLnByb3RvdHlwZSB0byAndGhpcycsXG5cdCAqICAgICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuXHQgKiAgICAgYmluZEZ1bmN0aW9ucyhGb28ucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcblx0ICogICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cdCAqICAgfVxuXHQgKlxuXHQgKiAgIGxvZygpIHtcblx0ICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG5cdCAqICAgfVxuXHQgKiB9XG5cdCAqXG5cdCAqIGxldCBteUZvbyA9IG5ldyBGb28oWzEsMiwzXSk7XG5cdCAqIHZhciBsb2dpdCA9IG15Rm9vLmxvZztcblx0ICogbG9naXQoKTsgLy8gbG9ncyBbMSwgMiwgM10gZnJvbSB0aGUgbXlGb28gJ3RoaXMnIGluc3RhbmNlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIGJvdW5kIHZlcnNpb24gb2YgYSBzZXJ2aWNlIGZ1bmN0aW9uLCBhbmQgY29waWVzIGl0IHRvIGFub3RoZXIgb2JqZWN0XG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiB2YXIgU29tZVNlcnZpY2UgPSB7XG5cdCAqICAgdGhpcy5kYXRhID0gWzMsIDQsIDVdO1xuXHQgKiAgIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG5cdCAqICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuXHQgKiAgIH1cblx0ICogfVxuXHQgKlxuXHQgKiAvLyBDb25zdHJ1Y3RvciBmblxuXHQgKiBmdW5jdGlvbiBPdGhlclRoaW5nKCkge1xuXHQgKiAgIC8vIEJpbmRzIGFsbCBmdW5jdGlvbnMgZnJvbSBTb21lU2VydmljZSB0byBTb21lU2VydmljZSxcblx0ICogICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuXHQgKiAgIGJpbmRGdW5jdGlvbnMoU29tZVNlcnZpY2UsIHRoaXMsIFNvbWVTZXJ2aWNlKTtcblx0ICogfVxuXHQgKlxuXHQgKiBsZXQgbXlPdGhlclRoaW5nID0gbmV3IE90aGVyVGhpbmcoKTtcblx0ICogbXlPdGhlclRoaW5nLmxvZygpOyAvLyBsb2dzIFszLCA0LCA1XSBmcm9tIFNvbWVTZXJ2aWNlJ3MgJ3RoaXMnXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBAcGFyYW0gZnJvbSBUaGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmdW5jdGlvbnMgdG8gYmUgYm91bmRcblx0ICogQHBhcmFtIHRvIFRoZSBvYmplY3Qgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBib3VuZCBmdW5jdGlvbnNcblx0ICogQHBhcmFtIGJpbmRUbyBUaGUgb2JqZWN0IHdoaWNoIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBib3VuZCB0b1xuXHQgKiBAcGFyYW0gZm5OYW1lcyBUaGUgZnVuY3Rpb24gbmFtZXMgd2hpY2ggd2lsbCBiZSBib3VuZCAoRGVmYXVsdHMgdG8gYWxsIHRoZSBmdW5jdGlvbnMgZm91bmQgb24gdGhlICdmcm9tJyBvYmplY3QpXG5cdCAqL1xuXHRmdW5jdGlvbiBiaW5kRnVuY3Rpb25zKGZyb20sIHRvLCBiaW5kVG8sIGZuTmFtZXMpIHtcblx0ICAgIGlmIChmbk5hbWVzID09PSB2b2lkIDApIHsgZm5OYW1lcyA9IE9iamVjdC5rZXlzKGZyb20pOyB9XG5cdCAgICByZXR1cm4gZm5OYW1lcy5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHR5cGVvZiBmcm9tW25hbWVdID09PSAnZnVuY3Rpb24nOyB9KVxuXHQgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0b1tuYW1lXSA9IGZyb21bbmFtZV0uYmluZChiaW5kVG8pOyB9KTtcblx0fVxuXHRleHBvcnRzLmJpbmRGdW5jdGlvbnMgPSBiaW5kRnVuY3Rpb25zO1xuXHQvKipcblx0ICogcHJvdG90eXBhbCBpbmhlcml0YW5jZSBoZWxwZXIuXG5cdCAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdoaWNoIGhhcyBgcGFyZW50YCBvYmplY3QgYXMgaXRzIHByb3RvdHlwZSwgYW5kIHRoZW4gY29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gYGV4dHJhYCBvbnRvIGl0XG5cdCAqL1xuXHRleHBvcnRzLmluaGVyaXQgPSBmdW5jdGlvbiAocGFyZW50LCBleHRyYSkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKG5ldyAoZXhwb3J0cy5leHRlbmQoZnVuY3Rpb24gKCkgeyB9LCB7IHByb3RvdHlwZTogcGFyZW50IH0pKSgpLCBleHRyYSk7XG5cdH07XG5cdC8qKlxuXHQgKiBHaXZlbiBhbiBhcmd1bWVudHMgb2JqZWN0LCBjb252ZXJ0cyB0aGUgYXJndW1lbnRzIGF0IGluZGV4IGlkeCBhbmQgYWJvdmUgdG8gYW4gYXJyYXkuXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byBlczYgcmVzdCBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiBPcHRpb25hbGx5LCB0aGUgYXJndW1lbnQgYXQgaW5kZXggaWR4IG1heSBpdHNlbGYgYWxyZWFkeSBiZSBhbiBhcnJheS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsXG5cdCAqIGdpdmVuIGVpdGhlcjpcblx0ICogICAgICAgIGFyZ3VtZW50cyA9IFsgb2JqLCBcImZvb1wiLCBcImJhclwiIF1cblx0ICogb3I6XG5cdCAqICAgICAgICBhcmd1bWVudHMgPSBbIG9iaiwgW1wiZm9vXCIsIFwiYmFyXCJdIF1cblx0ICogdGhlbjpcblx0ICogICAgICAgIHJlc3RBcmdzKGFyZ3VtZW50cywgMSkgPT0gW1wiZm9vXCIsIFwiYmFyXCJdXG5cdCAqXG5cdCAqIFRoaXMgYWxsb3dzIGZ1bmN0aW9ucyBsaWtlIHBpY2soKSB0byBiZSBpbXBsZW1lbnRlZCBzdWNoIHRoYXQgaXQgYWxsb3dzIGVpdGhlciBhIGJ1bmNoXG5cdCAqIG9mIHN0cmluZyBhcmd1bWVudHMgKGxpa2UgZXM2IHJlc3QgcGFyYW1ldGVycyksIG9yIGEgc2luZ2xlIGFycmF5IG9mIHN0cmluZ3M6XG5cdCAqXG5cdCAqIGdpdmVuOlxuXHQgKiAgICAgICAgdmFyIG9iaiA9IHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9O1xuXHQgKiB0aGVuOlxuXHQgKiAgICAgICAgcGljayhvYmosIFwiZm9vXCIsIFwiYmFyXCIpOyAgIC8vIHJldHVybnMgeyBmb286IDEsIGJhcjogMiB9XG5cdCAqICAgICAgICBwaWNrKG9iaiwgW1wiZm9vXCIsIFwiYmFyXCJdKTsgLy8gcmV0dXJucyB7IGZvbzogMSwgYmFyOiAyIH1cblx0ICovXG5cdHZhciByZXN0QXJncyA9IGZ1bmN0aW9uIChhcmdzLCBpZHgpIHtcblx0ICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShBcnJheS5wcm90b3R5cGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIGlkeCkpO1xuXHR9O1xuXHQvKiogR2l2ZW4gYW4gYXJyYXksIHJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGZvdW5kIGluIHRoZSBhcnJheSwgKHVzaW5nIGluZGV4T2YpICovXG5cdHZhciBpbkFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBvYmopIHsgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKSAhPT0gLTE7IH07XG5cdC8qKiBHaXZlbiBhbiBhcnJheSwgYW5kIGFuIGl0ZW0sIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBhcnJheSwgaXQgcmVtb3ZlcyBpdCAoaW4tcGxhY2UpLiAgVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWQgKi9cblx0ZXhwb3J0cy5yZW1vdmVGcm9tID0gaG9mXzEuY3VycnkoZnVuY3Rpb24gKGFycmF5LCBvYmopIHtcblx0ICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKG9iaik7XG5cdCAgICBpZiAoaWR4ID49IDApXG5cdCAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG5cdCAgICByZXR1cm4gYXJyYXk7XG5cdH0pO1xuXHQvKipcblx0ICogQXBwbGllcyBhIHNldCBvZiBkZWZhdWx0cyB0byBhbiBvcHRpb25zIG9iamVjdC4gIFRoZSBvcHRpb25zIG9iamVjdCBpcyBmaWx0ZXJlZFxuXHQgKiB0byBvbmx5IHRob3NlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdHMgaW4gdGhlIGRlZmF1bHRzTGlzdC5cblx0ICogRWFybGllciBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QgdGFrZSBwcmVjZWRlbmNlIHdoZW4gYXBwbHlpbmcgZGVmYXVsdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZhdWx0cyhvcHRzKSB7XG5cdCAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuXHQgICAgdmFyIGRlZmF1bHRzTGlzdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICBkZWZhdWx0c0xpc3RbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICB9XG5cdCAgICB2YXIgZGVmYXVsdHMgPSBtZXJnZS5hcHBseShudWxsLCBbe31dLmNvbmNhdChkZWZhdWx0c0xpc3QpKTtcblx0ICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBpY2sob3B0cyB8fCB7fSwgT2JqZWN0LmtleXMoZGVmYXVsdHMpKSk7XG5cdH1cblx0ZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXHQvKipcblx0ICogTWVyZ2VzIHByb3BlcnRpZXMgZnJvbSB0aGUgbGlzdCBvZiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAqIElmIGEgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgdGhlbiBpdCBpcyBub3Qgb3ZlcndyaXR0ZW4uXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZShkc3QpIHtcblx0ICAgIHZhciBvYmpzID0gW107XG5cdCAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIG9ianNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICB9XG5cdCAgICBleHBvcnRzLmZvckVhY2gob2JqcywgZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIGV4cG9ydHMuZm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cdCAgICAgICAgICAgIGlmICghZHN0Lmhhc093blByb3BlcnR5KGtleSkpXG5cdCAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZHN0O1xuXHR9XG5cdGV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcblx0LyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW50byBhIHNpbmdsZSBvYmplY3QsIHVzaW5nIGV4dGVuZCAqL1xuXHRleHBvcnRzLm1lcmdlUiA9IGZ1bmN0aW9uIChtZW1vLCBpdGVtKSB7IHJldHVybiBleHBvcnRzLmV4dGVuZChtZW1vLCBpdGVtKTsgfTtcblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBiZXR3ZWVuIHR3byBzdGF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBUaGUgZmlyc3Qgc3RhdGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgVGhlIHNlY29uZCBzdGF0ZS5cblx0ICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgbmFtZXMgaW4gZGVzY2VuZGluZyBvcmRlciwgbm90IGluY2x1ZGluZyB0aGUgcm9vdC5cblx0ICovXG5cdGZ1bmN0aW9uIGFuY2VzdG9ycyhmaXJzdCwgc2Vjb25kKSB7XG5cdCAgICB2YXIgcGF0aCA9IFtdO1xuXHQgICAgZm9yICh2YXIgbiBpbiBmaXJzdC5wYXRoKSB7XG5cdCAgICAgICAgaWYgKGZpcnN0LnBhdGhbbl0gIT09IHNlY29uZC5wYXRoW25dKVxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBwYXRoLnB1c2goZmlyc3QucGF0aFtuXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcGF0aDtcblx0fVxuXHRleHBvcnRzLmFuY2VzdG9ycyA9IGFuY2VzdG9ycztcblx0LyoqXG5cdCAqIFBlcmZvcm1zIGEgbm9uLXN0cmljdCBjb21wYXJpc29uIG9mIHRoZSBzdWJzZXQgb2YgdHdvIG9iamVjdHMsIGRlZmluZWQgYnkgYSBsaXN0IG9mIGtleXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBmaXJzdCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBzZWNvbmQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBsaXN0IG9mIGtleXMgd2l0aGluIGVhY2ggb2JqZWN0IHRvIGNvbXBhcmUuIElmIHRoZSBsaXN0IGlzIGVtcHR5IG9yIG5vdCBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgICAgICAgaXQgZGVmYXVsdHMgdG8gdGhlIGxpc3Qgb2Yga2V5cyBpbiBgYWAuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGVxdWFsRm9yS2V5cyhhLCBiLCBrZXlzKSB7XG5cdCAgICBpZiAoa2V5cyA9PT0gdm9pZCAwKSB7IGtleXMgPSBPYmplY3Qua2V5cyhhKTsgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuXHQgICAgICAgIGlmIChhW2tdICE9IGJba10pXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90ICc9PT0nLCB2YWx1ZXMgYXJlbid0IG5lY2Vzc2FyaWx5IG5vcm1hbGl6ZWRcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGV4cG9ydHMuZXF1YWxGb3JLZXlzID0gZXF1YWxGb3JLZXlzO1xuXHRmdW5jdGlvbiBwaWNrT21pdEltcGwocHJlZGljYXRlLCBvYmopIHtcblx0ICAgIHZhciBvYmpDb3B5ID0ge30sIGtleXMgPSByZXN0QXJncyhhcmd1bWVudHMsIDIpO1xuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIGlmIChwcmVkaWNhdGUoa2V5cywga2V5KSlcblx0ICAgICAgICAgICAgb2JqQ29weVtrZXldID0gb2JqW2tleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb2JqQ29weTtcblx0fVxuXHQvKiogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy4gKi9cblx0ZnVuY3Rpb24gcGljayhvYmopIHsgcmV0dXJuIHBpY2tPbWl0SW1wbC5hcHBseShudWxsLCBbaW5BcnJheV0uY29uY2F0KHJlc3RBcmdzKGFyZ3VtZW50cykpKTsgfVxuXHRleHBvcnRzLnBpY2sgPSBwaWNrO1xuXHQvKiogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLiAqL1xuXHRmdW5jdGlvbiBvbWl0KG9iaikgeyByZXR1cm4gcGlja09taXRJbXBsLmFwcGx5KG51bGwsIFtob2ZfMS5ub3QoaW5BcnJheSldLmNvbmNhdChyZXN0QXJncyhhcmd1bWVudHMpKSk7IH1cblx0ZXhwb3J0cy5vbWl0ID0gb21pdDtcblx0LyoqXG5cdCAqIE1hcHMgYW4gYXJyYXksIG9yIG9iamVjdCB0byBhIHByb3BlcnR5IChieSBuYW1lKVxuXHQgKi9cblx0ZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcHJvcE5hbWUpIHtcblx0ICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgaG9mXzEucHJvcChwcm9wTmFtZSkpO1xuXHR9XG5cdGV4cG9ydHMucGx1Y2sgPSBwbHVjaztcblx0LyoqIEZpbHRlcnMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0J3MgcHJvcGVydGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSAqL1xuXHRmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcblx0ICAgIHZhciBhcnIgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb2xsZWN0aW9uKSwgcmVzdWx0ID0gYXJyID8gW10gOiB7fTtcblx0ICAgIHZhciBhY2NlcHQgPSBhcnIgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmVzdWx0LnB1c2goeCk7IH0gOiBmdW5jdGlvbiAoeCwga2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHg7IH07XG5cdCAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblx0ICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXG5cdCAgICAgICAgICAgIGFjY2VwdChpdGVtLCBpKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcblx0LyoqIEZpbmRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5LCBvciBhIHByb3BlcnR5IG9mIGFuIG9iamVjdCwgdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlICovXG5cdGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcblx0ICAgIHZhciByZXN1bHQ7XG5cdCAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHtcblx0ICAgICAgICBpZiAocmVzdWx0KVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZW0sIGkpKVxuXHQgICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuZmluZCA9IGZpbmQ7XG5cdC8qKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRyYW5zZm9ybWVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuXHRleHBvcnRzLm1hcE9iaiA9IG1hcDtcblx0LyoqIE1hcHMgYW4gYXJyYXkgb3Igb2JqZWN0IHByb3BlcnRpZXMgdXNpbmcgYSBjYWxsYmFjayBmdW5jdGlvbiAqL1xuXHRmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcblx0ICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge307XG5cdCAgICBleHBvcnRzLmZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIHJlc3VsdFtpXSA9IGNhbGxiYWNrKGl0ZW0sIGkpOyB9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZXhwb3J0cy5tYXAgPSBtYXA7XG5cdC8qKlxuXHQgKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBpdHMgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgXG5cdCAqXG5cdCAqIGxldCBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfVxuXHQgKiBsZXQgdmFscyA9IHZhbHVlcyhmb28pOyAvLyBbIDEsIDIsIDMgXVxuXHQgKiBgYGBcblx0ICovXG5cdGV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqW2tleV07IH0pOyB9O1xuXHQvKipcblx0ICogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFsbCBvZiB0aGUgdmFsdWVzIGFyZSB0cnV0aHkuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBsZXQgdmFscyA9IFsgMSwgdHJ1ZSwge30sIFwiaGVsbG8gd29ybGRcIl07XG5cdCAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gdHJ1ZVxuXHQgKlxuXHQgKiB2YWxzLnB1c2goMCk7XG5cdCAqIHZhbHMucmVkdWNlKGFsbFRydWVSLCB0cnVlKTsgLy8gZmFsc2Vcblx0ICogYGBgXG5cdCAqL1xuXHRleHBvcnRzLmFsbFRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gJiYgZWxlbTsgfTtcblx0LyoqXG5cdCAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgdHJ1dGh5LlxuXHQgKlxuXHQgKiAgKiBAZXhhbXBsZVxuXHQgKiBgYGBcblx0ICpcblx0ICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xuXHQgKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIGZhbHNlXG5cdCAqXG5cdCAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xuXHQgKiB2YWxzLnJlZHVjZShhbnlUcnVlUiwgdHJ1ZSk7IC8vIHRydWVcblx0ICogYGBgXG5cdCAqL1xuXHRleHBvcnRzLmFueVRydWVSID0gZnVuY3Rpb24gKG1lbW8sIGVsZW0pIHsgcmV0dXJuIG1lbW8gfHwgZWxlbTsgfTtcblx0LyoqXG5cdCAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcblx0ICogQGV4YW1wbGVcblx0ICogYGBgXG5cdCAqXG5cdCAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG5cdCAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgWyBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdIF1cblx0ICogYGBgXG5cdCAqL1xuXHRleHBvcnRzLnVubmVzdFIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtby5jb25jYXQoZWxlbSk7IH07XG5cdC8qKlxuXHQgKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggcmVjdXJzaXZlbHkgdW4tbmVzdHMgYWxsIGFycmF5c1xuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBcblx0ICpcblx0ICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcblx0ICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdXG5cdCAqIGBgYFxuXHQgKi9cblx0ZXhwb3J0cy5mbGF0dGVuUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShlbGVtKSA/IG1lbW8uY29uY2F0KGVsZW0ucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKSkgOiBwdXNoUihtZW1vLCBlbGVtKTsgfTtcblx0LyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHB1c2hlcyBhbiBvYmplY3QgdG8gYW4gYXJyYXksIHRoZW4gcmV0dXJucyB0aGUgYXJyYXkuICBNb3N0bHkganVzdCBmb3IgW1tmbGF0dGVuUl1dICovXG5cdGZ1bmN0aW9uIHB1c2hSKGFyciwgb2JqKSB7IGFyci5wdXNoKG9iaik7IHJldHVybiBhcnI7IH1cblx0LyoqXG5cdCAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIGEgc2luZ2xlIGxldmVsIG9mIGFycmF5cyB1bm5lc3RlZC5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgXG5cdCAqXG5cdCAqIGxldCBpbnB1dCA9IFsgWyBcImFcIiwgXCJiXCIgXSwgWyBcImNcIiwgXCJkXCIgXSwgWyBbIFwiZG91YmxlXCIsIFwibmVzdGVkXCIgXSBdIF07XG5cdCAqIHVubmVzdChpbnB1dCkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgWyBcImRvdWJsZSwgXCJuZXN0ZWRcIiBdIF1cblx0ICogYGBgXG5cdCAqL1xuXHRleHBvcnRzLnVubmVzdCA9IGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZXhwb3J0cy51bm5lc3RSLCBbXSk7IH07XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBjb21wbGV0ZWx5IGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIGFuIGFycmF5LlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBcblx0ICpcblx0ICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcblx0ICogZmxhdHRlbihpbnB1dCkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuXHQgKiBgYGBcblx0ICovXG5cdGV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIGFyci5yZWR1Y2UoZXhwb3J0cy5mbGF0dGVuUiwgW10pOyB9O1xuXHQvKipcblx0ICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cblx0ICogQGV4YW1wbGVcblx0ICogYGBgXG5cdCAqXG5cdCAqIGxldCBpc051bWJlciA9IChvYmopID0+IHR5cGVvZihvYmopID09PSAnbnVtYmVyJztcblx0ICogbGV0IGFsbE51bWJlcnMgPSBbIDEsIDIsIDMsIDQsIDUgXTtcblx0ICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcblx0ICpcblx0ICogbGV0IG9uZVN0cmluZyA9IFsgMSwgMiwgMywgNCwgXCI1XCIgXTtcblx0ICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcblx0ICogYGBgXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBlcnJNc2cpIHtcblx0ICAgIGlmIChlcnJNc2cgPT09IHZvaWQgMCkgeyBlcnJNc2cgPSBcImFzc2VydCBmYWlsdXJlXCI7IH1cblx0ICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGUob2JqKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZXJyTXNnKSA/IGVyck1zZyhvYmopIDogZXJyTXNnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9O1xuXHR9XG5cdGV4cG9ydHMuYXNzZXJ0UHJlZGljYXRlID0gYXNzZXJ0UHJlZGljYXRlO1xuXHQvKipcblx0ICogTGlrZSBfLnBhaXJzOiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlIHBhaXJzXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBwYWlycyh7IGZvbzogXCJGT09cIiwgYmFyOiBcIkJBUiB9KSAvLyBbIFsgXCJmb29cIiwgXCJGT09cIiBdLCBbIFwiYmFyXCI6IFwiQkFSXCIgXSBdXG5cdCAqIGBgYFxuXHQgKi9cblx0ZXhwb3J0cy5wYWlycyA9IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTsgfSk7IH07XG5cdC8qKlxuXHQgKiBHaXZlbiB0d28gb3IgbW9yZSBwYXJhbGxlbCBhcnJheXMsIHJldHVybnMgYW4gYXJyYXkgb2YgdHVwbGVzIHdoZXJlXG5cdCAqIGVhY2ggdHVwbGUgaXMgY29tcG9zZWQgb2YgWyBhW2ldLCBiW2ldLCAuLi4geltpXSBdXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBsZXQgZm9vID0gWyAwLCAyLCA0LCA2IF07XG5cdCAqIGxldCBiYXIgPSBbIDEsIDMsIDUsIDcgXTtcblx0ICogbGV0IGJheiA9IFsgMTAsIDMwLCA1MCwgNzAgXTtcblx0ICogYXJyYXlUdXBsZXMoZm9vLCBiYXIpOyAgICAgICAvLyBbIFswLCAxXSwgWzIsIDNdLCBbNCwgNV0sIFs2LCA3XSBdXG5cdCAqIGFycmF5VHVwbGVzKGZvbywgYmFyLCBiYXopOyAgLy8gWyBbMCwgMSwgMTBdLCBbMiwgMywgMzBdLCBbNCwgNSwgNTBdLCBbNiwgNywgNzBdIF1cblx0ICogYGBgXG5cdCAqL1xuXHRmdW5jdGlvbiBhcnJheVR1cGxlcygpIHtcblx0ICAgIHZhciBhcnJheUFyZ3MgPSBbXTtcblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgYXJyYXlBcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgfVxuXHQgICAgaWYgKGFycmF5QXJncy5sZW5ndGggPT09IDApXG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgdmFyIGxlbmd0aCA9IGFycmF5QXJncy5yZWR1Y2UoZnVuY3Rpb24gKG1pbiwgYXJyKSB7IHJldHVybiBNYXRoLm1pbihhcnIubGVuZ3RoLCBtaW4pOyB9LCA5MDA3MTk5MjU0NzQwOTkxKTsgLy8gYWthIDJeNTMg4oiSIDEgYWthIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5cdCAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkobGVuZ3RoKSkubWFwKGZ1bmN0aW9uIChpZ25vcmVkLCBpZHgpIHsgcmV0dXJuIGFycmF5QXJncy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyW2lkeF07IH0pOyB9KTtcblx0fVxuXHRleHBvcnRzLmFycmF5VHVwbGVzID0gYXJyYXlUdXBsZXM7XG5cdC8qKlxuXHQgKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycy5cblx0ICpcblx0ICogRWFjaCBpdGVyYXRpb24gc2V0cyB0aGUga2V5L3ZhbCBwYWlyIG9uIHRoZSBtZW1vIG9iamVjdCwgdGhlbiByZXR1cm5zIHRoZSBtZW1vIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG5cdCAqXG5cdCAqIEVhY2gga2V5VmFsdWVUdXBsZSBzaG91bGQgYmUgYW4gYXJyYXkgd2l0aCB2YWx1ZXMgWyBrZXk6IHN0cmluZywgdmFsdWU6IGFueSBdXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiB2YXIgcGFpcnMgPSBbIFtcImZvb2tleVwiLCBcImZvb3ZhbFwiXSwgW1wiYmFya2V5XCIsIFwiYmFydmFsXCJdIF1cblx0ICpcblx0ICogdmFyIHBhaXJzVG9PYmogPSBwYWlycy5yZWR1Y2UoKG1lbW8sIHBhaXIpID0+IGFwcGx5UGFpcnMobWVtbywgcGFpciksIHt9KVxuXHQgKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuXHQgKlxuXHQgKiAvLyBPciwgbW9yZSBzaW1wbHk6XG5cdCAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KVxuXHQgKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuXHQgKiBgYGBcblx0ICovXG5cdGZ1bmN0aW9uIGFwcGx5UGFpcnMobWVtbywga2V5VmFsVHVwbGUpIHtcblx0ICAgIHZhciBrZXksIHZhbHVlO1xuXHQgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGtleVZhbFR1cGxlKSlcblx0ICAgICAgICBrZXkgPSBrZXlWYWxUdXBsZVswXSwgdmFsdWUgPSBrZXlWYWxUdXBsZVsxXTtcblx0ICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKGtleSkpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXJhbWV0ZXJzIHRvIGFwcGx5UGFpcnNcIik7XG5cdCAgICBtZW1vW2tleV0gPSB2YWx1ZTtcblx0ICAgIHJldHVybiBtZW1vO1xuXHR9XG5cdGV4cG9ydHMuYXBwbHlQYWlycyA9IGFwcGx5UGFpcnM7XG5cdC8qKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSAqL1xuXHRmdW5jdGlvbiB0YWlsKGFycikge1xuXHQgICAgcmV0dXJuIGFyci5sZW5ndGggJiYgYXJyW2Fyci5sZW5ndGggLSAxXSB8fCB1bmRlZmluZWQ7XG5cdH1cblx0ZXhwb3J0cy50YWlsID0gdGFpbDtcblx0LyoqXG5cdCAqIHNoYWxsb3cgY29weSBmcm9tIHNyYyB0byBkZXN0XG5cdCAqXG5cdCAqIG5vdGU6IFRoaXMgaXMgYSBzaGFsbG93IGNvcHksIHdoaWxlIGFuZ3VsYXIuY29weSBpcyBhIGRlZXAgY29weS5cblx0ICogdWktcm91dGVyIHVzZXMgYGNvcHlgIG9ubHkgdG8gbWFrZSBjb3BpZXMgb2Ygc3RhdGUgcGFyYW1ldGVycy5cblx0ICovXG5cdGZ1bmN0aW9uIF9jb3B5KHNyYywgZGVzdCkge1xuXHQgICAgaWYgKGRlc3QpXG5cdCAgICAgICAgT2JqZWN0LmtleXMoZGVzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBkZWxldGUgZGVzdFtrZXldOyB9KTtcblx0ICAgIGlmICghZGVzdClcblx0ICAgICAgICBkZXN0ID0ge307XG5cdCAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoZGVzdCwgc3JjKTtcblx0fVxuXHRmdW5jdGlvbiBfZm9yRWFjaChvYmosIGNiLCBfdGhpcykge1xuXHQgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KG9iaikpXG5cdCAgICAgICAgcmV0dXJuIG9iai5mb3JFYWNoKGNiLCBfdGhpcyk7XG5cdCAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2Iob2JqW2tleV0sIGtleSk7IH0pO1xuXHR9XG5cdGZ1bmN0aW9uIF9jb3B5UHJvcHModG8sIGZyb20pIHsgT2JqZWN0LmtleXMoZnJvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0b1trZXldID0gZnJvbVtrZXldOyB9KTsgcmV0dXJuIHRvOyB9XG5cdGZ1bmN0aW9uIF9leHRlbmQodG9PYmosIHJlc3QpIHtcblx0ICAgIHJldHVybiByZXN0QXJncyhhcmd1bWVudHMsIDEpLmZpbHRlcihleHBvcnRzLmlkZW50aXR5KS5yZWR1Y2UoX2NvcHlQcm9wcywgdG9PYmopO1xuXHR9XG5cdGZ1bmN0aW9uIF9lcXVhbHMobzEsIG8yKSB7XG5cdCAgICBpZiAobzEgPT09IG8yKVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIGlmIChvMSAhPT0gbzEgJiYgbzIgIT09IG8yKVxuXHQgICAgICAgIHJldHVybiB0cnVlOyAvLyBOYU4gPT09IE5hTlxuXHQgICAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMjtcblx0ICAgIGlmICh0MSAhPT0gdDIgfHwgdDEgIT09ICdvYmplY3QnKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciB0dXAgPSBbbzEsIG8yXTtcblx0ICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzQXJyYXkpKHR1cCkpXG5cdCAgICAgICAgcmV0dXJuIF9hcnJheXNFcShvMSwgbzIpO1xuXHQgICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNEYXRlKSh0dXApKVxuXHQgICAgICAgIHJldHVybiBvMS5nZXRUaW1lKCkgPT09IG8yLmdldFRpbWUoKTtcblx0ICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzUmVnRXhwKSh0dXApKVxuXHQgICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09PSBvMi50b1N0cmluZygpO1xuXHQgICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbikodHVwKSlcblx0ICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbWVoXG5cdCAgICB2YXIgcHJlZGljYXRlcyA9IFtwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbiwgcHJlZGljYXRlc18xLmlzQXJyYXksIHByZWRpY2F0ZXNfMS5pc0RhdGUsIHByZWRpY2F0ZXNfMS5pc1JlZ0V4cF07XG5cdCAgICBpZiAocHJlZGljYXRlcy5tYXAoaG9mXzEuYW55KS5yZWR1Y2UoZnVuY3Rpb24gKGIsIGZuKSB7IHJldHVybiBiIHx8ICEhZm4odHVwKTsgfSwgZmFsc2UpKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciBrZXksIGtleXMgPSB7fTtcblx0ICAgIGZvciAoa2V5IGluIG8xKSB7XG5cdCAgICAgICAgaWYgKCFfZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGZvciAoa2V5IGluIG8yKSB7XG5cdCAgICAgICAgaWYgKCFrZXlzW2tleV0pXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGZ1bmN0aW9uIF9hcnJheXNFcShhMSwgYTIpIHtcblx0ICAgIGlmIChhMS5sZW5ndGggIT09IGEyLmxlbmd0aClcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICByZXR1cm4gYXJyYXlUdXBsZXMoYTEsIGEyKS5yZWR1Y2UoZnVuY3Rpb24gKGIsIHQpIHsgcmV0dXJuIGIgJiYgX2VxdWFscyh0WzBdLCB0WzFdKTsgfSwgdHJ1ZSk7XG5cdH1cblx0Ly9cblx0Ly9jb25zdCBfYWRkVG9Hcm91cCA9IChyZXN1bHQsIGtleUZuKSA9PiAoaXRlbSkgPT5cblx0Ly8gIChyZXN1bHRba2V5Rm4oaXRlbSldID0gcmVzdWx0W2tleUZuKGl0ZW0pXSB8fCBbXSkucHVzaChpdGVtKSAmJiByZXN1bHQ7XG5cdC8vY29uc3QgZ3JvdXBCeSA9IChhcnJheSwga2V5Rm4pID0+IGFycmF5LnJlZHVjZSgobWVtbywgaXRlbSkgPT4gX2FkZFRvR3JvdXAobWVtbywga2V5Rm4pLCB7fSk7XG5cdC8vXG5cdC8vXG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogUHJlZGljYXRlcyBAbW9kdWxlIGNvbW1vbl9wcmVkaWNhdGVzICovIC8qKiAqL1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgdGlzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB0eXBlb2YgKHgpID09PSB0OyB9OyB9O1xuXHRleHBvcnRzLmlzVW5kZWZpbmVkID0gdGlzKCd1bmRlZmluZWQnKTtcblx0ZXhwb3J0cy5pc0RlZmluZWQgPSBob2ZfMS5ub3QoZXhwb3J0cy5pc1VuZGVmaW5lZCk7XG5cdGV4cG9ydHMuaXNOdWxsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gPT09IG51bGw7IH07XG5cdGV4cG9ydHMuaXNGdW5jdGlvbiA9IHRpcygnZnVuY3Rpb24nKTtcblx0ZXhwb3J0cy5pc051bWJlciA9IHRpcygnbnVtYmVyJyk7XG5cdGV4cG9ydHMuaXNTdHJpbmcgPSB0aXMoJ3N0cmluZycpO1xuXHRleHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnOyB9O1xuXHRleHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXHRleHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBEYXRlXSc7IH07XG5cdGV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH07XG5cdC8qKlxuXHQgKiBQcmVkaWNhdGUgd2hpY2ggY2hlY2tzIGlmIGEgdmFsdWUgaXMgaW5qZWN0YWJsZVxuXHQgKlxuXHQgKiBBIHZhbHVlIGlzIFwiaW5qZWN0YWJsZVwiIGlmIGl0IGlzIGEgZnVuY3Rpb24sIG9yIGlmIGl0IGlzIGFuIG5nMSBhcnJheS1ub3RhdGlvbi1zdHlsZSBhcnJheVxuXHQgKiB3aGVyZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgU3RyaW5ncywgZXhjZXB0IHRoZSBsYXN0IG9uZSwgd2hpY2ggaXMgYSBGdW5jdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gaXNJbmplY3RhYmxlKHZhbCkge1xuXHQgICAgaWYgKGV4cG9ydHMuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgaGVhZCA9IHZhbC5zbGljZSgwLCAtMSksIHRhaWwgPSB2YWwuc2xpY2UoLTEpO1xuXHQgICAgICAgIHJldHVybiAhKGhlYWQuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzU3RyaW5nKSkubGVuZ3RoIHx8IHRhaWwuZmlsdGVyKGhvZl8xLm5vdChleHBvcnRzLmlzRnVuY3Rpb24pKS5sZW5ndGgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGV4cG9ydHMuaXNGdW5jdGlvbih2YWwpO1xuXHR9XG5cdGV4cG9ydHMuaXNJbmplY3RhYmxlID0gaXNJbmplY3RhYmxlO1xuXHQvKipcblx0ICogUHJlZGljYXRlIHdoaWNoIGNoZWNrcyBpZiBhIHZhbHVlIGxvb2tzIGxpa2UgYSBQcm9taXNlXG5cdCAqXG5cdCAqIEl0IGlzIHByb2JhYmx5IGEgUHJvbWlzZSBpZiBpdCdzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhIGB0aGVuYCBwcm9wZXJ0eSB3aGljaCBpcyBhIEZ1bmN0aW9uXG5cdCAqL1xuXHRleHBvcnRzLmlzUHJvbWlzZSA9IGhvZl8xLmFuZChleHBvcnRzLmlzT2JqZWN0LCBob2ZfMS5waXBlKGhvZl8xLnByb3AoJ3RoZW4nKSwgZXhwb3J0cy5pc0Z1bmN0aW9uKSk7XG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBIaWdoZXIgb3JkZXIgZnVuY3Rpb25zXG5cdCAqXG5cdCAqIEBtb2R1bGUgY29tbW9uX2hvZlxuXHQgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGZvciBbUGFydGlhbCBBcHBsaWNhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9hcHBsaWNhdGlvbikgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBHaXZlbiBhIGZ1bmN0aW9uIHdpdGggTiBwYXJhbWV0ZXJzLCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgc3VwcG9ydHMgcGFydGlhbCBhcHBsaWNhdGlvbi5cblx0ICogVGhlIG5ldyBmdW5jdGlvbiBhY2NlcHRzIGFueXdoZXJlIGZyb20gMSB0byBOIHBhcmFtZXRlcnMuICBXaGVuIHRoYXQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggTSBwYXJhbWV0ZXJzLFxuXHQgKiB3aGVyZSBNIGlzIGxlc3MgdGhhbiBOLCBpdCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIHBhcmFtZXRlcnMuICBJdCBjb250aW51ZXMgdG9cblx0ICogYWNjZXB0IG1vcmUgcGFyYW1ldGVycyB1bnRpbCBhbGwgTiBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzdXBwbGllZC5cblx0ICpcblx0ICpcblx0ICogVGhpcyBjb250cml2ZWQgZXhhbXBsZSB1c2VzIGEgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24gYXMgYW4gcHJlZGljYXRlLCB3aGljaCByZXR1cm5zIHRydWVcblx0ICogaWYgYW4gb2JqZWN0IGlzIGZvdW5kIGluIGJvdGggYXJyYXlzLlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBcblx0ICogLy8gcmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBpbiBib3RoIG9mIHRoZSB0d28gYXJyYXlzXG5cdCAqIGZ1bmN0aW9uIGluQm90aChhcnJheTEsIGFycmF5Miwgb2JqZWN0KSB7XG5cdCAqICAgcmV0dXJuIGFycmF5MS5pbmRleE9mKG9iamVjdCkgIT09IC0xICYmXG5cdCAqICAgICAgICAgIGFycmF5Mi5pbmRleE9mKG9iamVjdCkgIT09IDE7XG5cdCAqIH1cblx0ICogbGV0IG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajdcblx0ICogbGV0IGZvb3MgPSBbb2JqMSwgb2JqM11cblx0ICogbGV0IGJhcnMgPSBbb2JqMywgb2JqNCwgb2JqNV1cblx0ICpcblx0ICogLy8gQSBjdXJyaWVkIFwiY29weVwiIG9mIGluQm90aFxuXHQgKiBsZXQgY3VycmllZEluQm90aCA9IGN1cnJ5KGluQm90aCk7XG5cdCAqIC8vIFBhcnRpYWxseSBhcHBseSBib3RoIHRoZSBhcnJheTEgYW5kIGFycmF5MlxuXHQgKiBsZXQgaW5Gb29zQW5kQmFycyA9IGN1cnJpZWRJbkJvdGgoZm9vcywgYmFycyk7XG5cdCAqXG5cdCAqIC8vIFN1cHBseSB0aGUgZmluYWwgYXJndW1lbnQ7IHNpbmNlIGFsbCBhcmd1bWVudHMgYXJlXG5cdCAqIC8vIHN1cHBsaWVkLCB0aGUgb3JpZ2luYWwgaW5Cb3RoIGZ1bmN0aW9uIGlzIHRoZW4gY2FsbGVkLlxuXHQgKiBsZXQgb2JqMUluQm90aCA9IGluRm9vc0FuZEJhcnMob2JqMSk7IC8vIGZhbHNlXG5cdCAqXG5cdCAqIC8vIFVzZSB0aGUgaW5Gb29zQW5kQmFycyBhcyBhIHByZWRpY2F0ZS5cblx0ICogLy8gRmlsdGVyLCBvbiBlYWNoIGl0ZXJhdGlvbiwgc3VwcGxpZXMgdGhlIGZpbmFsIGFyZ3VtZW50XG5cdCAqIGxldCBhbGxPYmpzID0gWyBvYmoxLCBvYmoyLCBvYmozLCBvYmo0LCBvYmo1LCBvYmo2LCBvYmo3IF07XG5cdCAqIGxldCBmb3VuZEluQm90aCA9IGFsbE9ianMuZmlsdGVyKGluRm9vc0FuZEJhcnMpOyAvLyBbIG9iajMgXVxuXHQgKlxuXHQgKiBgYGBcblx0ICpcblx0ICogU3RvbGVuIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM5NDc0Ny9qYXZhc2NyaXB0LWN1cnJ5LWZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSBmblxuXHQgKiBAcmV0dXJucyB7KnxmdW5jdGlvbigpOiAoKnxhbnkpfVxuXHQgKi9cblx0ZnVuY3Rpb24gY3VycnkoZm4pIHtcblx0ICAgIHZhciBpbml0aWFsX2FyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7XG5cdCAgICB2YXIgZnVuY19hcmdzX2xlbmd0aCA9IGZuLmxlbmd0aDtcblx0ICAgIGZ1bmN0aW9uIGN1cnJpZWQoYXJncykge1xuXHQgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSBmdW5jX2FyZ3NfbGVuZ3RoKVxuXHQgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGN1cnJpZWQoYXJncy5jb25jYXQoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSkpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3VycmllZChpbml0aWFsX2FyZ3MpO1xuXHR9XG5cdGV4cG9ydHMuY3VycnkgPSBjdXJyeTtcblx0LyoqXG5cdCAqIEdpdmVuIGEgdmFyYXJncyBsaXN0IG9mIGZ1bmN0aW9ucywgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY29tcG9zZXMgdGhlIGFyZ3VtZW50IGZ1bmN0aW9ucywgcmlnaHQtdG8tbGVmdFxuXHQgKiBnaXZlbjogZih4KSwgZyh4KSwgaCh4KVxuXHQgKiBsZXQgY29tcG9zZWQgPSBjb21wb3NlKGYsZyxoKVxuXHQgKiB0aGVuLCBjb21wb3NlZCBpczogZihnKGgoeCkpKVxuXHQgKi9cblx0ZnVuY3Rpb24gY29tcG9zZSgpIHtcblx0ICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHQgICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgaSA9IHN0YXJ0LCByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHdoaWxlIChpLS0pXG5cdCAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHR9XG5cdGV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7XG5cdC8qKlxuXHQgKiBHaXZlbiBhIHZhcmFyZ3MgbGlzdCBvZiBmdW5jdGlvbnMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIGNvbXBvc2VzIHRoZSBhcmd1bWVudCBmdW5jdGlvbnMsIGxlZnQtdG8tcmlnaHRcblx0ICogZ2l2ZW46IGYoeCksIGcoeCksIGgoeClcblx0ICogbGV0IHBpcGVkID0gcGlwZShmLGcsaCk7XG5cdCAqIHRoZW4sIHBpcGVkIGlzOiBoKGcoZih4KSkpXG5cdCAqL1xuXHRmdW5jdGlvbiBwaXBlKCkge1xuXHQgICAgdmFyIGZ1bmNzID0gW107XG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIGZ1bmNzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLnJldmVyc2UoKSk7XG5cdH1cblx0ZXhwb3J0cy5waXBlID0gcGlwZTtcblx0LyoqXG5cdCAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGF0IHByb3BlcnR5IGZyb20gYW4gb2JqZWN0XG5cdCAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG5cdCAqIGxldCBnZXROYW1lID0gcHJvcChcIm5hbWVcIik7XG5cdCAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG5cdCAqL1xuXHRleHBvcnRzLnByb3AgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXTsgfTsgfTtcblx0LyoqXG5cdCAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSBhbmQgYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gYmFzZWQgb24gd2hldGhlclxuXHQgKiB0aGUgcGFzc2VkIG9iamVjdCBoYXMgYSBwcm9wZXJ0eSB0aGF0IG1hdGNoZXMgdGhlIHZhbHVlXG5cdCAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG5cdCAqIGxldCBnZXROYW1lID0gcHJvcEVxKFwibmFtZVwiLCBcImJsYXJnXCIpO1xuXHQgKiBnZXROYW1lKG9iaikgPT09IHRydWVcblx0ICovXG5cdGV4cG9ydHMucHJvcEVxID0gY3VycnkoZnVuY3Rpb24gKG5hbWUsIHZhbCwgb2JqKSB7IHJldHVybiBvYmogJiYgb2JqW25hbWVdID09PSB2YWw7IH0pO1xuXHQvKipcblx0ICogR2l2ZW4gYSBkb3R0ZWQgcHJvcGVydHkgbmFtZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG5lc3RlZCBwcm9wZXJ0eSBmcm9tIGFuIG9iamVjdCwgb3IgdW5kZWZpbmVkXG5cdCAqIGxldCBvYmogPSB7IGlkOiAxLCBuZXN0ZWRPYmo6IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfSwgfTtcblx0ICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmVzdGVkT2JqLm5hbWVcIik7XG5cdCAqIGdldE5hbWUob2JqKSA9PT0gXCJibGFyZ1wiXG5cdCAqIGxldCBwcm9wTm90Rm91bmQgPSBwcm9wKFwidGhpcy5wcm9wZXJ0eS5kb2VzbnQuZXhpc3RcIik7XG5cdCAqIHByb3BOb3RGb3VuZChvYmopID09PSB1bmRlZmluZWRcblx0ICovXG5cdGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcGlwZS5hcHBseShudWxsLCBuYW1lLnNwbGl0KFwiLlwiKS5tYXAoZXhwb3J0cy5wcm9wKSk7IH07XG5cdC8qKlxuXHQgKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRydXRoeSBvciBmYWxzZXkgdmFsdWUsIHJldHVybnMgYVxuXHQgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9wcG9zaXRlIChmYWxzZXkgb3IgdHJ1dGh5KSB2YWx1ZSBnaXZlbiB0aGUgc2FtZSBpbnB1dHNcblx0ICovXG5cdGV4cG9ydHMubm90ID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuICFmbi5hcHBseShudWxsLCBhcmdzKTtcblx0fTsgfTtcblx0LyoqXG5cdCAqIEdpdmVuIHR3byBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZXMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1dGh5XG5cdCAqIGlmIGJvdGggZnVuY3Rpb25zIHJldHVybiB0cnV0aHkgZm9yIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0ICovXG5cdGZ1bmN0aW9uIGFuZChmbjEsIGZuMikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgJiYgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHQgICAgfTtcblx0fVxuXHRleHBvcnRzLmFuZCA9IGFuZDtcblx0LyoqXG5cdCAqIEdpdmVuIHR3byBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZXMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1dGh5XG5cdCAqIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZnVuY3Rpb25zIHJldHVybnMgdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdCAqL1xuXHRmdW5jdGlvbiBvcihmbjEsIGZuMikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgfHwgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHQgICAgfTtcblx0fVxuXHRleHBvcnRzLm9yID0gb3I7XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG1hdGNoIGEgcHJlZGljYXRlIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSBmbjEgYSBwcmVkaWNhdGUgZnVuY3Rpb24gYGZuMWBcblx0ICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcnJheSBhbmQgcmV0dXJucyB0cnVlIGlmIGBmbjFgIGlzIHRydWUgZm9yIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcblx0ICovXG5cdGV4cG9ydHMuYWxsID0gZnVuY3Rpb24gKGZuMSkgeyByZXR1cm4gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYiwgeCkgeyByZXR1cm4gYiAmJiAhIWZuMSh4KTsgfSwgdHJ1ZSk7IH07IH07XG5cdGV4cG9ydHMuYW55ID0gZnVuY3Rpb24gKGZuMSkgeyByZXR1cm4gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYiwgeCkgeyByZXR1cm4gYiB8fCAhIWZuMSh4KTsgfSwgZmFsc2UpOyB9OyB9O1xuXHRleHBvcnRzLm5vbmUgPSBleHBvcnRzLm5vdChleHBvcnRzLmFueSk7XG5cdC8qKiBHaXZlbiBhIGNsYXNzLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgb2YgdGhhdCBjbGFzcyAqL1xuXHRleHBvcnRzLmlzID0gZnVuY3Rpb24gKGN0b3IpIHsgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgPT09IGN0b3IgfHwgb2JqIGluc3RhbmNlb2YgY3Rvcik7IH07IH07XG5cdC8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFub3RoZXIgdmFsdWUgaXMgPT09IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSAqL1xuXHRleHBvcnRzLmVxID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gZnVuY3Rpb24gKG90aGVyKSB7IHJldHVybiB2YWwgPT09IG90aGVyOyB9OyB9O1xuXHQvKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlICovXG5cdGV4cG9ydHMudmFsID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY7IH07IH07XG5cdGZ1bmN0aW9uIGludm9rZShmbk5hbWUsIGFyZ3MpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmpbZm5OYW1lXS5hcHBseShvYmosIGFyZ3MpOyB9O1xuXHR9XG5cdGV4cG9ydHMuaW52b2tlID0gaW52b2tlO1xuXHQvKipcblx0ICogU29ydGEgbGlrZSBQYXR0ZXJuIE1hdGNoaW5nIChhIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgY29uZGl0aW9uYWwgY29uc3RydWN0KVxuXHQgKlxuXHQgKiBTZWUgaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9QYXR0ZXJuTWF0Y2hpbmdcblx0ICpcblx0ICogVGhpcyBpcyBhIGNvbmRpdGlvbmFsIGNvbnN0cnVjdCB3aGljaCBhbGxvd3MgYSBzZXJpZXMgb2YgcHJlZGljYXRlcyBhbmQgb3V0cHV0IGZ1bmN0aW9uc1xuXHQgKiB0byBiZSBjaGVja2VkIGFuZCB0aGVuIGFwcGxpZWQuICBFYWNoIHByZWRpY2F0ZSByZWNlaXZlcyB0aGUgaW5wdXQuICBJZiB0aGUgcHJlZGljYXRlXG5cdCAqIHJldHVybnMgdHJ1dGh5LCB0aGVuIGl0cyBtYXRjaGluZyBvdXRwdXQgZnVuY3Rpb24gKG1hcHBpbmcgZnVuY3Rpb24pIGlzIHByb3ZpZGVkIHdpdGhcblx0ICogdGhlIGlucHV0IGFuZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHJldHVybmVkLlxuXHQgKlxuXHQgKiBFYWNoIGNvbWJpbmF0aW9uICgyLXR1cGxlKSBvZiBwcmVkaWNhdGUgKyBvdXRwdXQgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCBpbiBhbiBhcnJheVxuXHQgKiBvZiBzaXplIDI6IFsgcHJlZGljYXRlLCBtYXBGbiBdXG5cdCAqXG5cdCAqIFRoZXNlIDItdHVwbGVzIHNob3VsZCBiZSBwdXQgaW4gYW4gb3V0ZXIgYXJyYXkuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiAvLyBIZXJlJ3MgYSAyLXR1cGxlIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBpc1N0cmluZyBwcmVkaWNhdGVcblx0ICogLy8gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnB1dFxuXHQgKiBsZXQgZmlyc3RUdXBsZSA9IFsgYW5ndWxhci5pc1N0cmluZywgKGlucHV0KSA9PiBgSGVyZXMgeW91ciBzdHJpbmcgJHtpbnB1dH1gIF07XG5cdCAqXG5cdCAqIC8vIFNlY29uZCB0dXBsZTogcHJlZGljYXRlIFwiaXNOdW1iZXJcIiwgbWFwZm4gcmV0dXJucyBhIGRlc2NyaXB0aW9uXG5cdCAqIGxldCBzZWNvbmRUdXBsZSA9IFsgYW5ndWxhci5pc051bWJlciwgKGlucHV0KSA9PiBgKCR7aW5wdXR9KSBUaGF0J3MgYSBudW1iZXIhYCBdO1xuXHQgKlxuXHQgKiBsZXQgdGhpcmQgPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IG51bGwsICAoaW5wdXQpID0+IGBPaCwgbnVsbC4uLmAgXTtcblx0ICpcblx0ICogbGV0IGZvdXJ0aCA9IFsgKGlucHV0KSA9PiBpbnB1dCA9PT0gdW5kZWZpbmVkLCAgKGlucHV0KSA9PiBgbm90ZGVmaW5lZGAgXTtcblx0ICpcblx0ICogbGV0IGRlc2NyaXB0aW9uT2YgPSBwYXR0ZXJuKFsgZmlyc3RUdXBsZSwgc2Vjb25kVHVwbGUsIHRoaXJkLCBmb3VydGggXSk7XG5cdCAqXG5cdCAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YodW5kZWZpbmVkKSk7IC8vICdub3RkZWZpbmVkJ1xuXHQgKiBjb25zb2xlLmxvZyhkZXNjcmlwdGlvbk9mKDU1KSk7IC8vICcoNTUpIFRoYXQncyBhIG51bWJlciEnXG5cdCAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YoXCJmb29cIikpOyAvLyAnSGVyZSdzIHlvdXIgc3RyaW5nIGZvbydcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBwYXJhbSBzdHJ1Y3QgQSAyRCBhcnJheS4gIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgc2hvdWxkIGJlIGFuIGFycmF5LCBhIDItdHVwbGUsXG5cdCAqIHdpdGggYSBQcmVkaWNhdGUgYW5kIGEgbWFwcGluZy9vdXRwdXQgZnVuY3Rpb25cblx0ICogQHJldHVybnMge2Z1bmN0aW9uKGFueSk6ICp9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJ1Y3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHN0cnVjdFtpXVswXSh4KSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RbaV1bMV0oeCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fVxuXHRleHBvcnRzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogVGhpcyBtb2R1bGUgaXMgYSBzdHViIGZvciBjb3JlIHNlcnZpY2VzIHN1Y2ggYXMgRGVwZW5kZW5jeSBJbmplY3Rpb24gb3IgQnJvd3NlciBMb2NhdGlvbi5cblx0ICogQ29yZSBzZXJ2aWNlcyBtYXkgYmUgaW1wbGVtZW50ZWQgYnkgYSBzcGVjaWZpYyBmcmFtZXdvcmssIHN1Y2ggYXMgbmcxIG9yIG5nMiwgb3IgYmUgcHVyZSBqYXZhc2NyaXB0LlxuXHQgKlxuXHQgKiBAbW9kdWxlIGNvbW1vblxuXHQgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBmb3IgdHlwZWRvYyAqL1xuXHQvL2ltcG9ydCB7SVFTZXJ2aWNlfSBmcm9tIFwiYW5ndWxhclwiO1xuXHQvL2ltcG9ydCB7SUluamVjdG9yU2VydmljZX0gZnJvbSBcImFuZ3VsYXJcIjtcblx0dmFyIG5vdEltcGxlbWVudGVkID0gZnVuY3Rpb24gKGZubmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKGZubmFtZSArIFwiKCk6IE5vIGNvcmVzZXJ2aWNlcyBpbXBsZW1lbnRhdGlvbiBmb3IgVUktUm91dGVyIGlzIGxvYWRlZC4gWW91IHNob3VsZCBpbmNsdWRlIG9uZSBvZjogWydhbmd1bGFyMS5qcyddXCIpO1xuXHR9OyB9O1xuXHR2YXIgc2VydmljZXMgPSB7XG5cdCAgICAkcTogdW5kZWZpbmVkLFxuXHQgICAgJGluamVjdG9yOiB1bmRlZmluZWQsXG5cdCAgICBsb2NhdGlvbjoge30sXG5cdCAgICBsb2NhdGlvbkNvbmZpZzoge30sXG5cdCAgICB0ZW1wbGF0ZToge31cblx0fTtcblx0ZXhwb3J0cy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuXHRbXCJyZXBsYWNlXCIsIFwidXJsXCIsIFwicGF0aFwiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgXCJvbkNoYW5nZVwiXVxuXHQgICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2VydmljZXMubG9jYXRpb25ba2V5XSA9IG5vdEltcGxlbWVudGVkKGtleSk7IH0pO1xuXHRbXCJwb3J0XCIsIFwicHJvdG9jb2xcIiwgXCJob3N0XCIsIFwiYmFzZUhyZWZcIiwgXCJodG1sNU1vZGVcIiwgXCJoYXNoUHJlZml4XCJdXG5cdCAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBzZXJ2aWNlcy5sb2NhdGlvbkNvbmZpZ1trZXldID0gbm90SW1wbGVtZW50ZWQoa2V5KTsgfSk7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0dmFyIEdsb2IgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gR2xvYih0ZXh0KSB7XG5cdCAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcblx0ICAgICAgICB0aGlzLmdsb2IgPSB0ZXh0LnNwbGl0KCcuJyk7XG5cdCAgICB9XG5cdCAgICBHbG9iLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICB2YXIgc2VnbWVudHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgLy8gbWF0Y2ggc2luZ2xlIHN0YXJzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmdsb2IubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmdsb2JbaV0gPT09ICcqJylcblx0ICAgICAgICAgICAgICAgIHNlZ21lbnRzW2ldID0gJyonO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBtYXRjaCBncmVlZHkgc3RhcnRzXG5cdCAgICAgICAgaWYgKHRoaXMuZ2xvYlswXSA9PT0gJyoqJykge1xuXHQgICAgICAgICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKHNlZ21lbnRzLmluZGV4T2YodGhpcy5nbG9iWzFdKSk7XG5cdCAgICAgICAgICAgIHNlZ21lbnRzLnVuc2hpZnQoJyoqJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIG1hdGNoIGdyZWVkeSBlbmRzXG5cdCAgICAgICAgaWYgKHRoaXMuZ2xvYlt0aGlzLmdsb2IubGVuZ3RoIC0gMV0gPT09ICcqKicpIHtcblx0ICAgICAgICAgICAgc2VnbWVudHMuc3BsaWNlKHNlZ21lbnRzLmluZGV4T2YodGhpcy5nbG9iW3RoaXMuZ2xvYi5sZW5ndGggLSAyXSkgKyAxLCBOdW1iZXIuTUFYX1ZBTFVFKTtcblx0ICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnKionKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuZ2xvYi5sZW5ndGggIT0gc2VnbWVudHMubGVuZ3RoKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oJycpID09PSB0aGlzLmdsb2Iuam9pbignJyk7XG5cdCAgICB9O1xuXHQgICAgR2xvYi5pcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdCAgICAgICAgcmV0dXJuIHRleHQuaW5kZXhPZignKicpID4gLTE7XG5cdCAgICB9O1xuXHQgICAgR2xvYi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuaXModGV4dCkpXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIHJldHVybiBuZXcgR2xvYih0ZXh0KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gR2xvYjtcblx0fSgpKTtcblx0ZXhwb3J0cy5HbG9iID0gR2xvYjtcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIFF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFF1ZXVlKF9pdGVtcywgX2xpbWl0KSB7XG5cdCAgICAgICAgaWYgKF9pdGVtcyA9PT0gdm9pZCAwKSB7IF9pdGVtcyA9IFtdOyB9XG5cdCAgICAgICAgaWYgKF9saW1pdCA9PT0gdm9pZCAwKSB7IF9saW1pdCA9IG51bGw7IH1cblx0ICAgICAgICB0aGlzLl9pdGVtcyA9IF9pdGVtcztcblx0ICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcblx0ICAgIH1cblx0ICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9pdGVtcztcblx0ICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuXHQgICAgICAgIGlmICh0aGlzLl9saW1pdCAmJiBpdGVtcy5sZW5ndGggPiB0aGlzLl9saW1pdClcblx0ICAgICAgICAgICAgaXRlbXMuc2hpZnQoKTtcblx0ICAgICAgICByZXR1cm4gaXRlbTtcblx0ICAgIH07XG5cdCAgICBRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5zaXplKCkpXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XG5cdCAgICB9O1xuXHQgICAgUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faXRlbXM7XG5cdCAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcblx0ICAgICAgICByZXR1cm4gY3VycmVudDtcblx0ICAgIH07XG5cdCAgICBRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIFF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHZhciBpZHggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXHQgICAgICAgIHJldHVybiBpZHggPiAtMSAmJiB0aGlzLl9pdGVtcy5zcGxpY2UoaWR4LCAxKVswXTtcblx0ICAgIH07XG5cdCAgICBRdWV1ZS5wcm90b3R5cGUucGVla1RhaWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuXHQgICAgfTtcblx0ICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrSGVhZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5zaXplKCkpXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1swXTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUXVldWU7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqIEBtb2R1bGUgY29tbW9uX3N0cmluZ3MgKi8gLyoqICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHJlamVjdEZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdHJhbnNpdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciByZXNvbHZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgc2hvcnRlbmVkIHRvIGEgbWF4aW11bSBsZW5ndGhcblx0ICpcblx0ICogSWYgdGhlIHN0cmluZyBpcyBhbHJlYWR5IGxlc3MgdGhhbiB0aGUgYG1heGAgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cblx0ICogRWxzZSByZXR1cm4gdGhlIHN0cmluZywgc2hvcnRlbmVkIHRvIGBtYXggLSAzYCBhbmQgYXBwZW5kIHRocmVlIGRvdHMgKFwiLi4uXCIpLlxuXHQgKlxuXHQgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJldHVyblxuXHQgKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcblx0ICovXG5cdGZ1bmN0aW9uIG1heExlbmd0aChtYXgsIHN0cikge1xuXHQgICAgaWYgKHN0ci5sZW5ndGggPD0gbWF4KVxuXHQgICAgICAgIHJldHVybiBzdHI7XG5cdCAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBtYXggLSAzKSArIFwiLi4uXCI7XG5cdH1cblx0ZXhwb3J0cy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nLCB3aXRoIHNwYWNlcyBhZGRlZCB0byB0aGUgZW5kLCB1cCB0byBhIGRlc2lyZWQgc3RyIGxlbmd0aFxuXHQgKlxuXHQgKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gdGhlIGRlc2lyZWQgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cblx0ICogRWxzZSByZXR1cm5zIHRoZSBzdHJpbmcsIHdpdGggZXh0cmEgc3BhY2VzIG9uIHRoZSBlbmQsIHN1Y2ggdGhhdCBpdCByZWFjaGVzIGBsZW5ndGhgIGNoYXJhY3RlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSBsZW5ndGggdGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG5cdCAqIEBwYXJhbSBzdHIgdGhlIGlucHV0IHN0cmluZ1xuXHQgKi9cblx0ZnVuY3Rpb24gcGFkU3RyaW5nKGxlbmd0aCwgc3RyKSB7XG5cdCAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aClcblx0ICAgICAgICBzdHIgKz0gXCIgXCI7XG5cdCAgICByZXR1cm4gc3RyO1xuXHR9XG5cdGV4cG9ydHMucGFkU3RyaW5nID0gcGFkU3RyaW5nO1xuXHRleHBvcnRzLmtlYm9iU3RyaW5nID0gZnVuY3Rpb24gKGNhbWVsQ2FzZSkgeyByZXR1cm4gY2FtZWxDYXNlLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKCQxKSB7IHJldHVybiBcIi1cIiArICQxLnRvTG93ZXJDYXNlKCk7IH0pOyB9O1xuXHRmdW5jdGlvbiBfdG9Kc29uKG9iaikge1xuXHQgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG5cdH1cblx0ZnVuY3Rpb24gX2Zyb21Kc29uKGpzb24pIHtcblx0ICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoanNvbikgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcblx0fVxuXHRmdW5jdGlvbiBwcm9taXNlVG9TdHJpbmcocCkge1xuXHQgICAgaWYgKGhvZl8xLmlzKHJlamVjdEZhY3RvcnlfMS5UcmFuc2l0aW9uUmVqZWN0aW9uKShwLnJlYXNvbikpXG5cdCAgICAgICAgcmV0dXJuIHAucmVhc29uLnRvU3RyaW5nKCk7XG5cdCAgICByZXR1cm4gXCJQcm9taXNlKFwiICsgSlNPTi5zdHJpbmdpZnkocCkgKyBcIilcIjtcblx0fVxuXHRmdW5jdGlvbiBmdW5jdGlvblRvU3RyaW5nKGZuKSB7XG5cdCAgICB2YXIgZm5TdHIgPSBmblRvU3RyaW5nKGZuKTtcblx0ICAgIHZhciBuYW1lZEZ1bmN0aW9uTWF0Y2ggPSBmblN0ci5tYXRjaCgvXihmdW5jdGlvbiBbXiBdK1xcKFteKV0qXFwpKS8pO1xuXHQgICAgcmV0dXJuIG5hbWVkRnVuY3Rpb25NYXRjaCA/IG5hbWVkRnVuY3Rpb25NYXRjaFsxXSA6IGZuU3RyO1xuXHR9XG5cdGV4cG9ydHMuZnVuY3Rpb25Ub1N0cmluZyA9IGZ1bmN0aW9uVG9TdHJpbmc7XG5cdGZ1bmN0aW9uIGZuVG9TdHJpbmcoZm4pIHtcblx0ICAgIHZhciBfZm4gPSBwcmVkaWNhdGVzXzEuaXNBcnJheShmbikgPyBmbi5zbGljZSgtMSlbMF0gOiBmbjtcblx0ICAgIHJldHVybiBfZm4gJiYgX2ZuLnRvU3RyaW5nKCkgfHwgXCJ1bmRlZmluZWRcIjtcblx0fVxuXHRleHBvcnRzLmZuVG9TdHJpbmcgPSBmblRvU3RyaW5nO1xuXHR2YXIgc3RyaW5naWZ5UGF0dGVybiA9IGhvZl8xLnBhdHRlcm4oW1xuXHQgICAgW2hvZl8xLm5vdChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKSwgaG9mXzEudmFsKFwidW5kZWZpbmVkXCIpXSxcblx0ICAgIFtwcmVkaWNhdGVzXzEuaXNOdWxsLCBob2ZfMS52YWwoXCJudWxsXCIpXSxcblx0ICAgIFtwcmVkaWNhdGVzXzEuaXNQcm9taXNlLCBwcm9taXNlVG9TdHJpbmddLFxuXHQgICAgW2hvZl8xLmlzKHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxuXHQgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgaG9mXzEuaW52b2tlKFwidG9TdHJpbmdcIildLFxuXHQgICAgW3ByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUsIGZ1bmN0aW9uVG9TdHJpbmddLFxuXHQgICAgW2hvZl8xLnZhbCh0cnVlKSwgY29tbW9uXzEuaWRlbnRpdHldXG5cdF0pO1xuXHRmdW5jdGlvbiBzdHJpbmdpZnkobykge1xuXHQgICAgdmFyIHNlZW4gPSBbXTtcblx0ICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWwpIHtcblx0ICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KHZhbCkpIHtcblx0ICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWwpICE9PSAtMSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiAnW2NpcmN1bGFyIHJlZl0nO1xuXHQgICAgICAgICAgICBzZWVuLnB1c2godmFsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm4odmFsKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHsgcmV0dXJuIGZvcm1hdCh2YWwpOyB9KS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG5cdH1cblx0ZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiogQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIGNvcmVzZXJ2aWNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIHN0cmluZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdChmdW5jdGlvbiAoUmVqZWN0VHlwZSkge1xuXHQgICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiU1VQRVJTRURFRFwiXSA9IDJdID0gXCJTVVBFUlNFREVEXCI7XG5cdCAgICBSZWplY3RUeXBlW1JlamVjdFR5cGVbXCJBQk9SVEVEXCJdID0gM10gPSBcIkFCT1JURURcIjtcblx0ICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklOVkFMSURcIl0gPSA0XSA9IFwiSU5WQUxJRFwiO1xuXHQgICAgUmVqZWN0VHlwZVtSZWplY3RUeXBlW1wiSUdOT1JFRFwiXSA9IDVdID0gXCJJR05PUkVEXCI7XG5cdH0pKGV4cG9ydHMuUmVqZWN0VHlwZSB8fCAoZXhwb3J0cy5SZWplY3RUeXBlID0ge30pKTtcblx0dmFyIFJlamVjdFR5cGUgPSBleHBvcnRzLlJlamVjdFR5cGU7XG5cdHZhciBUcmFuc2l0aW9uUmVqZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25SZWplY3Rpb24odHlwZSwgbWVzc2FnZSwgZGV0YWlsKSB7XG5cdCAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHtcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcblx0ICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIFRyYW5zaXRpb25SZWplY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBkZXRhaWxTdHJpbmcgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAmJiBkLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID8gZC50b1N0cmluZygpIDogc3RyaW5nc18xLnN0cmluZ2lmeShkKTsgfTtcblx0ICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZSwgbWVzc2FnZSA9IHRoaXMubWVzc2FnZSwgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcblx0ICAgICAgICByZXR1cm4gXCJUcmFuc2l0aW9uUmVqZWN0aW9uKHR5cGU6IFwiICsgdHlwZSArIFwiLCBtZXNzYWdlOiBcIiArIG1lc3NhZ2UgKyBcIiwgZGV0YWlsOiBcIiArIGRldGFpbCArIFwiKVwiO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUcmFuc2l0aW9uUmVqZWN0aW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLlRyYW5zaXRpb25SZWplY3Rpb24gPSBUcmFuc2l0aW9uUmVqZWN0aW9uO1xuXHR2YXIgUmVqZWN0RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZWplY3RGYWN0b3J5KCkge1xuXHQgICAgfVxuXHQgICAgUmVqZWN0RmFjdG9yeS5wcm90b3R5cGUuc3VwZXJzZWRlZCA9IGZ1bmN0aW9uIChkZXRhaWwsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gc3VwZXJzZWRlZCBieSBhIGRpZmZlcmVudCB0cmFuc2l0aW9uIChzZWUgZGV0YWlsKS5cIjtcblx0ICAgICAgICB2YXIgcmVhc29uID0gbmV3IFRyYW5zaXRpb25SZWplY3Rpb24oUmVqZWN0VHlwZS5TVVBFUlNFREVELCBtZXNzYWdlLCBkZXRhaWwpO1xuXHQgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVkaXJlY3RlZCkge1xuXHQgICAgICAgICAgICByZWFzb24ucmVkaXJlY3RlZCA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KHJlYXNvbiksIHsgcmVhc29uOiByZWFzb24gfSk7XG5cdCAgICB9O1xuXHQgICAgUmVqZWN0RmFjdG9yeS5wcm90b3R5cGUucmVkaXJlY3RlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zdXBlcnNlZGVkKGRldGFpbCwgeyByZWRpcmVjdGVkOiB0cnVlIH0pO1xuXHQgICAgfTtcblx0ICAgIFJlamVjdEZhY3RvcnkucHJvdG90eXBlLmludmFsaWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG5cdCAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRoaXMgdHJhbnNpdGlvbiBpcyBpbnZhbGlkIChzZWUgZGV0YWlsKVwiO1xuXHQgICAgICAgIHZhciByZWFzb24gPSBuZXcgVHJhbnNpdGlvblJlamVjdGlvbihSZWplY3RUeXBlLklOVkFMSUQsIG1lc3NhZ2UsIGRldGFpbCk7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QocmVhc29uKSwgeyByZWFzb246IHJlYXNvbiB9KTtcblx0ICAgIH07XG5cdCAgICBSZWplY3RGYWN0b3J5LnByb3RvdHlwZS5pZ25vcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuXHQgICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZC5cIjtcblx0ICAgICAgICB2YXIgcmVhc29uID0gbmV3IFRyYW5zaXRpb25SZWplY3Rpb24oUmVqZWN0VHlwZS5JR05PUkVELCBtZXNzYWdlLCBkZXRhaWwpO1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KHJlYXNvbiksIHsgcmVhc29uOiByZWFzb24gfSk7XG5cdCAgICB9O1xuXHQgICAgUmVqZWN0RmFjdG9yeS5wcm90b3R5cGUuYWJvcnRlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcblx0ICAgICAgICAvLyBUT0RPIHRoaW5rIGFib3V0IGhvdyB0byBlbmNhcHN1bGF0ZSBhbiBFcnJvcigpIG9iamVjdFxuXHQgICAgICAgIHZhciBtZXNzYWdlID0gXCJUaGUgdHJhbnNpdGlvbiBoYXMgYmVlbiBhYm9ydGVkLlwiO1xuXHQgICAgICAgIHZhciByZWFzb24gPSBuZXcgVHJhbnNpdGlvblJlamVjdGlvbihSZWplY3RUeXBlLkFCT1JURUQsIG1lc3NhZ2UsIGRldGFpbCk7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QocmVhc29uKSwgeyByZWFzb246IHJlYXNvbiB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUmVqZWN0RmFjdG9yeTtcblx0fSgpKTtcblx0ZXhwb3J0cy5SZWplY3RGYWN0b3J5ID0gUmVqZWN0RmFjdG9yeTtcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgdHJhY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGhvZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIG1vZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdHZhciBub2RlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblx0dmFyIHBhdGhGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0dmFyIG1vZHVsZV8yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdHZhciBtb2R1bGVfMyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgbW9kdWxlXzQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0dmFyIHRyYW5zaXRpb25Db3VudCA9IDAsIFJFSkVDVCA9IG5ldyBtb2R1bGVfMS5SZWplY3RGYWN0b3J5KCk7XG5cdHZhciBzdGF0ZVNlbGYgPSBob2ZfMS5wcm9wKFwic2VsZlwiKTtcblx0LyoqXG5cdCAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gc3RhdGVzLlxuXHQgKlxuXHQgKiBDb250YWlucyBhbGwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdG8vZnJvbSBzdGF0ZXMsIHBhcmFtZXRlcnMsIHJlc29sdmVzLCBhcyB3ZWxsIGFzIHRoZVxuXHQgKiBsaXN0IG9mIHN0YXRlcyBiZWluZyBlbnRlcmVkIGFuZCBleGl0ZWQgYXMgYSByZXN1bHQgb2YgdGhpcyB0cmFuc2l0aW9uLlxuXHQgKi9cblx0dmFyIFRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgbmV3IFRyYW5zaXRpb24gb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIElmIHRoZSB0YXJnZXQgc3RhdGUgaXMgbm90IHZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24uXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBwYXRoIG9mIFtbTm9kZV1dcyBmcm9tIHdoaWNoIHRoZSB0cmFuc2l0aW9uIGlzIGxlYXZpbmcuICBUaGUgbGFzdCBub2RlIGluIHRoZSBgZnJvbVBhdGhgXG5cdCAgICAgKiAgICAgICAgZW5jYXBzdWxhdGVzIHRoZSBcImZyb20gc3RhdGVcIi5cblx0ICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSBUaGUgdGFyZ2V0IHN0YXRlIGFuZCBwYXJhbWV0ZXJzIGJlaW5nIHRyYW5zaXRpb25lZCB0byAoYWxzbywgdGhlIHRyYW5zaXRpb24gb3B0aW9ucylcblx0ICAgICAqIEBwYXJhbSBfdHJhbnNpdGlvblNlcnZpY2UgVGhlIFRyYW5zaXRpb24gU2VydmljZSBpbnN0YW5jZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBUcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgX3RyYW5zaXRpb25TZXJ2aWNlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLl90cmFuc2l0aW9uU2VydmljZSA9IF90cmFuc2l0aW9uU2VydmljZTtcblx0ICAgICAgICB0aGlzLl9kZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVGhpcyBwcm9taXNlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkIGJhc2VkIG9uIHRoZSBvdXRjb21lIG9mIHRoZSBUcmFuc2l0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuXHQgICAgICAgICAqIFdoZW4gdGhlIHRyYW5zaXRpb24gaXMgdW5zdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHRoZSBbW1RyYW5zaXRpb25SZWplY3Rpb25dXSBvciBqYXZhc2NyaXB0IGVycm9yXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5fZGVmZXJyZWQucHJvbWlzZTtcblx0ICAgICAgICB0aGlzLnRyZWVDaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RyZWVDaGFuZ2VzOyB9O1xuXHQgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcyA9PT0gX3RoaXMuX29wdGlvbnMuY3VycmVudCgpOyB9O1xuXHQgICAgICAgIGlmICghdGFyZ2V0U3RhdGUudmFsaWQoKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1ha2VzIHRoZSBUcmFuc2l0aW9uIGluc3RhbmNlIGEgaG9vayByZWdpc3RyeSAob25TdGFydCwgZXRjKVxuXHQgICAgICAgIG1vZHVsZV8xLkhvb2tSZWdpc3RyeS5taXhpbihuZXcgbW9kdWxlXzEuSG9va1JlZ2lzdHJ5KCksIHRoaXMpO1xuXHQgICAgICAgIC8vIGN1cnJlbnQoKSBpcyBhc3N1bWVkIHRvIGNvbWUgZnJvbSB0YXJnZXRTdGF0ZS5vcHRpb25zLCBidXQgcHJvdmlkZSBhIG5haXZlIGltcGxlbWVudGF0aW9uIG90aGVyd2lzZS5cblx0ICAgICAgICB0aGlzLl9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHsgY3VycmVudDogaG9mXzEudmFsKHRoaXMpIH0sIHRhcmdldFN0YXRlLm9wdGlvbnMoKSk7XG5cdCAgICAgICAgdGhpcy4kaWQgPSB0cmFuc2l0aW9uQ291bnQrKztcblx0ICAgICAgICB2YXIgdG9QYXRoID0gcGF0aEZhY3RvcnlfMS5QYXRoRmFjdG9yeS5idWlsZFRvUGF0aChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpO1xuXHQgICAgICAgIHRvUGF0aCA9IHBhdGhGYWN0b3J5XzEuUGF0aEZhY3RvcnkuYXBwbHlWaWV3Q29uZmlncyhfdHJhbnNpdGlvblNlcnZpY2UuJHZpZXcsIHRvUGF0aCk7XG5cdCAgICAgICAgdGhpcy5fdHJlZUNoYW5nZXMgPSBwYXRoRmFjdG9yeV8xLlBhdGhGYWN0b3J5LnRyZWVDaGFuZ2VzKGZyb21QYXRoLCB0b1BhdGgsIHRoaXMuX29wdGlvbnMucmVsb2FkU3RhdGUpO1xuXHQgICAgICAgIHBhdGhGYWN0b3J5XzEuUGF0aEZhY3RvcnkuYmluZFRyYW5zaXRpb25SZXNvbHZlKHRoaXMuX3RyZWVDaGFuZ2VzLCB0aGlzKTtcblx0ICAgIH1cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiRmcm9tID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20pLnN0YXRlO1xuXHQgICAgfTtcblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLiR0byA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykuc3RhdGU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBcImZyb20gc3RhdGVcIlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZSBvYmplY3QgZm9yIHRoZSBUcmFuc2l0aW9uJ3MgXCJmcm9tIHN0YXRlXCIuXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuJGZyb20oKS5zZWxmO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyB0aGUgXCJ0byBzdGF0ZVwiXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMgVGhlIHN0YXRlIG9iamVjdCBmb3IgdGhlIFRyYW5zaXRpb24ncyB0YXJnZXQgc3RhdGUgKFwidG8gc3RhdGVcIikuXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLiR0bygpLnNlbGY7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHRyYW5zaXRpb25zIGFyZSBlcXVpdmFsZW50LlxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdCAgICAgICAgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIC8vIFRPRE86IEFsc28gY29tcGFyZSBwYXJhbWV0ZXJzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmlzKHsgdG86IGNvbXBhcmUuJHRvKCkubmFtZSwgZnJvbTogY29tcGFyZS4kZnJvbSgpLm5hbWUgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAhKChjb21wYXJlLnRvICYmICFtb2R1bGVfMS5tYXRjaFN0YXRlKHRoaXMuJHRvKCksIGNvbXBhcmUudG8pKSB8fFxuXHQgICAgICAgICAgICAoY29tcGFyZS5mcm9tICYmICFtb2R1bGVfMS5tYXRjaFN0YXRlKHRoaXMuJGZyb20oKSwgY29tcGFyZS5mcm9tKSkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0cmFuc2l0aW9uIHBhcmFtZXRlciB2YWx1ZXNcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcGF0aG5hbWUgUGljayB3aGljaCB0cmVlQ2hhbmdlcyBwYXRoIHRvIGdldCBwYXJhbWV0ZXJzIGZvcjpcblx0ICAgICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcblx0ICAgICAqIEByZXR1cm5zIHRyYW5zaXRpb24gcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIGRlc2lyZWQgcGF0aC5cblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucGFyYW1zID0gZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG5cdCAgICAgICAgaWYgKHBhdGhuYW1lID09PSB2b2lkIDApIHsgcGF0aG5hbWUgPSBcInRvXCI7IH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdLm1hcChob2ZfMS5wcm9wKFwicGFyYW1WYWx1ZXNcIikpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEdldCByZXNvbHZlZCBkYXRhXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMgYW4gb2JqZWN0IChrZXkvdmFsdWUgcGFpcnMpIHdoZXJlIGtleXMgYXJlIHJlc29sdmUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgYW55IHNldHRsZWQgcmVzb2x2ZSBkYXRhLFxuXHQgICAgICogICAgb3IgYHVuZGVmaW5lZGAgZm9yIHBlbmRpbmcgcmVzb2x2ZSBkYXRhXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlc29sdmVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMS5tYXAoY29tbW9uXzEudGFpbCh0aGlzLl90cmVlQ2hhbmdlcy50bykucmVzb2x2ZUNvbnRleHQuZ2V0UmVzb2x2YWJsZXMoKSwgZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gcmVzLmRhdGE7IH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBuZXcgcmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSByZXNvbHZlcyBhbiBbW1Jlc29sdmVEZWNsYXJhdGlvbnNdXSBvYmplY3Qgd2hpY2ggZGVzY3JpYmVzIHRoZSBuZXcgcmVzb2x2ZXNcblx0ICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgaW4gdGhlIFwidG8gcGF0aFwiIHdoaWNoIHNob3VsZCByZWNlaXZlIHRoZSBuZXcgcmVzb2x2ZXMgKG90aGVyd2lzZSwgdGhlIHJvb3Qgc3RhdGUpXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFkZFJlc29sdmVzID0gZnVuY3Rpb24gKHJlc29sdmVzLCBzdGF0ZSkge1xuXHQgICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gXCJcIjsgfVxuXHQgICAgICAgIHZhciBzdGF0ZU5hbWUgPSAodHlwZW9mIHN0YXRlID09PSBcInN0cmluZ1wiKSA/IHN0YXRlIDogc3RhdGUubmFtZTtcblx0ICAgICAgICB2YXIgdG9wYXRoID0gdGhpcy5fdHJlZUNoYW5nZXMudG87XG5cdCAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBjb21tb25fMS5maW5kKHRvcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGUubmFtZSA9PT0gc3RhdGVOYW1lOyB9KTtcblx0ICAgICAgICBjb21tb25fMS50YWlsKHRvcGF0aCkucmVzb2x2ZUNvbnRleHQuYWRkUmVzb2x2YWJsZXMobW9kdWxlXzQuUmVzb2x2YWJsZS5tYWtlUmVzb2x2YWJsZXMocmVzb2x2ZXMpLCB0YXJnZXROb2RlLnN0YXRlKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24sIGZyb20gd2hpY2ggdGhpcyB0cmFuc2l0aW9uIHdhcyByZWRpcmVjdGVkLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBUcmFuc2l0aW9uLCBvciBudWxsIGlmIHRoaXMgVHJhbnNpdGlvbiBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0aW9uXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnByZXZpb3VzIHx8IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgdGhlIHRyYW5zaXRpb24gb3B0aW9uc1xuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHRoZSBvcHRpb25zIGZvciB0aGlzIFRyYW5zaXRpb24uXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZW50ZXJlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCB3aWxsIGJlIGVudGVyZWQgZHVyaW5nIHRoaXMgdHJhbnNpdGlvbi5cblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZW50ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgZXhpdGVkLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IHdpbGwgYmUgZXhpdGVkIGR1cmluZyB0aGlzIHRyYW5zaXRpb24uXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmV4aXRpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5leGl0aW5nLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKS5yZXZlcnNlKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgcmV0YWluZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgYXJlIGFscmVhZHkgZW50ZXJlZCBmcm9tIGEgcHJldmlvdXMgVHJhbnNpdGlvbiwgdGhhdCB3aWxsIG5vdCBiZVxuXHQgICAgICogICAgZXhpdGVkIGR1cmluZyB0aGlzIFRyYW5zaXRpb25cblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucmV0YWluZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5yZXRhaW5lZCwgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgdGhlIFtbVmlld0NvbmZpZ11dcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBUcmFuc2l0aW9uXG5cdCAgICAgKlxuXHQgICAgICogRWFjaCBzdGF0ZSBjYW4gZGVmaW5lIG9uZSBvciBtb3JlIHZpZXdzICh0ZW1wbGF0ZS9jb250cm9sbGVyKSwgd2hpY2ggYXJlIGVuY2Fwc3VsYXRlZCBhcyBgVmlld0NvbmZpZ2Agb2JqZWN0cy5cblx0ICAgICAqIFRoaXMgbWV0aG9kIGZldGNoZXMgdGhlIGBWaWV3Q29uZmlnc2AgZm9yIGEgZ2l2ZW4gcGF0aCBpbiB0aGUgVHJhbnNpdGlvbiAoZS5nLiwgXCJ0b1wiIG9yIFwiZW50ZXJpbmdcIikuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHBhdGhuYW1lIHRoZSBuYW1lIG9mIHRoZSBwYXRoIHRvIGZldGNoIHZpZXdzIGZvcjpcblx0ICAgICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcblx0ICAgICAqIEBwYXJhbSBzdGF0ZSBJZiBwcm92aWRlZCwgb25seSByZXR1cm5zIHRoZSBgVmlld0NvbmZpZ2BzIGZvciBhIHNpbmdsZSBzdGF0ZSBpbiB0aGUgcGF0aFxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBWaWV3Q29uZmlnIG9iamVjdHMgZm9yIHRoZSBnaXZlbiBwYXRoLlxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52aWV3cyA9IGZ1bmN0aW9uIChwYXRobmFtZSwgc3RhdGUpIHtcblx0ICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9IFwiZW50ZXJpbmdcIjsgfVxuXHQgICAgICAgIHZhciBwYXRoID0gdGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdO1xuXHQgICAgICAgIHBhdGggPSAhc3RhdGUgPyBwYXRoIDogcGF0aC5maWx0ZXIoaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG5cdCAgICAgICAgcmV0dXJuIHBhdGgubWFwKGhvZl8xLnByb3AoXCJ2aWV3c1wiKSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUudHlwZTpUcmFuc2l0aW9uI3JlZGlyZWN0XG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLnR5cGU6VHJhbnNpdGlvblxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogQ3JlYXRlcyBhIG5ldyB0cmFuc2l0aW9uIHRoYXQgaXMgYSByZWRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCBvbmUuIFRoaXMgdHJhbnNpdGlvbiBjYW5cblx0ICAgICAqIGJlIHJldHVybmVkIGZyb20gYSBgJHRyYW5zaXRpb25zUHJvdmlkZXJgIGhvb2ssIGAkc3RhdGVgIGV2ZW50LCBvciBvdGhlciBtZXRob2QsIHRvXG5cdCAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHtUcmFuc2l0aW9ufSBSZXR1cm5zIGEgbmV3IGBUcmFuc2l0aW9uYCBpbnN0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGUpIHtcblx0ICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKCksIHRhcmdldFN0YXRlLm9wdGlvbnMoKSwgeyBwcmV2aW91czogdGhpcyB9KTtcblx0ICAgICAgICB0YXJnZXRTdGF0ZSA9IG5ldyBtb2R1bGVfMi5UYXJnZXRTdGF0ZSh0YXJnZXRTdGF0ZS5pZGVudGlmaWVyKCksIHRhcmdldFN0YXRlLiRzdGF0ZSgpLCB0YXJnZXRTdGF0ZS5wYXJhbXMoKSwgbmV3T3B0aW9ucyk7XG5cdCAgICAgICAgdmFyIHJlZGlyZWN0VG8gPSBuZXcgVHJhbnNpdGlvbih0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSwgdGhpcy5fdHJhbnNpdGlvblNlcnZpY2UpO1xuXHQgICAgICAgIHZhciByZWxvYWRTdGF0ZSA9IHRhcmdldFN0YXRlLm9wdGlvbnMoKS5yZWxvYWRTdGF0ZTtcblx0ICAgICAgICAvLyBJZiB0aGUgY3VycmVudCB0cmFuc2l0aW9uIGhhcyBhbHJlYWR5IHJlc29sdmVkIGFueSByZXNvbHZhYmxlcyB3aGljaCBhcmUgYWxzbyBpbiB0aGUgcmVkaXJlY3RlZCBcInRvIHBhdGhcIiwgdGhlblxuXHQgICAgICAgIC8vIGFkZCB0aG9zZSByZXNvbHZhYmxlcyB0byB0aGUgcmVkaXJlY3RlZCB0cmFuc2l0aW9uLiAgQWxsb3dzIHlvdSB0byBkZWZpbmUgYSByZXNvbHZlIGF0IGEgcGFyZW50IGxldmVsLCB3YWl0IGZvclxuXHQgICAgICAgIC8vIHRoZSByZXNvbHZlLCB0aGVuIHJlZGlyZWN0IHRvIGEgY2hpbGQgc3RhdGUgYmFzZWQgb24gdGhlIHJlc3VsdCwgYW5kIG5vdCBoYXZlIHRvIHJlLWZldGNoIHRoZSByZXNvbHZlLlxuXHQgICAgICAgIHZhciByZWRpcmVjdGVkUGF0aCA9IHRoaXMudHJlZUNoYW5nZXMoKS50bztcblx0ICAgICAgICB2YXIgY29weVJlc29sdmVzRm9yID0gbm9kZV8xLk5vZGUubWF0Y2hpbmcocmVkaXJlY3RUby50cmVlQ2hhbmdlcygpLnRvLCByZWRpcmVjdGVkUGF0aClcblx0ICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gIXJlbG9hZFN0YXRlIHx8ICFyZWxvYWRTdGF0ZS5pbmNsdWRlc1tub2RlLnN0YXRlLm5hbWVdOyB9KTtcblx0ICAgICAgICB2YXIgaW5jbHVkZVJlc29sdmUgPSBmdW5jdGlvbiAocmVzb2x2ZSwga2V5KSB7IHJldHVybiBbJyRzdGF0ZVBhcmFtcycsICckdHJhbnNpdGlvbiQnXS5pbmRleE9mKGtleSkgPT09IC0xOyB9O1xuXHQgICAgICAgIGNvcHlSZXNvbHZlc0Zvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpZHgpIHsgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChub2RlLnJlc29sdmVzLCBjb21tb25fMS5maWx0ZXIocmVkaXJlY3RlZFBhdGhbaWR4XS5yZXNvbHZlcywgaW5jbHVkZVJlc29sdmUpKTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHJlZGlyZWN0VG87XG5cdCAgICB9O1xuXHQgICAgLyoqIEBoaWRkZW4gSWYgYSB0cmFuc2l0aW9uIGRvZXNuJ3QgZXhpdC9lbnRlciBhbnkgc3RhdGVzLCByZXR1cm5zIGFueSBbW1BhcmFtXV0gd2hvc2UgdmFsdWUgY2hhbmdlZCAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuX2NoYW5nZWRQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcy5fdHJlZUNoYW5nZXMsIHRvID0gX2EudG8sIGZyb20gPSBfYS5mcm9tO1xuXHQgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnJlbG9hZCB8fCBjb21tb25fMS50YWlsKHRvKS5zdGF0ZSAhPT0gY29tbW9uXzEudGFpbChmcm9tKS5zdGF0ZSlcblx0ICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICB2YXIgbm9kZVNjaGVtYXMgPSB0by5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pO1xuXHQgICAgICAgIHZhciBfYiA9IFt0bywgZnJvbV0ubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5wYXJhbVZhbHVlczsgfSk7IH0pLCB0b1ZhbHVlcyA9IF9iWzBdLCBmcm9tVmFsdWVzID0gX2JbMV07XG5cdCAgICAgICAgdmFyIHR1cGxlcyA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKG5vZGVTY2hlbWFzLCB0b1ZhbHVlcywgZnJvbVZhbHVlcyk7XG5cdCAgICAgICAgcmV0dXJuIHR1cGxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHZhciBzY2hlbWEgPSBfYVswXSwgdG9WYWxzID0gX2FbMV0sIGZyb21WYWxzID0gX2FbMl07XG5cdCAgICAgICAgICAgIHJldHVybiBtb2R1bGVfMy5QYXJhbS5jaGFuZ2VkKHNjaGVtYSwgdG9WYWxzLCBmcm9tVmFscyk7XG5cdCAgICAgICAgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNpdGlvbiBpcyBkeW5hbWljLlxuXHQgICAgICpcblx0ICAgICAqIEEgdHJhbnNpdGlvbiBpcyBkeW5hbWljIGlmIG5vIHN0YXRlcyBhcmUgZW50ZXJlZCBub3IgZXhpdGVkLCBidXQgYXQgbGVhc3Qgb25lIGR5bmFtaWMgcGFyYW1ldGVyIGhhcyBjaGFuZ2VkLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgZHluYW1pY1xuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5keW5hbWljID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlZFBhcmFtcygpO1xuXHQgICAgICAgIHJldHVybiAhY2hhbmdlcyA/IGZhbHNlIDogY2hhbmdlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZHluYW1pYzsgfSkucmVkdWNlKGNvbW1vbl8xLmFueVRydWVSLCBmYWxzZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zaXRpb24gaXMgaWdub3JlZC5cblx0ICAgICAqXG5cdCAgICAgKiBBIHRyYW5zaXRpb24gaXMgaWdub3JlZCBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYW5kIG5vIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgaWdub3JlZC5cblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuaWdub3JlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZWRQYXJhbXMoKTtcblx0ICAgICAgICByZXR1cm4gIWNoYW5nZXMgPyBmYWxzZSA6IGNoYW5nZXMubGVuZ3RoID09PSAwO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQGhpZGRlblxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5ob29rQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IG1vZHVsZV8xLkhvb2tCdWlsZGVyKHRoaXMuX3RyYW5zaXRpb25TZXJ2aWNlLCB0aGlzLCB7XG5cdCAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMsXG5cdCAgICAgICAgICAgIGN1cnJlbnQ6IHRoaXMuX29wdGlvbnMuY3VycmVudFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUnVucyB0aGUgdHJhbnNpdGlvblxuXHQgICAgICpcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGdlbmVyYWxseSBjYWxsZWQgZnJvbSB0aGUgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGEgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uLlxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgaG9va0J1aWxkZXIgPSB0aGlzLmhvb2tCdWlsZGVyKCk7XG5cdCAgICAgICAgdmFyIHJ1blN5bmNocm9ub3VzSG9va3MgPSBtb2R1bGVfMS5UcmFuc2l0aW9uSG9vay5ydW5TeW5jaHJvbm91c0hvb2tzO1xuXHQgICAgICAgIC8vIFRPRE86IG51a2UgdGhlc2UgaW4gZmF2b3Igb2YgY2hhaW5pbmcgb2ZmIHRoZSBwcm9taXNlLCBpLmUuLFxuXHQgICAgICAgIC8vICR0cmFuc2l0aW9ucy5vbkJlZm9yZSh7fSwgJHRyYW5zaXRpb24kID0+IHskdHJhbnNpdGlvbiQucHJvbWlzZS50aGVuKCl9XG5cdCAgICAgICAgdmFyIHJ1blN1Y2Nlc3NIb29rcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJ1blN5bmNocm9ub3VzSG9va3MoaG9va0J1aWxkZXIuZ2V0T25TdWNjZXNzSG9va3MoKSwge30sIHRydWUpOyB9O1xuXHQgICAgICAgIHZhciBydW5FcnJvckhvb2tzID0gZnVuY3Rpb24gKCRlcnJvciQpIHsgcmV0dXJuIHJ1blN5bmNocm9ub3VzSG9va3MoaG9va0J1aWxkZXIuZ2V0T25FcnJvckhvb2tzKCksIHsgJGVycm9yJDogJGVycm9yJCB9LCB0cnVlKTsgfTtcblx0ICAgICAgICAvLyBSdW4gdGhlIHN1Y2Nlc3MvZXJyb3IgaG9va3MgKmFmdGVyKiB0aGUgVHJhbnNpdGlvbiBwcm9taXNlIGlzIHNldHRsZWQuXG5cdCAgICAgICAgdGhpcy5wcm9taXNlLnRoZW4ocnVuU3VjY2Vzc0hvb2tzLCBydW5FcnJvckhvb2tzKTtcblx0ICAgICAgICB2YXIgc3luY1Jlc3VsdCA9IHJ1blN5bmNocm9ub3VzSG9va3MoaG9va0J1aWxkZXIuZ2V0T25CZWZvcmVIb29rcygpKTtcblx0ICAgICAgICBpZiAobW9kdWxlXzEuVHJhbnNpdGlvbkhvb2suaXNSZWplY3Rpb24oc3luY1Jlc3VsdCkpIHtcblx0ICAgICAgICAgICAgdmFyIHJlamVjdFJlYXNvbiA9IHN5bmNSZXN1bHQucmVhc29uO1xuXHQgICAgICAgICAgICB0aGlzLl9kZWZlcnJlZC5yZWplY3QocmVqZWN0UmVhc29uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCF0aGlzLnZhbGlkKCkpIHtcblx0ICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHRoaXMuZXJyb3IoKSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlZmVycmVkLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmlnbm9yZWQoKSkge1xuXHQgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVHJhbnNpdGlvbklnbm9yZWQodGhpcyk7XG5cdCAgICAgICAgICAgIHZhciBpZ25vcmVkID0gUkVKRUNULmlnbm9yZWQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVmZXJyZWQucmVqZWN0KGlnbm9yZWQucmVhc29uKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gV2hlbiB0aGUgY2hhaW4gaXMgY29tcGxldGUsIHRoZW4gcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG5cdCAgICAgICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xuXHQgICAgICAgICAgICBfdGhpcy5fZGVmZXJyZWQucmVzb2x2ZShfdGhpcyk7XG5cdCAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VTdWNjZXNzKF90aGlzLiR0bygpLCBfdGhpcyk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcblx0ICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VFcnJvcihlcnJvciwgX3RoaXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQodGhpcyk7XG5cdCAgICAgICAgdmFyIGNoYWluID0gaG9va0J1aWxkZXIuYXN5bmNIb29rcygpLnJlZHVjZShmdW5jdGlvbiAoX2NoYWluLCBzdGVwKSB7IHJldHVybiBfY2hhaW4udGhlbihzdGVwLmludm9rZVN0ZXApOyB9LCBzeW5jUmVzdWx0KTtcblx0ICAgICAgICBjaGFpbi50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiB0aGUgVHJhbnNpdGlvbiBpcyB2YWxpZFxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgcmVhc29uIHRoZSBUcmFuc2l0aW9uIGlzIGludmFsaWRcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGV4cGxhaW5pbmcgd2h5IHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy4kdG8oKTtcblx0ICAgICAgICBpZiAoc3RhdGUuc2VsZltjb21tb25fMS5hYnN0cmFjdEtleV0pXG5cdCAgICAgICAgICAgIHJldHVybiBcIkNhbm5vdCB0cmFuc2l0aW9uIHRvIGFic3RyYWN0IHN0YXRlICdcIiArIHN0YXRlLm5hbWUgKyBcIidcIjtcblx0ICAgICAgICBpZiAoIW1vZHVsZV8zLlBhcmFtLnZhbGlkYXRlcyhzdGF0ZS5wYXJhbWV0ZXJzKCksIHRoaXMucGFyYW1zKCkpKVxuXHQgICAgICAgICAgICByZXR1cm4gXCJQYXJhbSB2YWx1ZXMgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInXCI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2l0aW9uXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmcm9tU3RhdGVPck5hbWUgPSB0aGlzLmZyb20oKTtcblx0ICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcblx0ICAgICAgICB2YXIgYXZvaWRFbXB0eUhhc2ggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAocGFyYW1zW1wiI1wiXSAhPT0gbnVsbCAmJiBwYXJhbXNbXCIjXCJdICE9PSB1bmRlZmluZWQpID8gcGFyYW1zIDogY29tbW9uXzEub21pdChwYXJhbXMsIFwiI1wiKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIChYKSBtZWFucyB0aGUgdG8gc3RhdGUgaXMgaW52YWxpZC5cblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLiRpZCwgZnJvbSA9IHByZWRpY2F0ZXNfMS5pc09iamVjdChmcm9tU3RhdGVPck5hbWUpID8gZnJvbVN0YXRlT3JOYW1lLm5hbWUgOiBmcm9tU3RhdGVPck5hbWUsIGZyb21QYXJhbXMgPSBjb21tb25fMS50b0pzb24oYXZvaWRFbXB0eUhhc2godGhpcy5fdHJlZUNoYW5nZXMuZnJvbS5tYXAoaG9mXzEucHJvcCgncGFyYW1WYWx1ZXMnKSkucmVkdWNlKGNvbW1vbl8xLm1lcmdlUiwge30pKSksIHRvVmFsaWQgPSB0aGlzLnZhbGlkKCkgPyBcIlwiIDogXCIoWCkgXCIsIHRvID0gcHJlZGljYXRlc18xLmlzT2JqZWN0KHRvU3RhdGVPck5hbWUpID8gdG9TdGF0ZU9yTmFtZS5uYW1lIDogdG9TdGF0ZU9yTmFtZSwgdG9QYXJhbXMgPSBjb21tb25fMS50b0pzb24oYXZvaWRFbXB0eUhhc2godGhpcy5wYXJhbXMoKSkpO1xuXHQgICAgICAgIHJldHVybiBcIlRyYW5zaXRpb24jXCIgKyBpZCArIFwiKCAnXCIgKyBmcm9tICsgXCInXCIgKyBmcm9tUGFyYW1zICsgXCIgLT4gXCIgKyB0b1ZhbGlkICsgXCInXCIgKyB0byArIFwiJ1wiICsgdG9QYXJhbXMgKyBcIiApXCI7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRyYW5zaXRpb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqXG5cdCAqIFVJLVJvdXRlciBUcmFuc2l0aW9uIFRyYWNpbmdcblx0ICpcblx0ICogRW5hYmxlIHRyYW5zaXRpb24gdHJhY2luZyB0byBwcmludCB0cmFuc2l0aW9uIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLCBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXG5cdCAqIFRyYWNpbmcgbG9ncyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIFRyYW5zaXRpb24gdG8geW91ciBjb25zb2xlLlxuXHQgKlxuXHQgKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW3RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cblx0ICpcblx0ICogRVM2XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwidWktcm91dGVyLW5nMlwiOyAvLyBvciBcImFuZ3VsYXItdWktcm91dGVyXCJcblx0ICogdHJhY2UuZW5hYmxlKDEsIDUpOyAvLyBUUkFOU0lUSU9OIGFuZCBWSUVXQ09ORklHXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBDSlNcblx0ICogYGBgXG5cdCAqXG5cdCAqIGxldCB0cmFjZSA9IHJlcXVpcmUoXCJhbmd1bGFyLXVpLXJvdXRlclwiKS50cmFjZTsgLy8gb3IgXCJ1aS1yb3V0ZXItbmcyXCJcblx0ICogdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiLCBcIlZJRVdDT05GSUdcIik7XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBHbG9iYWxzXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBsZXQgdHJhY2UgPSB3aW5kb3dbXCJhbmd1bGFyLXVpLXJvdXRlclwiXS50cmFjZTsgLy8gb3IgXCJ1aS1yb3V0ZXItbmcyXCJcblx0ICogdHJhY2UuZW5hYmxlKCk7IC8vIFRyYWNlIGV2ZXJ5dGhpbmcgKHZlcnkgdmVyYm9zZSlcblx0ICogYGBgXG5cdCAqXG5cdCAqIEBtb2R1bGUgdHJhY2Vcblx0ICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHN0cmluZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdC8qKiBAaGlkZGVuICovXG5cdGZ1bmN0aW9uIHVpVmlld1N0cmluZyh2aWV3RGF0YSkge1xuXHQgICAgaWYgKCF2aWV3RGF0YSlcblx0ICAgICAgICByZXR1cm4gJ3VpLXZpZXcgKGRlZnVuY3QpJztcblx0ICAgIHJldHVybiBcInVpLXZpZXcgaWQjXCIgKyB2aWV3RGF0YS5pZCArIFwiLCBjb250ZXh0dWFsIG5hbWUgJ1wiICsgdmlld0RhdGEubmFtZSArIFwiQFwiICsgdmlld0RhdGEuY3JlYXRpb25Db250ZXh0ICsgXCInLCBmcW46ICdcIiArIHZpZXdEYXRhLmZxbiArIFwiJ1wiO1xuXHR9XG5cdC8qKiBAaGlkZGVuICovXG5cdHZhciB2aWV3Q29uZmlnU3RyaW5nID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcblx0ICAgIHJldHVybiAoXCJWaWV3Q29uZmlnIHRhcmdldGluZyB1aS12aWV3OiAnXCIgKyB2aWV3Q29uZmlnLnZpZXdEZWNsLiR1aVZpZXdOYW1lICsgXCJAXCIgKyB2aWV3Q29uZmlnLnZpZXdEZWNsLiR1aVZpZXdDb250ZXh0QW5jaG9yICsgXCInLCBjb250ZXh0OiAnXCIgKyB2aWV3Q29uZmlnLnZpZXdEZWNsLiRjb250ZXh0Lm5hbWUgKyBcIidcIik7XG5cdH07XG5cdC8qKiBAaGlkZGVuICovXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZWRDYXQoaW5wdXQpIHtcblx0ICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNOdW1iZXIoaW5wdXQpID8gQ2F0ZWdvcnlbaW5wdXRdIDogQ2F0ZWdvcnlbQ2F0ZWdvcnlbaW5wdXRdXTtcblx0fVxuXHQvKipcblx0ICogVHJhY2UgY2F0ZWdvcmllc1xuXHQgKlxuXHQgKiBbW1RyYWNlLmVuYWJsZV1dIG9yIFtbVHJhY2UuZGlzYWJsZV1dIGEgY2F0ZWdvcnlcblx0ICpcblx0ICogYHRyYWNlLmVuYWJsZShDYXRlZ29yeS5UUkFOU0lUSU9OKWBcblx0ICpcblx0ICogVGhlc2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgdXNpbmcgYSBtYXRjaGluZyBzdHJpbmcsIG9yIHBvc2l0aW9uIG9yZGluYWxcblx0ICpcblx0ICogYHRyYWNlLmVuYWJsZShcIlRSQU5TSVRJT05cIilgXG5cdCAqXG5cdCAqIGB0cmFjZS5lbmFibGUoMSlgXG5cdCAqL1xuXHQoZnVuY3Rpb24gKENhdGVnb3J5KSB7XG5cdCAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlJFU09MVkVcIl0gPSAwXSA9IFwiUkVTT0xWRVwiO1xuXHQgICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJUUkFOU0lUSU9OXCJdID0gMV0gPSBcIlRSQU5TSVRJT05cIjtcblx0ICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiSE9PS1wiXSA9IDJdID0gXCJIT09LXCI7XG5cdCAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIklOVk9LRVwiXSA9IDNdID0gXCJJTlZPS0VcIjtcblx0ICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiVUlWSUVXXCJdID0gNF0gPSBcIlVJVklFV1wiO1xuXHQgICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJWSUVXQ09ORklHXCJdID0gNV0gPSBcIlZJRVdDT05GSUdcIjtcblx0fSkoZXhwb3J0cy5DYXRlZ29yeSB8fCAoZXhwb3J0cy5DYXRlZ29yeSA9IHt9KSk7XG5cdHZhciBDYXRlZ29yeSA9IGV4cG9ydHMuQ2F0ZWdvcnk7XG5cdC8qKlxuXHQgKiBQcmludHMgVUktUm91dGVyIFRyYW5zaXRpb24gdHJhY2UgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXG5cdCAqL1xuXHR2YXIgVHJhY2UgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVHJhY2UoKSB7XG5cdCAgICAgICAgLyoqIEBoaWRkZW4gKi9cblx0ICAgICAgICB0aGlzLl9lbmFibGVkID0ge307XG5cdCAgICAgICAgdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMgPSAwO1xuXHQgICAgfVxuXHQgICAgLyoqIEBoaWRkZW4gKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKGVuYWJsZWQsIGNhdGVnb3JpZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghY2F0ZWdvcmllcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgY2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKENhdGVnb3J5KVxuXHQgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gaXNOYU4ocGFyc2VJbnQoaywgMTApKTsgfSlcblx0ICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gQ2F0ZWdvcnlba2V5XTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGVnb3JpZXMubWFwKG5vcm1hbGl6ZWRDYXQpLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7IHJldHVybiBfdGhpcy5fZW5hYmxlZFtjYXRlZ29yeV0gPSBlbmFibGVkOyB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEVuYWJsZXMgYSB0cmFjZSBbW0NhdGVnb3J5XV1cblx0ICAgICAqXG5cdCAgICAgKiBgYGBcblx0ICAgICAqIHRyYWNlLmVuYWJsZShcIlRSQU5TSVRJT05cIik7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGVuYWJsZS4gSWYgYGNhdGVnb3JpZXNgIGlzIG9taXR0ZWQsIGFsbCBjYXRlZ29yaWVzIGFyZSBlbmFibGVkLlxuXHQgICAgICogICAgICAgIEFsc28gdGFrZXMgc3RyaW5ncyAoY2F0ZWdvcnkgbmFtZSkgb3Igb3JkaW5hbCAoY2F0ZWdvcnkgcG9zaXRpb24pXG5cdCAgICAgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zZXQodHJ1ZSwgY2F0ZWdvcmllcyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBEaXNhYmxlcyBhIHRyYWNlIFtbQ2F0ZWdvcnldXVxuXHQgICAgICpcblx0ICAgICAqIGBgYFxuXHQgICAgICogdHJhY2UuZGlzYWJsZShcIlZJRVdDT05GSUdcIik7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gY2F0ZWdvcmllcyBjYXRlZ29yaWVzIHRvIGRpc2FibGUuIElmIGBjYXRlZ29yaWVzYCBpcyBvbWl0dGVkLCBhbGwgY2F0ZWdvcmllcyBhcmUgZGlzYWJsZWQuXG5cdCAgICAgKiAgICAgICAgQWxzbyB0YWtlcyBzdHJpbmdzIChjYXRlZ29yeSBuYW1lKSBvciBvcmRpbmFsIChjYXRlZ29yeSBwb3NpdGlvbilcblx0ICAgICAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zZXQoZmFsc2UsIGNhdGVnb3JpZXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmVzIHRoZSBlbmFibGVkIHN0YXRldXMgb2YgYSBbW0NhdGVnb3J5XV1cblx0ICAgICAqXG5cdCAgICAgKiBgYGBcblx0ICAgICAqIHRyYWNlLmVuYWJsZWQoXCJWSUVXQ09ORklHXCIpOyAvLyB0cnVlIG9yIGZhbHNlXG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgdGhlIGNhdGVnb3J5IGlzIGVuYWJsZWRcblx0ICAgICAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcblx0ICAgICAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkW25vcm1hbGl6ZWRDYXQoY2F0ZWdvcnkpXTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VUcmFuc2l0aW9uU3RhcnQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgdmFyIHRpZCA9IHRyYW5zaXRpb24uJGlkLCBkaWdlc3QgPSB0aGlzLmFwcHJveGltYXRlRGlnZXN0cywgdHJhbnNpdGlvblN0ciA9IHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnNpdGlvbik7XG5cdCAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2l0aW9uICNcIiArIHRpZCArIFwiIERpZ2VzdCAjXCIgKyBkaWdlc3QgKyBcIjogU3RhcnRlZCAgLT4gXCIgKyB0cmFuc2l0aW9uU3RyKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VUcmFuc2l0aW9uSWdub3JlZCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gdHJhbnNpdGlvbi4kaWQsIGRpZ2VzdCA9IHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzLCB0cmFuc2l0aW9uU3RyID0gc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFuc2l0aW9uKTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiBJZ25vcmVkICA8PiBcIiArIHRyYW5zaXRpb25TdHIpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHN0ZXAsIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5IT09LKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHZhciB0aWQgPSBob2ZfMS5wYXJzZShcInRyYW5zaXRpb24uJGlkXCIpKG9wdGlvbnMpLCBkaWdlc3QgPSB0aGlzLmFwcHJveGltYXRlRGlnZXN0cywgZXZlbnQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5ob29rVHlwZVwiKShvcHRpb25zKSB8fCBcImludGVybmFsXCIsIGNvbnRleHQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWVcIikob3B0aW9ucykgfHwgaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dFwiKShvcHRpb25zKSB8fCBcInVua25vd25cIiwgbmFtZSA9IHN0cmluZ3NfMS5mdW5jdGlvblRvU3RyaW5nKHN0ZXAuZm4pO1xuXHQgICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNpdGlvbiAjXCIgKyB0aWQgKyBcIiBEaWdlc3QgI1wiICsgZGlnZXN0ICsgXCI6ICAgSG9vayAtPiBcIiArIGV2ZW50ICsgXCIgY29udGV4dDogXCIgKyBjb250ZXh0ICsgXCIsIFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIG5hbWUpKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VIb29rUmVzdWx0ID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQsIHRyYW5zaXRpb25SZXN1bHQsIHRyYW5zaXRpb25PcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuSE9PSykpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gaG9mXzEucGFyc2UoXCJ0cmFuc2l0aW9uLiRpZFwiKSh0cmFuc2l0aW9uT3B0aW9ucyksIGRpZ2VzdCA9IHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzLCBob29rUmVzdWx0U3RyID0gc3RyaW5nc18xLnN0cmluZ2lmeShob29rUmVzdWx0KSwgdHJhbnNpdGlvblJlc3VsdFN0ciA9IHN0cmluZ3NfMS5zdHJpbmdpZnkodHJhbnNpdGlvblJlc3VsdCk7XG5cdCAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2l0aW9uICNcIiArIHRpZCArIFwiIERpZ2VzdCAjXCIgKyBkaWdlc3QgKyBcIjogICA8LSBIb29rIHJldHVybmVkOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBob29rUmVzdWx0U3RyKSArIFwiLCB0cmFuc2l0aW9uIHJlc3VsdDogXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgdHJhbnNpdGlvblJlc3VsdFN0cikpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHZhciB0aWQgPSBob2ZfMS5wYXJzZShcInRyYW5zaXRpb24uJGlkXCIpKG9wdGlvbnMpLCBkaWdlc3QgPSB0aGlzLmFwcHJveGltYXRlRGlnZXN0cywgcGF0aFN0ciA9IHBhdGggJiYgcGF0aC50b1N0cmluZygpLCBwb2xpY3lTdHIgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzb2x2ZVBvbGljeTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiAgICAgICAgIFJlc29sdmluZyBcIiArIHBhdGhTdHIgKyBcIiAoXCIgKyBwb2xpY3lTdHIgKyBcIilcIik7XG5cdCAgICB9O1xuXHQgICAgLyoqIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLnRyYWNlUmVzb2x2ZVBhdGhFbGVtZW50ID0gZnVuY3Rpb24gKHBhdGhFbGVtZW50LCByZXNvbHZhYmxlUHJvbWlzZXMsIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5SRVNPTFZFKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIGlmICghcmVzb2x2YWJsZVByb21pc2VzLmxlbmd0aClcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHZhciB0aWQgPSBob2ZfMS5wYXJzZShcInRyYW5zaXRpb24uJGlkXCIpKG9wdGlvbnMpLCBkaWdlc3QgPSB0aGlzLmFwcHJveGltYXRlRGlnZXN0cywgcmVzb2x2YWJsZVByb21pc2VzU3RyID0gT2JqZWN0LmtleXMocmVzb2x2YWJsZVByb21pc2VzKS5qb2luKFwiLCBcIiksIHBhdGhFbGVtZW50U3RyID0gcGF0aEVsZW1lbnQgJiYgcGF0aEVsZW1lbnQudG9TdHJpbmcoKSwgcG9saWN5U3RyID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc29sdmVQb2xpY3k7XG5cdCAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2l0aW9uICNcIiArIHRpZCArIFwiIERpZ2VzdCAjXCIgKyBkaWdlc3QgKyBcIjogICAgICAgICBSZXNvbHZlIFwiICsgcGF0aEVsZW1lbnRTdHIgKyBcIiByZXNvbHZhYmxlczogW1wiICsgcmVzb2x2YWJsZVByb21pc2VzU3RyICsgXCJdIChcIiArIHBvbGljeVN0ciArIFwiKVwiKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VSZXNvbHZlUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuUkVTT0xWRSkpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gaG9mXzEucGFyc2UoXCJ0cmFuc2l0aW9uLiRpZFwiKShvcHRpb25zKSwgZGlnZXN0ID0gdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMsIHJlc29sdmFibGVTdHIgPSByZXNvbHZhYmxlICYmIHJlc29sdmFibGUudG9TdHJpbmcoKTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiAgICAgICAgICAgICAgIFJlc29sdmluZyAtPiBcIiArIHJlc29sdmFibGVTdHIpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmFibGVSZXNvbHZlZCA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuUkVTT0xWRSkpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gaG9mXzEucGFyc2UoXCJ0cmFuc2l0aW9uLiRpZFwiKShvcHRpb25zKSwgZGlnZXN0ID0gdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMsIHJlc29sdmFibGVTdHIgPSByZXNvbHZhYmxlICYmIHJlc29sdmFibGUudG9TdHJpbmcoKSwgcmVzdWx0ID0gc3RyaW5nc18xLnN0cmluZ2lmeShyZXNvbHZhYmxlLmRhdGEpO1xuXHQgICAgICAgIGNvbnNvbGUubG9nKFwiVHJhbnNpdGlvbiAjXCIgKyB0aWQgKyBcIiBEaWdlc3QgI1wiICsgZGlnZXN0ICsgXCI6ICAgICAgICAgICAgICAgPC0gUmVzb2x2ZWQgIFwiICsgcmVzb2x2YWJsZVN0ciArIFwiIHRvOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCByZXN1bHQpKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VQYXRoRWxlbWVudEludm9rZSA9IGZ1bmN0aW9uIChub2RlLCBmbiwgZGVwcywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LklOVk9LRSkpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gaG9mXzEucGFyc2UoXCJ0cmFuc2l0aW9uLiRpZFwiKShvcHRpb25zKSwgZGlnZXN0ID0gdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMsIHN0YXRlTmFtZSA9IG5vZGUgJiYgbm9kZS5zdGF0ZSAmJiBub2RlLnN0YXRlLnRvU3RyaW5nKCksIGZuTmFtZSA9IHN0cmluZ3NfMS5mdW5jdGlvblRvU3RyaW5nKGZuKTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiAgICAgICAgIEludm9rZSBcIiArIG9wdGlvbnMud2hlbiArIFwiOiBjb250ZXh0OiBcIiArIHN0YXRlTmFtZSArIFwiIFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIGZuTmFtZSkpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVFJBTlNJVElPTikpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB2YXIgdGlkID0gdHJhbnNpdGlvbi4kaWQsIGRpZ2VzdCA9IHRoaXMuYXBwcm94aW1hdGVEaWdlc3RzLCB0cmFuc2l0aW9uU3RyID0gc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFuc2l0aW9uKTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiA8LSBSZWplY3RlZCBcIiArIHRyYW5zaXRpb25TdHIgKyBcIiwgcmVhc29uOiBcIiArIGVycm9yKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VTdWNjZXNzID0gZnVuY3Rpb24gKGZpbmFsU3RhdGUsIHRyYW5zaXRpb24pIHtcblx0ICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHZhciB0aWQgPSB0cmFuc2l0aW9uLiRpZCwgZGlnZXN0ID0gdGhpcy5hcHByb3hpbWF0ZURpZ2VzdHMsIHN0YXRlID0gZmluYWxTdGF0ZS5uYW1lLCB0cmFuc2l0aW9uU3RyID0gc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFuc2l0aW9uKTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zaXRpb24gI1wiICsgdGlkICsgXCIgRGlnZXN0ICNcIiArIGRpZ2VzdCArIFwiOiA8LSBTdWNjZXNzICBcIiArIHRyYW5zaXRpb25TdHIgKyBcIiwgZmluYWwgc3RhdGU6IFwiICsgc3RhdGUpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cblx0ICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVpVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSwgZXh0cmEpIHtcblx0ICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IFwiXCI7IH1cblx0ICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5VSVZJRVcpKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgY29uc29sZS5sb2coXCJ1aS12aWV3OiBcIiArIHN0cmluZ3NfMS5wYWRTdHJpbmcoMzAsIGV2ZW50KSArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSArIGV4dHJhKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VVaVZpZXdDb25maWdVcGRhdGVkID0gZnVuY3Rpb24gKHZpZXdEYXRhLCBjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIHRoaXMudHJhY2VVaVZpZXdFdmVudChcIlVwZGF0aW5nXCIsIHZpZXdEYXRhLCBcIiB3aXRoIFZpZXdDb25maWcgZnJvbSBjb250ZXh0PSdcIiArIGNvbnRleHQgKyBcIidcIik7XG5cdCAgICB9O1xuXHQgICAgLyoqIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVWlWaWV3U2NvcGVDcmVhdGVkID0gZnVuY3Rpb24gKHZpZXdEYXRhLCBuZXdTY29wZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB0aGlzLnRyYWNlVWlWaWV3RXZlbnQoXCJDcmVhdGVkIHNjb3BlIGZvclwiLCB2aWV3RGF0YSwgXCIsIHNjb3BlICNcIiArIG5ld1Njb3BlLiRpZCk7XG5cdCAgICB9O1xuXHQgICAgLyoqIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVWlWaWV3RmlsbCA9IGZ1bmN0aW9uICh2aWV3RGF0YSwgaHRtbCkge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB0aGlzLnRyYWNlVWlWaWV3RXZlbnQoXCJGaWxsXCIsIHZpZXdEYXRhLCBcIiB3aXRoOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBodG1sKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuXHQgICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0NvbmZpZykge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgY29uc29sZS5sb2coXCIkdmlldy5WaWV3Q29uZmlnOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB2aWV3Q29uZmlnU3RyaW5nKHZpZXdDb25maWcpKTtcblx0ICAgIH07XG5cdCAgICAvKiogY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG5cdCAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VWaWV3U2VydmljZVVpVmlld0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCB2aWV3RGF0YSkge1xuXHQgICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlZJRVdDT05GSUcpKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgY29uc29sZS5sb2coXCIkdmlldy5WaWV3Q29uZmlnOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB1aVZpZXdTdHJpbmcodmlld0RhdGEpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVHJhY2U7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVHJhY2UgPSBUcmFjZTtcblx0LyoqXG5cdCAqIFRoZSBbW1RyYWNlXV0gc2luZ2xldG9uXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYGpzXG5cdCAqXG5cdCAqIGltcG9ydCB7dHJhY2V9IGZyb20gXCJhbmd1bGFyLXVpLXJvdXRlclwiO1xuXHQgKiB0cmFjZS5lbmFibGUoMSwgNSk7XG5cdCAqIGBgYFxuXHQgKi9cblx0dmFyIHRyYWNlID0gbmV3IFRyYWNlKCk7XG5cdGV4cG9ydHMudHJhY2UgPSB0cmFjZTtcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRmdW5jdGlvbiBfX2V4cG9ydChtKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG5cdH1cblx0LyoqXG5cdCAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIEFQSXMgcmVsYXRlZCB0byBhIFRyYW5zaXRpb24uXG5cdCAqXG5cdCAqIFNlZSBbW1RyYW5zaXRpb25dXSwgW1skdHJhbnNpdGlvbnNdXVxuXHQgKlxuXHQgKiBAbW9kdWxlIHRyYW5zaXRpb25cblx0ICogQHByZWZlcnJlZFxuXHQgKi9cblx0LyoqIGZvciB0eXBlZG9jICovXG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMTEpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygxNikpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKSk7XG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiogQG1vZHVsZSB0cmFuc2l0aW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHByZWRpY2F0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBtb2R1bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHQvKipcblx0ICogVGhpcyBjbGFzcyByZXR1cm5zIGFwcGxpY2FibGUgVHJhbnNpdGlvbkhvb2tzIGZvciBhIHNwZWNpZmljIFRyYW5zaXRpb24gaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEhvb2tzIChJRXZlbnRIb29rKSBtYXkgYmUgcmVnaXN0ZXJlZCBnbG9iYWxseSwgZS5nLiwgJHRyYW5zaXRpb25zLm9uRW50ZXIoLi4uKSwgb3IgbG9jYWxseSwgZS5nLlxuXHQgKiBteVRyYW5zaXRpb24ub25FbnRlciguLi4pLiAgVGhlIEhvb2tCdWlsZGVyIGZpbmRzIG1hdGNoaW5nIElFdmVudEhvb2tzICh3aGVyZSB0aGUgbWF0Y2ggY3JpdGVyaWEgaXNcblx0ICogZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBvZiBob29rKVxuXHQgKlxuXHQgKiBUaGUgSG9va0J1aWxkZXIgYWxzbyBjb252ZXJ0cyBJRXZlbnRIb29rcyBvYmplY3RzIHRvIFRyYW5zaXRpb25Ib29rIG9iamVjdHMsIHdoaWNoIGFyZSB1c2VkIHRvIHJ1biBhIFRyYW5zaXRpb24uXG5cdCAqXG5cdCAqIFRoZSBIb29rQnVpbGRlciBjb25zdHJ1Y3RvciBpcyBnaXZlbiB0aGUgJHRyYW5zaXRpb25zIHNlcnZpY2UgYW5kIGEgVHJhbnNpdGlvbiBpbnN0YW5jZS4gIFRodXMsIGEgSG9va0J1aWxkZXJcblx0ICogaW5zdGFuY2UgbWF5IG9ubHkgYmUgdXNlZCBmb3Igb25lIHNwZWNpZmljIFRyYW5zaXRpb24gb2JqZWN0LiAoc2lkZSBub3RlOiB0aGUgX3RyZWVDaGFuZ2VzIGFjY2Vzc29yIGlzIHByaXZhdGVcblx0ICogaW4gdGhlIFRyYW5zaXRpb24gY2xhc3MsIHNvIHdlIG11c3QgYWxzbyBwcm92aWRlIHRoZSBUcmFuc2l0aW9uJ3MgX3RyZWVDaGFuZ2VzKVxuXHQgKlxuXHQgKi9cblx0dmFyIEhvb2tCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEhvb2tCdWlsZGVyKCR0cmFuc2l0aW9ucywgdHJhbnNpdGlvbiwgYmFzZUhvb2tPcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLiR0cmFuc2l0aW9ucyA9ICR0cmFuc2l0aW9ucztcblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHQgICAgICAgIHRoaXMuYmFzZUhvb2tPcHRpb25zID0gYmFzZUhvb2tPcHRpb25zO1xuXHQgICAgICAgIC8vIFRPRE86IFRoZXNlIGdldCogbWV0aG9kcyBhcmUgcmV0dXJuaW5nIGRpZmZlcmVudCBjYXJkaW5hbGl0aWVzIG9mIGhvb2tzXG5cdCAgICAgICAgLy8gb25CZWZvcmUvb25TdGFydC9vbkZpbmlzaC9vblN1Y2Nlc3Mvb25FcnJvciByZXR1cm5zIGFuIGFycmF5IG9mIGhvb2tzXG5cdCAgICAgICAgLy8gb25FeGl0L29uUmV0YWluL29uRW50ZXIgcmV0dXJucyBhbiBhcnJheSBvZiBhcnJheXMgb2YgaG9va3Ncblx0ICAgICAgICB0aGlzLmdldE9uQmVmb3JlSG9va3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYnVpbGROb2RlSG9va3MoXCJvbkJlZm9yZVwiLCBcInRvXCIsIHR1cGxlU29ydCgpLCB1bmRlZmluZWQsIHsgYXN5bmM6IGZhbHNlIH0pOyB9O1xuXHQgICAgICAgIHRoaXMuZ2V0T25TdGFydEhvb2tzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2J1aWxkTm9kZUhvb2tzKFwib25TdGFydFwiLCBcInRvXCIsIHR1cGxlU29ydCgpKTsgfTtcblx0ICAgICAgICB0aGlzLmdldE9uRXhpdEhvb2tzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2J1aWxkTm9kZUhvb2tzKFwib25FeGl0XCIsIFwiZXhpdGluZ1wiLCB0dXBsZVNvcnQodHJ1ZSksIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoeyAkc3RhdGUkOiBub2RlLnN0YXRlIH0pOyB9KTsgfTtcblx0ICAgICAgICB0aGlzLmdldE9uUmV0YWluSG9va3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYnVpbGROb2RlSG9va3MoXCJvblJldGFpblwiLCBcInJldGFpbmVkXCIsIHR1cGxlU29ydCgpLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKHsgJHN0YXRlJDogbm9kZS5zdGF0ZSB9KTsgfSk7IH07XG5cdCAgICAgICAgdGhpcy5nZXRPbkVudGVySG9va3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYnVpbGROb2RlSG9va3MoXCJvbkVudGVyXCIsIFwiZW50ZXJpbmdcIiwgdHVwbGVTb3J0KCksIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiAoeyAkc3RhdGUkOiBub2RlLnN0YXRlIH0pOyB9KTsgfTtcblx0ICAgICAgICB0aGlzLmdldE9uRmluaXNoSG9va3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYnVpbGROb2RlSG9va3MoXCJvbkZpbmlzaFwiLCBcInRvXCIsIHR1cGxlU29ydCgpLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKHsgJHRyZWVDaGFuZ2VzJDogX3RoaXMudHJlZUNoYW5nZXMgfSk7IH0pOyB9O1xuXHQgICAgICAgIHRoaXMuZ2V0T25TdWNjZXNzSG9va3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYnVpbGROb2RlSG9va3MoXCJvblN1Y2Nlc3NcIiwgXCJ0b1wiLCB0dXBsZVNvcnQoKSwgdW5kZWZpbmVkLCB7IGFzeW5jOiBmYWxzZSwgcmVqZWN0SWZTdXBlcnNlZGVkOiBmYWxzZSB9KTsgfTtcblx0ICAgICAgICB0aGlzLmdldE9uRXJyb3JIb29rcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9idWlsZE5vZGVIb29rcyhcIm9uRXJyb3JcIiwgXCJ0b1wiLCB0dXBsZVNvcnQoKSwgdW5kZWZpbmVkLCB7IGFzeW5jOiBmYWxzZSwgcmVqZWN0SWZTdXBlcnNlZGVkOiBmYWxzZSB9KTsgfTtcblx0ICAgICAgICB0aGlzLnRyZWVDaGFuZ2VzID0gdHJhbnNpdGlvbi50cmVlQ2hhbmdlcygpO1xuXHQgICAgICAgIHRoaXMudG9TdGF0ZSA9IGNvbW1vbl8xLnRhaWwodGhpcy50cmVlQ2hhbmdlcy50bykuc3RhdGU7XG5cdCAgICAgICAgdGhpcy5mcm9tU3RhdGUgPSBjb21tb25fMS50YWlsKHRoaXMudHJlZUNoYW5nZXMuZnJvbSkuc3RhdGU7XG5cdCAgICAgICAgdGhpcy50cmFuc2l0aW9uT3B0aW9ucyA9IHRyYW5zaXRpb24ub3B0aW9ucygpO1xuXHQgICAgfVxuXHQgICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmFzeW5jSG9va3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9uU3RhcnRIb29rcyA9IHRoaXMuZ2V0T25TdGFydEhvb2tzKCk7XG5cdCAgICAgICAgdmFyIG9uRXhpdEhvb2tzID0gdGhpcy5nZXRPbkV4aXRIb29rcygpO1xuXHQgICAgICAgIHZhciBvblJldGFpbkhvb2tzID0gdGhpcy5nZXRPblJldGFpbkhvb2tzKCk7XG5cdCAgICAgICAgdmFyIG9uRW50ZXJIb29rcyA9IHRoaXMuZ2V0T25FbnRlckhvb2tzKCk7XG5cdCAgICAgICAgdmFyIG9uRmluaXNoSG9va3MgPSB0aGlzLmdldE9uRmluaXNoSG9va3MoKTtcblx0ICAgICAgICB2YXIgYXN5bmNIb29rcyA9IFtvblN0YXJ0SG9va3MsIG9uRXhpdEhvb2tzLCBvblJldGFpbkhvb2tzLCBvbkVudGVySG9va3MsIG9uRmluaXNoSG9va3NdO1xuXHQgICAgICAgIHJldHVybiBhc3luY0hvb2tzLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbmV3bHkgYnVpbHQgVHJhbnNpdGlvbkhvb2sgb2JqZWN0cy5cblx0ICAgICAqXG5cdCAgICAgKiAtIEZpbmRzIGFsbCBJRXZlbnRIb29rcyByZWdpc3RlcmVkIGZvciB0aGUgZ2l2ZW4gYGhvb2tUeXBlYCB3aGljaCBtYXRjaGVkIHRoZSB0cmFuc2l0aW9uJ3MgW1tUcmVlQ2hhbmdlc11dLlxuXHQgICAgICogLSBGaW5kcyBbW05vZGVdXSAob3IgYE5vZGVbXWApIHRvIHVzZSBhcyB0aGUgVHJhbnNpdGlvbkhvb2sgY29udGV4dChzKVxuXHQgICAgICogLSBGb3IgZWFjaCBvZiB0aGUgW1tOb2RlXV1zLCBjcmVhdGVzIGEgVHJhbnNpdGlvbkhvb2tcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gaG9va1R5cGUgdGhlIG5hbWUgb2YgdGhlIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uLCBlLmcuLCAnb25FbnRlcicsICdvbkZpbmlzaCcuXG5cdCAgICAgKiBAcGFyYW0gbWF0Y2hpbmdOb2Rlc1Byb3Agc2VsZWN0cyB3aGljaCBbW05vZGVdXXMgZnJvbSB0aGUgW1tJTWF0Y2hpbmdOb2Rlc11dIG9iamVjdCB0byBjcmVhdGUgaG9va3MgZm9yLlxuXHQgICAgICogQHBhcmFtIGdldExvY2FscyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBbW05vZGVdXSBhbmQgcmV0dXJucyBhZGRpdGlvbmFsIGxvY2FscyB0byBwcm92aWRlIHRvIHRoZSBob29rIGFzIGluamVjdGFibGVzXG5cdCAgICAgKiBAcGFyYW0gc29ydEhvb2tzRm4gYSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0d28gSG9va1R1cGxlIGFuZCByZXR1cm5zIDwxLCAwLCBvciA+MVxuXHQgICAgICogQHBhcmFtIG9wdGlvbnMgYW55IHNwZWNpZmljIFRyYW5zaXRpb24gSG9vayBPcHRpb25zXG5cdCAgICAgKi9cblx0ICAgIEhvb2tCdWlsZGVyLnByb3RvdHlwZS5fYnVpbGROb2RlSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUsIG1hdGNoaW5nTm9kZXNQcm9wLCBzb3J0SG9va3NGbiwgZ2V0TG9jYWxzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAoZ2V0TG9jYWxzID09PSB2b2lkIDApIHsgZ2V0TG9jYWxzID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuICh7fSk7IH07IH1cblx0ICAgICAgICAvLyBGaW5kIGFsbCB0aGUgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBob29rcyBmb3IgYSBnaXZlbiBob29rIHR5cGVcblx0ICAgICAgICB2YXIgbWF0Y2hpbmdIb29rcyA9IHRoaXMuX21hdGNoaW5nSG9va3MoaG9va1R5cGUsIHRoaXMudHJlZUNoYW5nZXMpO1xuXHQgICAgICAgIGlmICghbWF0Y2hpbmdIb29rcylcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcblx0ICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIE5vZGVzIHRoYXQgY2F1c2VkIHRoaXMgaG9vayB0byBtYXRjaC5cblx0ICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBob29rLm1hdGNoZXMoX3RoaXMudHJlZUNoYW5nZXMpO1xuXHQgICAgICAgICAgICAvLyBTZWxlY3QgdGhlIE5vZGVbXSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBUcmFuc2l0aW9uSG9vayBjb250ZXh0IG9iamVjdHNcblx0ICAgICAgICAgICAgdmFyIG5vZGVzID0gbWF0Y2hlc1ttYXRjaGluZ05vZGVzUHJvcF07XG5cdCAgICAgICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBIb29rVHVwbGVzXG5cdCAgICAgICAgICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7IGJpbmQ6IGhvb2suYmluZCwgdHJhY2VEYXRhOiB7IGhvb2tUeXBlOiBob29rVHlwZSwgY29udGV4dDogbm9kZSB9IH0sIF90aGlzLmJhc2VIb29rT3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkhvb2sgPSBuZXcgbW9kdWxlXzEuVHJhbnNpdGlvbkhvb2soaG9vay5jYWxsYmFjaywgZ2V0TG9jYWxzKG5vZGUpLCBub2RlLnJlc29sdmVDb250ZXh0LCBfb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4geyBob29rOiBob29rLCBub2RlOiBub2RlLCB0cmFuc2l0aW9uSG9vazogdHJhbnNpdGlvbkhvb2sgfTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbWF0Y2hpbmdIb29rcy5tYXAobWFrZVRyYW5zaXRpb25Ib29rcylcblx0ICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcblx0ICAgICAgICAgICAgLnNvcnQoc29ydEhvb2tzRm4pXG5cdCAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZS50cmFuc2l0aW9uSG9vazsgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBGaW5kcyBhbGwgSUV2ZW50SG9va3MgZnJvbTpcblx0ICAgICAqIC0gVGhlIFRyYW5zaXRpb24gb2JqZWN0IGluc3RhbmNlIGhvb2sgcmVnaXN0cnlcblx0ICAgICAqIC0gVGhlIFRyYW5zaXRpb25TZXJ2aWNlICgkdHJhbnNpdGlvbnMpIGdsb2JhbCBob29rIHJlZ2lzdHJ5XG5cdCAgICAgKlxuXHQgICAgICogd2hpY2ggbWF0Y2hlZDpcblx0ICAgICAqIC0gdGhlIGV2ZW50VHlwZVxuXHQgICAgICogLSB0aGUgbWF0Y2hDcml0ZXJpYSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGVkIFtbSUV2ZW50SG9va11dc1xuXHQgICAgICovXG5cdCAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuX21hdGNoaW5nSG9va3MgPSBmdW5jdGlvbiAoaG9va05hbWUsIHRyZWVDaGFuZ2VzKSB7XG5cdCAgICAgICAgcmV0dXJuIFt0aGlzLnRyYW5zaXRpb24sIHRoaXMuJHRyYW5zaXRpb25zXSAvLyBJbnN0YW5jZSBhbmQgR2xvYmFsIGhvb2sgcmVnaXN0cmllc1xuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZWcpIHsgcmV0dXJuIHJlZy5nZXRIb29rcyhob29rTmFtZSk7IH0pIC8vIEdldCBuYW1lZCBob29rcyBmcm9tIHJlZ2lzdHJpZXNcblx0ICAgICAgICAgICAgLmZpbHRlcihjb21tb25fMS5hc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlc18xLmlzQXJyYXksIFwiYnJva2VuIGV2ZW50IG5hbWVkOiBcIiArIGhvb2tOYW1lKSkgLy8gU2FuaXR5IGNoZWNrXG5cdCAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pIC8vIFVuLW5lc3QgSUV2ZW50SG9va1tdW10gdG8gSUV2ZW50SG9va1tdIGFycmF5XG5cdCAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7IH0pOyAvLyBPbmx5IHRob3NlIHNhdGlzZnlpbmcgbWF0Y2hDcml0ZXJpYVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBIb29rQnVpbGRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Ib29rQnVpbGRlciA9IEhvb2tCdWlsZGVyO1xuXHQvKipcblx0ICogQSBmYWN0b3J5IGZvciBhIHNvcnQgZnVuY3Rpb24gZm9yIEhvb2tUdXBsZXMuXG5cdCAqXG5cdCAqIFRoZSBzb3J0IGZ1bmN0aW9uIGZpcnN0IGNvbXBhcmVzIHRoZSBOb2RlIGRlcHRoIChob3cgZGVlcCBpbiB0aGUgc3RhdGUgdHJlZSBhIG5vZGUgaXMpLCB0aGVuIGNvbXBhcmVzXG5cdCAqIHRoZSBFdmVudEhvb2sgcHJpb3JpdHkuXG5cdCAqXG5cdCAqIEBwYXJhbSByZXZlcnNlRGVwdGhTb3J0IGEgYm9vbGVhbiwgd2hlbiB0cnVlLCByZXZlcnNlcyB0aGUgc29ydCBvcmRlciBmb3IgdGhlIG5vZGUgZGVwdGhcblx0ICogQHJldHVybnMgYSB0dXBsZSBzb3J0IGZ1bmN0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiB0dXBsZVNvcnQocmV2ZXJzZURlcHRoU29ydCkge1xuXHQgICAgaWYgKHJldmVyc2VEZXB0aFNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlRGVwdGhTb3J0ID0gZmFsc2U7IH1cblx0ICAgIHJldHVybiBmdW5jdGlvbiBub2RlRGVwdGhUaGVuUHJpb3JpdHkobCwgcikge1xuXHQgICAgICAgIHZhciBmYWN0b3IgPSByZXZlcnNlRGVwdGhTb3J0ID8gLTEgOiAxO1xuXHQgICAgICAgIHZhciBkZXB0aERlbHRhID0gKGwubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCAtIHIubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCkgKiBmYWN0b3I7XG5cdCAgICAgICAgcmV0dXJuIGRlcHRoRGVsdGEgIT09IDAgPyBkZXB0aERlbHRhIDogci5ob29rLnByaW9yaXR5IC0gbC5ob29rLnByaW9yaXR5O1xuXHQgICAgfTtcblx0fVxuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHRyYW5zaXRpb24gKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZ2xvYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHN0YXRlIG1hdGNoZXMgdGhlIG1hdGNoQ3JpdGVyaWFcblx0ICogQHBhcmFtIHN0YXRlIGEgU3RhdGUgT2JqZWN0IHRvIHRlc3QgYWdhaW5zdFxuXHQgKiBAcGFyYW0gY3JpdGVyaW9uXG5cdCAqIC0gSWYgYSBzdHJpbmcsIG1hdGNoU3RhdGUgdXNlcyB0aGUgc3RyaW5nIGFzIGEgZ2xvYi1tYXRjaGVyIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcblx0ICogLSBJZiBhbiBhcnJheSAob2Ygc3RyaW5ncyksIG1hdGNoU3RhdGUgdXNlcyBlYWNoIHN0cmluZyBpbiB0aGUgYXJyYXkgYXMgYSBnbG9iLW1hdGNoZXJzIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcblx0ICogICBhbmQgcmV0dXJucyBhIHBvc2l0aXZlIG1hdGNoIGlmIGFueSBvZiB0aGUgZ2xvYnMgbWF0Y2guXG5cdCAqIC0gSWYgYSBmdW5jdGlvbiwgbWF0Y2hTdGF0ZSBjYWxscyB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3RhdGUgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgdHJ1dGh5LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoU3RhdGUoc3RhdGUsIGNyaXRlcmlvbikge1xuXHQgICAgdmFyIHRvTWF0Y2ggPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY3JpdGVyaW9uKSA/IFtjcml0ZXJpb25dIDogY3JpdGVyaW9uO1xuXHQgICAgZnVuY3Rpb24gbWF0Y2hHbG9icyhfc3RhdGUpIHtcblx0ICAgICAgICB2YXIgZ2xvYlN0cmluZ3MgPSB0b01hdGNoO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYlN0cmluZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGdsb2IgPSBnbG9iXzEuR2xvYi5mcm9tU3RyaW5nKGdsb2JTdHJpbmdzW2ldKTtcblx0ICAgICAgICAgICAgaWYgKChnbG9iICYmIGdsb2IubWF0Y2hlcyhfc3RhdGUubmFtZSkpIHx8ICghZ2xvYiAmJiBnbG9iU3RyaW5nc1tpXSA9PT0gX3N0YXRlLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB2YXIgbWF0Y2hGbiA9IChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih0b01hdGNoKSA/IHRvTWF0Y2ggOiBtYXRjaEdsb2JzKTtcblx0ICAgIHJldHVybiAhIW1hdGNoRm4oc3RhdGUpO1xuXHR9XG5cdGV4cG9ydHMubWF0Y2hTdGF0ZSA9IG1hdGNoU3RhdGU7XG5cdHZhciBFdmVudEhvb2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXZlbnRIb29rKG1hdGNoQ3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdCAgICAgICAgdGhpcy5tYXRjaENyaXRlcmlhID0gY29tbW9uXzEuZXh0ZW5kKHsgdG86IHRydWUsIGZyb206IHRydWUsIGV4aXRpbmc6IHRydWUsIHJldGFpbmVkOiB0cnVlLCBlbnRlcmluZzogdHJ1ZSB9LCBtYXRjaENyaXRlcmlhKTtcblx0ICAgICAgICB0aGlzLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eSB8fCAwO1xuXHQgICAgICAgIHRoaXMuYmluZCA9IG9wdGlvbnMuYmluZCB8fCBudWxsO1xuXHQgICAgfVxuXHQgICAgRXZlbnRIb29rLl9tYXRjaGluZ05vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjcml0ZXJpb24pIHtcblx0ICAgICAgICBpZiAoY3JpdGVyaW9uID09PSB0cnVlKVxuXHQgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG5cdCAgICAgICAgdmFyIG1hdGNoaW5nID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBtYXRjaFN0YXRlKG5vZGUuc3RhdGUsIGNyaXRlcmlvbik7IH0pO1xuXHQgICAgICAgIHJldHVybiBtYXRjaGluZy5sZW5ndGggPyBtYXRjaGluZyA6IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgaG9vaydzIFtbbWF0Y2hDcml0ZXJpYV1dIG1hdGNoIHRoZSBnaXZlbiBbW1RyZWVDaGFuZ2VzXV1cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QsIG9yIG51bGwuIElmIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIHZhbHVlc1xuXHQgICAgICogYXJlIHRoZSBtYXRjaGluZyBbW05vZGVdXXMgZm9yIGVhY2ggW1tIb29rTWF0Y2hDcml0ZXJpb25dXSAodG8sIGZyb20sIGV4aXRpbmcsIHJldGFpbmVkLCBlbnRlcmluZylcblx0ICAgICAqL1xuXHQgICAgRXZlbnRIb29rLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzKSB7XG5cdCAgICAgICAgdmFyIG1jID0gdGhpcy5tYXRjaENyaXRlcmlhLCBfbWF0Y2hpbmdOb2RlcyA9IEV2ZW50SG9vay5fbWF0Y2hpbmdOb2Rlcztcblx0ICAgICAgICB2YXIgbWF0Y2hlcyA9IHtcblx0ICAgICAgICAgICAgdG86IF9tYXRjaGluZ05vZGVzKFtjb21tb25fMS50YWlsKHRyZWVDaGFuZ2VzLnRvKV0sIG1jLnRvKSxcblx0ICAgICAgICAgICAgZnJvbTogX21hdGNoaW5nTm9kZXMoW2NvbW1vbl8xLnRhaWwodHJlZUNoYW5nZXMuZnJvbSldLCBtYy5mcm9tKSxcblx0ICAgICAgICAgICAgZXhpdGluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZXhpdGluZywgbWMuZXhpdGluZyksXG5cdCAgICAgICAgICAgIHJldGFpbmVkOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5yZXRhaW5lZCwgbWMucmV0YWluZWQpLFxuXHQgICAgICAgICAgICBlbnRlcmluZzogX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZW50ZXJpbmcsIG1jLmVudGVyaW5nKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIENoZWNrIGlmIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2hlZCB0aGUgVHJlZUNoYW5nZXMgb2JqZWN0XG5cdCAgICAgICAgdmFyIGFsbE1hdGNoZWQgPSBbXCJ0b1wiLCBcImZyb21cIiwgXCJleGl0aW5nXCIsIFwicmV0YWluZWRcIiwgXCJlbnRlcmluZ1wiXVxuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBtYXRjaGVzW3Byb3BdOyB9KVxuXHQgICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcblx0ICAgICAgICByZXR1cm4gYWxsTWF0Y2hlZCA/IG1hdGNoZXMgOiBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdmVudEhvb2s7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRXZlbnRIb29rID0gRXZlbnRIb29rO1xuXHQvLyBSZXR1cm4gYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gb2YgdGhlIHJlcXVlc3RlZCB0eXBlLlxuXHRmdW5jdGlvbiBtYWtlSG9va1JlZ2lzdHJhdGlvbkZuKGhvb2tzLCBuYW1lKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoT2JqZWN0LCBjYWxsYmFjaywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG5cdCAgICAgICAgdmFyIGV2ZW50SG9vayA9IG5ldyBFdmVudEhvb2sobWF0Y2hPYmplY3QsIGNhbGxiYWNrLCBvcHRpb25zKTtcblx0ICAgICAgICBob29rc1tuYW1lXS5wdXNoKGV2ZW50SG9vayk7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJFdmVudEhvb2soKSB7XG5cdCAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20oaG9va3NbbmFtZV0pKGV2ZW50SG9vayk7XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdH1cblx0dmFyIEhvb2tSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBIb29rUmVnaXN0cnkoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLl90cmFuc2l0aW9uRXZlbnRzID0ge1xuXHQgICAgICAgICAgICBvbkJlZm9yZTogW10sIG9uU3RhcnQ6IFtdLCBvbkVudGVyOiBbXSwgb25SZXRhaW46IFtdLCBvbkV4aXQ6IFtdLCBvbkZpbmlzaDogW10sIG9uU3VjY2VzczogW10sIG9uRXJyb3I6IFtdXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmdldEhvb2tzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLl90cmFuc2l0aW9uRXZlbnRzW25hbWVdOyB9O1xuXHQgICAgICAgIHRoaXMub25CZWZvcmUgPSBtYWtlSG9va1JlZ2lzdHJhdGlvbkZuKHRoaXMuX3RyYW5zaXRpb25FdmVudHMsIFwib25CZWZvcmVcIik7XG5cdCAgICAgICAgdGhpcy5vblN0YXJ0ID0gbWFrZUhvb2tSZWdpc3RyYXRpb25Gbih0aGlzLl90cmFuc2l0aW9uRXZlbnRzLCBcIm9uU3RhcnRcIik7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyI29uRW50ZXJcblx0ICAgICAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0byBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCBkdXJpbmcgYSB0cmFuc2l0aW9uIGJldHdlZW4gdGhlIG1hdGNoZWQgJ3RvJyBhbmQgJ2Zyb20nIHN0YXRlcyxcblx0ICAgICAgICAgKiB3aGVuIHRoZSBtYXRjaGVkICd0bycgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC4gVGhpcyBmdW5jdGlvbiBpcyBpbmplY3RlZCB3aXRoIHRoZSBlbnRlcmluZyBzdGF0ZSdzIHJlc29sdmVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW5qZWN0ZWQgd2l0aCB0d28gYWRkaXRpb25hbCBzcGVjaWFsIHZhbHVlOlxuXHQgICAgICAgICAqIC0gKipgJHRyYW5zaXRpb24kYCoqOiBUaGUgY3VycmVudCB0cmFuc2l0aW9uXG5cdCAgICAgICAgICogLSAqKmAkc3RhdGUkYCoqOiBUaGUgc3RhdGUgYmVpbmcgZW50ZXJlZFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1hdGNoT2JqZWN0IFNlZSB0cmFuc2l0aW9uQ3JpdGVyaWEgaW4ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlciNvbiAkdHJhbnNpdGlvbnNQcm92aWRlci5vbn0uXG5cdCAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgU2VlIGNhbGxiYWNrIGluIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb24gJHRyYW5zaXRpb25zUHJvdmlkZXIub259LlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMub25FbnRlciA9IG1ha2VIb29rUmVnaXN0cmF0aW9uRm4odGhpcy5fdHJhbnNpdGlvbkV2ZW50cywgXCJvbkVudGVyXCIpO1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlciNvblJldGFpblxuXHQgICAgICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXJcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRvIGJlIGluamVjdGVkIGFuZCBpbnZva2VkIGR1cmluZyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0aGUgbWF0Y2hlZCAndG8nIGFuZCAnZnJvbSBzdGF0ZXMsXG5cdCAgICAgICAgICogd2hlbiB0aGUgbWF0Y2hlZCAnZnJvbScgc3RhdGUgaXMgYWxyZWFkeSBhY3RpdmUgYW5kIGlzIG5vdCBiZWluZyBleGl0ZWQgbm9yIGVudGVyZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBpbmplY3RlZCB3aXRoIHR3byBhZGRpdGlvbmFsIHNwZWNpYWwgdmFsdWU6XG5cdCAgICAgICAgICogLSAqKmAkdHJhbnNpdGlvbiRgKio6IFRoZSBjdXJyZW50IHRyYW5zaXRpb25cblx0ICAgICAgICAgKiAtICoqYCRzdGF0ZSRgKio6IFRoZSBzdGF0ZSB0aGF0IGlzIHJldGFpbmVkXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hPYmplY3QgU2VlIHRyYW5zaXRpb25Dcml0ZXJpYSBpbiB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyI29uICR0cmFuc2l0aW9uc1Byb3ZpZGVyLm9ufS5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBTZWUgY2FsbGJhY2sgaW4ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlciNvbiAkdHJhbnNpdGlvbnNQcm92aWRlci5vbn0uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5vblJldGFpbiA9IG1ha2VIb29rUmVnaXN0cmF0aW9uRm4odGhpcy5fdHJhbnNpdGlvbkV2ZW50cywgXCJvblJldGFpblwiKTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb25FeGl0XG5cdCAgICAgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlclxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQgZHVyaW5nIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHRoZSBtYXRjaGVkICd0bycgYW5kICdmcm9tIHN0YXRlcyxcblx0ICAgICAgICAgKiB3aGVuIHRoZSBtYXRjaGVkICdmcm9tJyBzdGF0ZSBpcyBiZWluZyBleGl0ZWQuIFRoaXMgZnVuY3Rpb24gaXMgaW4gaW5qZWN0ZWQgd2l0aCB0aGUgZXhpdGluZyBzdGF0ZSdzIHJlc29sdmVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW5qZWN0ZWQgd2l0aCB0d28gYWRkaXRpb25hbCBzcGVjaWFsIHZhbHVlOlxuXHQgICAgICAgICAqIC0gKipgJHRyYW5zaXRpb24kYCoqOiBUaGUgY3VycmVudCB0cmFuc2l0aW9uXG5cdCAgICAgICAgICogLSAqKmAkc3RhdGUkYCoqOiBUaGUgc3RhdGUgYmVpbmcgZW50ZXJlZFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1hdGNoT2JqZWN0IFNlZSB0cmFuc2l0aW9uQ3JpdGVyaWEgaW4ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlciNvbiAkdHJhbnNpdGlvbnNQcm92aWRlci5vbn0uXG5cdCAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgU2VlIGNhbGxiYWNrIGluIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb24gJHRyYW5zaXRpb25zUHJvdmlkZXIub259LlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMub25FeGl0ID0gbWFrZUhvb2tSZWdpc3RyYXRpb25Gbih0aGlzLl90cmFuc2l0aW9uRXZlbnRzLCBcIm9uRXhpdFwiKTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb25GaW5pc2hcblx0ICAgICAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0byBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCB3aGVuIGEgdHJhbnNpdGlvbiBpcyBmaW5pc2hlZCBlbnRlcmluZy9leGl0aW5nIGFsbCBzdGF0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBpbmplY3RlZCB3aXRoOlxuXHQgICAgICAgICAqIC0gKipgJHRyYW5zaXRpb24kYCoqOiBUaGUgY3VycmVudCB0cmFuc2l0aW9uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hPYmplY3QgU2VlIHRyYW5zaXRpb25Dcml0ZXJpYSBpbiB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyI29uICR0cmFuc2l0aW9uc1Byb3ZpZGVyLm9ufS5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBTZWUgY2FsbGJhY2sgaW4ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlciNvbiAkdHJhbnNpdGlvbnNQcm92aWRlci5vbn0uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5vbkZpbmlzaCA9IG1ha2VIb29rUmVnaXN0cmF0aW9uRm4odGhpcy5fdHJhbnNpdGlvbkV2ZW50cywgXCJvbkZpbmlzaFwiKTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb25TdWNjZXNzXG5cdCAgICAgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kdHJhbnNpdGlvbnNQcm92aWRlclxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQgd2hlbiBhIHRyYW5zaXRpb24gaGFzIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYmV0d2VlbiB0aGUgbWF0Y2hlZFxuXHQgICAgICAgICAqICd0bycgYW5kICdmcm9tJyBzdGF0ZSBpcyBiZWluZyBleGl0ZWQuXG5cdCAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBpbiBpbmplY3RlZCB3aXRoIHRoZSAndG8nIHN0YXRlJ3MgcmVzb2x2ZXMgKG5vdGU6IGBKSVRgIHJlc29sdmVzIGFyZSBub3QgaW5qZWN0ZWQpLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW5qZWN0ZWQgd2l0aCB0d28gYWRkaXRpb25hbCBzcGVjaWFsIHZhbHVlOlxuXHQgICAgICAgICAqIC0gKipgJHRyYW5zaXRpb24kYCoqOiBUaGUgY3VycmVudCB0cmFuc2l0aW9uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hPYmplY3QgU2VlIHRyYW5zaXRpb25Dcml0ZXJpYSBpbiB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyI29uICR0cmFuc2l0aW9uc1Byb3ZpZGVyLm9ufS5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCwgd2hlbiBhIG1hdGNoaW5nIHRyYW5zaXRpb24gaXMgc3RhcnRlZC5cblx0ICAgICAgICAgKiAgIFRoZSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMub25TdWNjZXNzID0gbWFrZUhvb2tSZWdpc3RyYXRpb25Gbih0aGlzLl90cmFuc2l0aW9uRXZlbnRzLCBcIm9uU3VjY2Vzc1wiKTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXIjb25FcnJvclxuXHQgICAgICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHRyYW5zaXRpb25zUHJvdmlkZXJcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRvIGJlIGluamVjdGVkIGFuZCBpbnZva2VkIHdoZW4gYSB0cmFuc2l0aW9uIGhhcyBmYWlsZWQgZm9yIGFueSByZWFzb24gYmV0d2VlbiB0aGUgbWF0Y2hlZFxuXHQgICAgICAgICAqICd0bycgYW5kICdmcm9tJyBzdGF0ZS4gVGhlIHRyYW5zaXRpb24gcmVqZWN0aW9uIHJlYXNvbiBpcyBpbmplY3RlZCBhcyBgJGVycm9yJGAuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hPYmplY3QgU2VlIHRyYW5zaXRpb25Dcml0ZXJpYSBpbiB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR0cmFuc2l0aW9uc1Byb3ZpZGVyI29uICR0cmFuc2l0aW9uc1Byb3ZpZGVyLm9ufS5cblx0ICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCwgd2hlbiBhIG1hdGNoaW5nIHRyYW5zaXRpb24gaXMgc3RhcnRlZC5cblx0ICAgICAgICAgKiAgIFRoZSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRoaXMub25FcnJvciA9IG1ha2VIb29rUmVnaXN0cmF0aW9uRm4odGhpcy5fdHJhbnNpdGlvbkV2ZW50cywgXCJvbkVycm9yXCIpO1xuXHQgICAgfVxuXHQgICAgSG9va1JlZ2lzdHJ5Lm1peGluID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0KSB7XG5cdCAgICAgICAgT2JqZWN0LmtleXMoc291cmNlLl90cmFuc2l0aW9uRXZlbnRzKS5jb25jYXQoW1wiZ2V0SG9va3NcIl0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEhvb2tSZWdpc3RyeTtcblx0fSgpKTtcblx0ZXhwb3J0cy5Ib29rUmVnaXN0cnkgPSBIb29rUmVnaXN0cnk7XG5cblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHN0cmluZ3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdHJhY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgcmVqZWN0RmFjdG9yeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdHZhciBtb2R1bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXHR2YXIgUkVKRUNUID0gbmV3IHJlamVjdEZhY3RvcnlfMS5SZWplY3RGYWN0b3J5KCk7XG5cdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0ICAgIGFzeW5jOiB0cnVlLFxuXHQgICAgcmVqZWN0SWZTdXBlcnNlZGVkOiB0cnVlLFxuXHQgICAgY3VycmVudDogY29tbW9uXzEubm9vcCxcblx0ICAgIHRyYW5zaXRpb246IG51bGwsXG5cdCAgICB0cmFjZURhdGE6IHt9LFxuXHQgICAgYmluZDogbnVsbFxuXHR9O1xuXHR2YXIgVHJhbnNpdGlvbkhvb2sgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVHJhbnNpdGlvbkhvb2soZm4sIGxvY2FscywgcmVzb2x2ZUNvbnRleHQsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuZm4gPSBmbjtcblx0ICAgICAgICB0aGlzLmxvY2FscyA9IGxvY2Fscztcblx0ICAgICAgICB0aGlzLnJlc29sdmVDb250ZXh0ID0gcmVzb2x2ZUNvbnRleHQ7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0ICAgICAgICB0aGlzLmlzU3VwZXJzZWRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wdGlvbnMuY3VycmVudCgpICE9PSBfdGhpcy5vcHRpb25zLnRyYW5zaXRpb247IH07XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSGFuZGxlcyB0cmFuc2l0aW9uIGFib3J0IGFuZCB0cmFuc2l0aW9uIHJlZGlyZWN0LiBBbHNvIGFkZHMgYW55IHJldHVybmVkIHJlc29sdmFibGVzXG5cdCAgICAgICAgICogdG8gdGhlIHBhdGhDb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXRoRWxlbWVudC4gIElmIHRoZSB0cmFuc2l0aW9uIGlzIHJlamVjdGVkLCB0aGVuIGEgcmVqZWN0ZWRcblx0ICAgICAgICAgKiBwcm9taXNlIGlzIHJldHVybmVkIGhlcmUsIG90aGVyd2lzZSB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5tYXBIb29rUmVzdWx0ID0gaG9mXzEucGF0dGVybihbXG5cdCAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnRcblx0ICAgICAgICAgICAgW3RoaXMuaXNTdXBlcnNlZGVkLCBmdW5jdGlvbiAoKSB7IHJldHVybiBSRUpFQ1Quc3VwZXJzZWRlZChfdGhpcy5vcHRpb25zLmN1cnJlbnQoKSk7IH1dLFxuXHQgICAgICAgICAgICAvLyBJZiB0aGUgaG9vayByZXR1cm5zIGZhbHNlLCBhYm9ydCB0aGUgY3VycmVudCBUcmFuc2l0aW9uXG5cdCAgICAgICAgICAgIFtob2ZfMS5lcShmYWxzZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJFSkVDVC5hYm9ydGVkKFwiSG9vayBhYm9ydGVkIHRyYW5zaXRpb25cIik7IH1dLFxuXHQgICAgICAgICAgICAvLyBJZiB0aGUgaG9vayByZXR1cm5zIGEgVHJhbnNpdGlvbiwgaGFsdCB0aGUgY3VycmVudCBUcmFuc2l0aW9uIGFuZCByZWRpcmVjdCB0byB0aGF0IFRyYW5zaXRpb24uXG5cdCAgICAgICAgICAgIFtob2ZfMS5pcyhtb2R1bGVfMS5UYXJnZXRTdGF0ZSksIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIFJFSkVDVC5yZWRpcmVjdGVkKHRhcmdldCk7IH1dLFxuXHQgICAgICAgICAgICAvLyBBIHByb21pc2Ugd2FzIHJldHVybmVkLCB3YWl0IGZvciB0aGUgcHJvbWlzZSBhbmQgdGhlbiBjaGFpbiBhbm90aGVyIGhvb2tIYW5kbGVyXG5cdCAgICAgICAgICAgIFtwcmVkaWNhdGVzXzEuaXNQcm9taXNlLCBmdW5jdGlvbiAocHJvbWlzZSkgeyByZXR1cm4gcHJvbWlzZS50aGVuKF90aGlzLmhhbmRsZUhvb2tSZXN1bHQuYmluZChfdGhpcykpOyB9XVxuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuaW52b2tlU3RlcCA9IGZ1bmN0aW9uIChtb3JlTG9jYWxzKSB7XG5cdCAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgZm4gPSBfYS5mbiwgcmVzb2x2ZUNvbnRleHQgPSBfYS5yZXNvbHZlQ29udGV4dDtcblx0ICAgICAgICAgICAgdmFyIGxvY2FscyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgX3RoaXMubG9jYWxzLCBtb3JlTG9jYWxzKTtcblx0ICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tJbnZvY2F0aW9uKF90aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVqZWN0SWZTdXBlcnNlZGVkICYmIF90aGlzLmlzU3VwZXJzZWRlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUkVKRUNULnN1cGVyc2VkZWQob3B0aW9ucy5jdXJyZW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgYmV0dGVyIGludGVncmF0aW9uIG9mIHJldHVybmVkIHByb21pc2VzIGluIHN5bmNocm9ub3VzIGNvZGUuXG5cdCAgICAgICAgICAgIGlmICghb3B0aW9ucy5hc3luYykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhvb2tSZXN1bHQgPSByZXNvbHZlQ29udGV4dC5pbnZva2VOb3coZm4sIGxvY2Fscywgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlSG9va1Jlc3VsdChob29rUmVzdWx0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbnRleHQuaW52b2tlTGF0ZXIoZm4sIGxvY2Fscywgb3B0aW9ucykudGhlbihfdGhpcy5oYW5kbGVIb29rUmVzdWx0LmJpbmQoX3RoaXMpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5oYW5kbGVIb29rUmVzdWx0ID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQpIHtcblx0ICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoaG9va1Jlc3VsdCkpXG5cdCAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZUhvb2tSZXN1bHQoaG9va1Jlc3VsdCwgdW5kZWZpbmVkLCB0aGlzLm9wdGlvbnMpO1xuXHQgICAgICAgIHZhciB0cmFuc2l0aW9uUmVzdWx0ID0gdGhpcy5tYXBIb29rUmVzdWx0KGhvb2tSZXN1bHQpO1xuXHQgICAgICAgIGlmICh0cmFuc2l0aW9uUmVzdWx0KVxuXHQgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlSG9va1Jlc3VsdChob29rUmVzdWx0LCB0cmFuc2l0aW9uUmVzdWx0LCB0aGlzLm9wdGlvbnMpO1xuXHQgICAgICAgIHJldHVybiB0cmFuc2l0aW9uUmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX2EgPSB0aGlzLCBvcHRpb25zID0gX2Eub3B0aW9ucywgZm4gPSBfYS5mbjtcblx0ICAgICAgICB2YXIgZXZlbnQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5ob29rVHlwZVwiKShvcHRpb25zKSB8fCBcImludGVybmFsXCIsIGNvbnRleHQgPSBob2ZfMS5wYXJzZShcInRyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWVcIikob3B0aW9ucykgfHwgaG9mXzEucGFyc2UoXCJ0cmFjZURhdGEuY29udGV4dFwiKShvcHRpb25zKSB8fCBcInVua25vd25cIiwgbmFtZSA9IHN0cmluZ3NfMS5mblRvU3RyaW5nKGZuKTtcblx0ICAgICAgICByZXR1cm4gZXZlbnQgKyBcIiBjb250ZXh0OiBcIiArIGNvbnRleHQgKyBcIiwgXCIgKyBzdHJpbmdzXzEubWF4TGVuZ3RoKDIwMCwgbmFtZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBUcmFuc2l0aW9uSG9va3MsIHJ1bnMgZWFjaCBvbmUgc3luY2hyb25vdXNseSBhbmQgc2VxdWVudGlhbGx5LlxuXHQgICAgICpcblx0ICAgICAqIFJldHVybnMgYSBwcm9taXNlIGNoYWluIGNvbXBvc2VkIG9mIGFueSBwcm9taXNlcyByZXR1cm5lZCBmcm9tIGVhY2ggaG9vay5pbnZva2VTdGVwKCkgY2FsbFxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uSG9vay5ydW5TeW5jaHJvbm91c0hvb2tzID0gZnVuY3Rpb24gKGhvb2tzLCBsb2NhbHMsIHN3YWxsb3dFeGNlcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKGxvY2FscyA9PT0gdm9pZCAwKSB7IGxvY2FscyA9IHt9OyB9XG5cdCAgICAgICAgaWYgKHN3YWxsb3dFeGNlcHRpb25zID09PSB2b2lkIDApIHsgc3dhbGxvd0V4Y2VwdGlvbnMgPSBmYWxzZTsgfVxuXHQgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGhvb2tzW2ldLmludm9rZVN0ZXAobG9jYWxzKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFzd2FsbG93RXhjZXB0aW9ucylcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUkVKRUNULmFib3J0ZWQoZXhjZXB0aW9uKTtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3dhbGxvd2VkIGV4Y2VwdGlvbiBkdXJpbmcgc3luY2hyb25vdXMgaG9vayBoYW5kbGVyOiBcIiArIGV4Y2VwdGlvbik7IC8vIFRPRE86IFdoYXQgdG8gZG8gaGVyZT9cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVqZWN0aW9ucyA9IHJlc3VsdHMuZmlsdGVyKFRyYW5zaXRpb25Ib29rLmlzUmVqZWN0aW9uKTtcblx0ICAgICAgICBpZiAocmVqZWN0aW9ucy5sZW5ndGgpXG5cdCAgICAgICAgICAgIHJldHVybiByZWplY3Rpb25zWzBdO1xuXHQgICAgICAgIHJldHVybiByZXN1bHRzXG5cdCAgICAgICAgICAgIC5maWx0ZXIoaG9mXzEubm90KFRyYW5zaXRpb25Ib29rLmlzUmVqZWN0aW9uKSlcblx0ICAgICAgICAgICAgLmZpbHRlcihwcmVkaWNhdGVzXzEuaXNQcm9taXNlKVxuXHQgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjaGFpbiwgcHJvbWlzZSkgeyByZXR1cm4gY2hhaW4udGhlbihob2ZfMS52YWwocHJvbWlzZSkpOyB9LCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKCkpO1xuXHQgICAgfTtcblx0ICAgIFRyYW5zaXRpb25Ib29rLmlzUmVqZWN0aW9uID0gZnVuY3Rpb24gKGhvb2tSZXN1bHQpIHtcblx0ICAgICAgICByZXR1cm4gaG9va1Jlc3VsdCAmJiBob29rUmVzdWx0LnJlYXNvbiBpbnN0YW5jZW9mIHJlamVjdEZhY3RvcnlfMS5UcmFuc2l0aW9uUmVqZWN0aW9uICYmIGhvb2tSZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRyYW5zaXRpb25Ib29rO1xuXHR9KCkpO1xuXHRleHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0ZnVuY3Rpb24gX19leHBvcnQobSkge1xuXHQgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xuXHR9XG5cdC8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygyNikpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMzQpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygzNSkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMzcpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygyNykpO1xuXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBvYmplY3Rcblx0ICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyXG5cdCAqXG5cdCAqIEByZXF1aXJlcyB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuXHQgKiBAcmVxdWlyZXMgdWkucm91dGVyLnV0aWwuJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFRoZSBuZXcgYCRzdGF0ZVByb3ZpZGVyYCB3b3JrcyBzaW1pbGFyIHRvIEFuZ3VsYXIncyB2MSByb3V0ZXIsIGJ1dCBpdCBmb2N1c2VzIHB1cmVseVxuXHQgKiBvbiBzdGF0ZS5cblx0ICpcblx0ICogQSBzdGF0ZSBjb3JyZXNwb25kcyB0byBhIFwicGxhY2VcIiBpbiB0aGUgYXBwbGljYXRpb24gaW4gdGVybXMgb2YgdGhlIG92ZXJhbGwgVUkgYW5kXG5cdCAqIG5hdmlnYXRpb24uIEEgc3RhdGUgZGVzY3JpYmVzICh2aWEgdGhlIGNvbnRyb2xsZXIgLyB0ZW1wbGF0ZSAvIHZpZXcgcHJvcGVydGllcykgd2hhdFxuXHQgKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuXHQgKlxuXHQgKiBTdGF0ZXMgb2Z0ZW4gaGF2ZSB0aGluZ3MgaW4gY29tbW9uLCBhbmQgdGhlIHByaW1hcnkgd2F5IG9mIGZhY3RvcmluZyBvdXQgdGhlc2Vcblx0ICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG5cdCAqIG5lc3RlZCBzdGF0ZXMuXG5cdCAqXG5cdCAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuXHQgKi9cblx0dmFyIFN0YXRlUHJvdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGVQcm92aWRlcihzdGF0ZVJlZ2lzdHJ5KSB7XG5cdCAgICAgICAgdGhpcy5zdGF0ZVJlZ2lzdHJ5ID0gc3RhdGVSZWdpc3RyeTtcblx0ICAgICAgICB0aGlzLmludmFsaWRDYWxsYmFja3MgPSBbXTtcblx0ICAgICAgICBjb21tb25fMS5iaW5kRnVuY3Rpb25zKFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLCB0aGlzLCB0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXIjZGVjb3JhdG9yXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBBbGxvd3MgeW91IHRvIGV4dGVuZCAoY2FyZWZ1bGx5KSBvciBvdmVycmlkZSAoYXQgeW91ciBvd24gcGVyaWwpIHRoZVxuXHQgICAgICogYHN0YXRlQnVpbGRlcmAgb2JqZWN0IHVzZWQgaW50ZXJuYWxseSBieSBgJHN0YXRlUHJvdmlkZXJgLiBUaGlzIGNhbiBiZSB1c2VkXG5cdCAgICAgKiB0byBhZGQgY3VzdG9tIGZ1bmN0aW9uYWxpdHkgdG8gdWktcm91dGVyLCBmb3IgZXhhbXBsZSBpbmZlcnJpbmcgdGVtcGxhdGVVcmxcblx0ICAgICAqIGJhc2VkIG9uIHRoZSBzdGF0ZSBuYW1lLlxuXHQgICAgICpcblx0ICAgICAqIFdoZW4gcGFzc2luZyBvbmx5IGEgbmFtZSwgaXQgcmV0dXJucyB0aGUgY3VycmVudCAob3JpZ2luYWwgb3IgZGVjb3JhdGVkKSBidWlsZGVyXG5cdCAgICAgKiBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgYG5hbWVgLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBidWlsZGVyIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBkZWNvcmF0ZWQgYXJlIGxpc3RlZCBiZWxvdy4gVGhvdWdoIG5vdCBhbGxcblx0ICAgICAqIG5lY2Vzc2FyaWx5IGhhdmUgYSBnb29kIHVzZSBjYXNlIGZvciBkZWNvcmF0aW9uLCB0aGF0IGlzIHVwIHRvIHlvdSB0byBkZWNpZGUuXG5cdCAgICAgKlxuXHQgICAgICogSW4gYWRkaXRpb24sIHVzZXJzIGNhbiBhdHRhY2ggY3VzdG9tIGRlY29yYXRvcnMsIHdoaWNoIHdpbGwgZ2VuZXJhdGUgbmV3XG5cdCAgICAgKiBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgc3RhdGUncyBpbnRlcm5hbCBkZWZpbml0aW9uLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gY2xlYXJcblx0ICAgICAqIHVzZS1jYXNlIGZvciB0aGlzIGJleW9uZCBhY2Nlc3NpbmcgaW50ZXJuYWwgc3RhdGVzIChpLmUuICRzdGF0ZS4kY3VycmVudCksXG5cdCAgICAgKiBob3dldmVyLCBleHBlY3QgdGhpcyB0byBiZWNvbWUgaW5jcmVhc2luZ2x5IHJlbGV2YW50IGFzIHdlIGludHJvZHVjZSBhZGRpdGlvbmFsXG5cdCAgICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuXHQgICAgICpcblx0ICAgICAqICoqV2FybmluZyoqOiBEZWNvcmF0b3JzIHNob3VsZCBub3QgYmUgaW50ZXJkZXBlbmRlbnQgYmVjYXVzZSB0aGUgb3JkZXIgb2Zcblx0ICAgICAqIGV4ZWN1dGlvbiBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbnMgaW4gbm9uLWRldGVybWluaXN0aWMuIEJ1aWxkZXIgZnVuY3Rpb25zXG5cdCAgICAgKiBzaG91bGQgb25seSBiZSBkZXBlbmRlbnQgb24gdGhlIHN0YXRlIGRlZmluaXRpb24gb2JqZWN0IGFuZCBzdXBlciBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKlxuXHQgICAgICogRXhpc3RpbmcgYnVpbGRlciBmdW5jdGlvbnMgYW5kIGN1cnJlbnQgcmV0dXJuIHZhbHVlczpcblx0ICAgICAqXG5cdCAgICAgKiAtICoqcGFyZW50KiogYHtvYmplY3R9YCAtIHJldHVybnMgdGhlIHBhcmVudCBzdGF0ZSBvYmplY3QuXG5cdCAgICAgKiAtICoqZGF0YSoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIHN0YXRlIGRhdGEsIGluY2x1ZGluZyBhbnkgaW5oZXJpdGVkIGRhdGEgdGhhdCBpcyBub3Rcblx0ICAgICAqICAgb3ZlcnJpZGRlbiBieSBvd24gdmFsdWVzIChpZiBhbnkpLlxuXHQgICAgICogLSAqKnVybCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfVxuXHQgICAgICogICBvciBgbnVsbGAuXG5cdCAgICAgKiAtICoqbmF2aWdhYmxlKiogYHtvYmplY3R9YCAtIHJldHVybnMgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoYWthIGlzXG5cdCAgICAgKiAgIG5hdmlnYWJsZSkuXG5cdCAgICAgKiAtICoqcGFyYW1zKiogYHtvYmplY3R9YCAtIHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGUgcGFyYW1zIHRoYXQgYXJlIGVuc3VyZWQgdG9cblx0ICAgICAqICAgYmUgYSBzdXBlci1zZXQgb2YgcGFyZW50J3MgcGFyYW1zLlxuXHQgICAgICogLSAqKnZpZXdzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB2aWV3cyBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYW4gYWJzb2x1dGUgdmlld1xuXHQgICAgICogICBuYW1lIChpLmUuIFwidmlld05hbWVAc3RhdGVOYW1lXCIpIGFuZCBlYWNoIHZhbHVlIGlzIHRoZSBjb25maWcgb2JqZWN0XG5cdCAgICAgKiAgICh0ZW1wbGF0ZSwgY29udHJvbGxlcikgZm9yIHRoZSB2aWV3LiBFdmVuIHdoZW4geW91IGRvbid0IHVzZSB0aGUgdmlld3Mgb2JqZWN0XG5cdCAgICAgKiAgIGV4cGxpY2l0bHkgb24gYSBzdGF0ZSBjb25maWcsIG9uZSBpcyBzdGlsbCBjcmVhdGVkIGZvciB5b3UgaW50ZXJuYWxseS5cblx0ICAgICAqICAgU28gYnkgZGVjb3JhdGluZyB0aGlzIGJ1aWxkZXIgZnVuY3Rpb24geW91IGhhdmUgYWNjZXNzIHRvIGRlY29yYXRpbmcgdGVtcGxhdGVcblx0ICAgICAqICAgYW5kIGNvbnRyb2xsZXIgcHJvcGVydGllcy5cblx0ICAgICAqIC0gKipvd25QYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlLFxuXHQgICAgICogICBub3QgaW5jbHVkaW5nIGFueSBwYXJhbXMgZGVmaW5lZCBieSBhbmNlc3RvciBzdGF0ZXMuXG5cdCAgICAgKiAtICoqcGF0aCoqIGB7c3RyaW5nfWAgLSByZXR1cm5zIHRoZSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUuXG5cdCAgICAgKiAgIE5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cblx0ICAgICAqIC0gKippbmNsdWRlcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIGV2ZXJ5IHN0YXRlIHRoYXRcblx0ICAgICAqICAgd291bGQgcGFzcyBhIGAkc3RhdGUuaW5jbHVkZXMoKWAgdGVzdC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogPHByZT5cblx0ICAgICAqIC8vIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXG5cdCAgICAgKiAvLyBkZWZpbml0aW9uLCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIGJlaW5nIG92ZXJyaWRkZW46XG5cdCAgICAgKiAkc3RhdGVQcm92aWRlci5kZWNvcmF0b3IoJ3ZpZXdzJywgZnVuY3Rpb24gKHN0YXRlLCBwYXJlbnQpIHtcblx0ICAgICAqICAgbGV0IHJlc3VsdCA9IHt9LFxuXHQgICAgICogICAgICAgdmlld3MgPSBwYXJlbnQoc3RhdGUpO1xuXHQgICAgICpcblx0ICAgICAqICAgYW5ndWxhci5mb3JFYWNoKHZpZXdzLCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG5cdCAgICAgKiAgICAgbGV0IGF1dG9OYW1lID0gKHN0YXRlLm5hbWUgKyAnLicgKyBuYW1lKS5yZXBsYWNlKCcuJywgJy8nKTtcblx0ICAgICAqICAgICBjb25maWcudGVtcGxhdGVVcmwgPSBjb25maWcudGVtcGxhdGVVcmwgfHwgJy9wYXJ0aWFscy8nICsgYXV0b05hbWUgKyAnLmh0bWwnO1xuXHQgICAgICogICAgIHJlc3VsdFtuYW1lXSA9IGNvbmZpZztcblx0ICAgICAqICAgfSk7XG5cdCAgICAgKiAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnaG9tZScsIHtcblx0ICAgICAqICAgdmlld3M6IHtcblx0ICAgICAqICAgICAnY29udGFjdC5saXN0JzogeyBjb250cm9sbGVyOiAnTGlzdENvbnRyb2xsZXInIH0sXG5cdCAgICAgKiAgICAgJ2NvbnRhY3QuaXRlbSc6IHsgY29udHJvbGxlcjogJ0l0ZW1Db250cm9sbGVyJyB9XG5cdCAgICAgKiAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIC8vIC4uLlxuXHQgICAgICpcblx0ICAgICAqICRzdGF0ZS5nbygnaG9tZScpO1xuXHQgICAgICogLy8gQXV0by1wb3B1bGF0ZXMgbGlzdCBhbmQgaXRlbSB2aWV3cyB3aXRoIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvbGlzdC5odG1sLFxuXHQgICAgICogLy8gYW5kIC9wYXJ0aWFscy9ob21lL2NvbnRhY3QvaXRlbS5odG1sLCByZXNwZWN0aXZlbHkuXG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbiB0byBkZWNvcmF0ZS5cblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmdW5jIEEgZnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgZGVjb3JhdGluZyB0aGUgb3JpZ2luYWxcblx0ICAgICAqIGJ1aWxkZXIgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0d28gcGFyYW1ldGVyczpcblx0ICAgICAqXG5cdCAgICAgKiAgIC0gYHtvYmplY3R9YCAtIHN0YXRlIC0gVGhlIHN0YXRlIGNvbmZpZyBvYmplY3QuXG5cdCAgICAgKiAgIC0gYHtvYmplY3R9YCAtIHN1cGVyIC0gVGhlIG9yaWdpbmFsIGJ1aWxkZXIgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7b2JqZWN0fSAkc3RhdGVQcm92aWRlciAtICRzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLmRlY29yYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IobmFtZSwgZnVuYykgfHwgdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyI3N0YXRlXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBSZWdpc3RlcnMgYSBzdGF0ZSBjb25maWd1cmF0aW9uIHVuZGVyIGEgZ2l2ZW4gc3RhdGUgbmFtZS4gVGhlIHN0YXRlQ29uZmlnIG9iamVjdFxuXHQgICAgICogaGFzIHRoZSBmb2xsb3dpbmcgYWNjZXB0YWJsZSBwcm9wZXJ0aWVzLlxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSd0ZW1wbGF0ZSc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgdGVtcGxhdGVgKiogLSB7c3RyaW5nfGZ1bmN0aW9uPX0gLSBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG5cdCAgICAgKiAgIGFuIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgd2hpY2ggc2hvdWxkIGJlIHVzZWQgYnkgdGhlIHVpVmlldyBkaXJlY3RpdmVzLiBUaGlzIHByb3BlcnR5XG5cdCAgICAgKiAgIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0ZW1wbGF0ZVVybC5cblx0ICAgICAqXG5cdCAgICAgKiAgIElmIGB0ZW1wbGF0ZWAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdCAgICAgKlxuXHQgICAgICogICAtIHthcnJheS4mbHQ7b2JqZWN0Jmd0O30gLSBzdGF0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50ICRsb2NhdGlvbi5wYXRoKCkgYnlcblx0ICAgICAqICAgICBhcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZVxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSd0ZW1wbGF0ZVVybCc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgdGVtcGxhdGVVcmxgKiogLSB7c3RyaW5nfGZ1bmN0aW9uPX0gLSBwYXRoIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGggdG8gYW4gaHRtbFxuXHQgICAgICogICB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IHVpVmlldy5cblx0ICAgICAqXG5cdCAgICAgKiAgIElmIGB0ZW1wbGF0ZVVybGAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdCAgICAgKlxuXHQgICAgICogICAtIHthcnJheS4mbHQ7b2JqZWN0Jmd0O30gLSBzdGF0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50ICRsb2NhdGlvbi5wYXRoKCkgYnlcblx0ICAgICAqICAgICBhcHBseWluZyB0aGUgY3VycmVudCBzdGF0ZVxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSd0ZW1wbGF0ZVByb3ZpZGVyJz48L2E+XG5cdCAgICAgKlxuXHQgICAgICogLSAqKmB0ZW1wbGF0ZVByb3ZpZGVyYCoqIC0ge2Z1bmN0aW9uPX0gLSBQcm92aWRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgSFRNTCBjb250ZW50XG5cdCAgICAgKiAgIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiA8YSBpZD0nY29udHJvbGxlcic+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgY29udHJvbGxlcmAqKiAtIHtzdHJpbmd8ZnVuY3Rpb249fSAtICBDb250cm9sbGVyIGZuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCBuZXdseVxuXHQgICAgICogICByZWxhdGVkIHNjb3BlIG9yIHRoZSBuYW1lIG9mIGEgcmVnaXN0ZXJlZCBjb250cm9sbGVyIGlmIHBhc3NlZCBhcyBhIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiA8YSBpZD0nY29udHJvbGxlclByb3ZpZGVyJz48L2E+XG5cdCAgICAgKlxuXHQgICAgICogLSAqKmBjb250cm9sbGVyUHJvdmlkZXJgKiogLSB7ZnVuY3Rpb249fSAtIEluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG5cdCAgICAgKiAgIHRoZSBhY3R1YWwgY29udHJvbGxlciBvciBzdHJpbmcuXG5cdCAgICAgKlxuXHQgICAgICogPGEgaWQ9J2NvbnRyb2xsZXJBcyc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgY29udHJvbGxlckFzYCoqIOKAkyB7c3RyaW5nPX0g4oCTIEEgY29udHJvbGxlciBhbGlhcyBuYW1lLiBJZiBwcmVzZW50IHRoZSBjb250cm9sbGVyIHdpbGwgYmVcblx0ICAgICAqICAgcHVibGlzaGVkIHRvIHNjb3BlIHVuZGVyIHRoZSBjb250cm9sbGVyQXMgbmFtZS5cblx0ICAgICAqXG5cdCAgICAgKiA8YSBpZD0ncmVzb2x2ZSc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgcmVzb2x2ZWAqKiAtIHtvYmplY3QuJmx0O3N0cmluZywgZnVuY3Rpb24mZ3Q7PX0gLSBBbiBvcHRpb25hbCBtYXAgb2YgZGVwZW5kZW5jaWVzIHdoaWNoXG5cdCAgICAgKiAgIHNob3VsZCBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb250cm9sbGVyLiBJZiBhbnkgb2YgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBwcm9taXNlcyxcblx0ICAgICAqICAgdGhlIHJvdXRlciB3aWxsIHdhaXQgZm9yIHRoZW0gYWxsIHRvIGJlIHJlc29sdmVkIG9yIG9uZSB0byBiZSByZWplY3RlZCBiZWZvcmUgdGhlXG5cdCAgICAgKiAgIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiBJZiBhbGwgdGhlIHByb21pc2VzIGFyZSByZXNvbHZlZCBzdWNjZXNzZnVsbHksIHRoZSB2YWx1ZXNcblx0ICAgICAqICAgb2YgdGhlIHJlc29sdmVkIHByb21pc2VzIGFyZSBpbmplY3RlZCBhbmQgJHN0YXRlQ2hhbmdlU3VjY2VzcyBldmVudCBpcyBmaXJlZC4gSWYgYW55XG5cdCAgICAgKiAgIG9mIHRoZSBwcm9taXNlcyBhcmUgcmVqZWN0ZWQgdGhlICRzdGF0ZUNoYW5nZUVycm9yIGV2ZW50IGlzIGZpcmVkLiBUaGUgbWFwIG9iamVjdCBpczpcblx0ICAgICAqXG5cdCAgICAgKiAgIC0ga2V5IC0ge3N0cmluZ306IG5hbWUgb2YgZGVwZW5kZW5jeSB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJcblx0ICAgICAqICAgLSBmYWN0b3J5IC0ge3N0cmluZ3xmdW5jdGlvbn06IElmIHN0cmluZyB0aGVuIGl0IGlzIGFsaWFzIGZvciBzZXJ2aWNlLiBPdGhlcndpc2UgaWYgZnVuY3Rpb24sXG5cdCAgICAgKiAgICAgaXQgaXMgaW5qZWN0ZWQgYW5kIHJldHVybiB2YWx1ZSBpdCB0cmVhdGVkIGFzIGRlcGVuZGVuY3kuIElmIHJlc3VsdCBpcyBhIHByb21pc2UsIGl0IGlzXG5cdCAgICAgKiAgICAgcmVzb2x2ZWQgYmVmb3JlIGl0cyB2YWx1ZSBpcyBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXIuXG5cdCAgICAgKlxuXHQgICAgICogPGEgaWQ9J3VybCc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgdXJsYCoqIC0ge3N0cmluZz19IC0gQSB1cmwgd2l0aCBvcHRpb25hbCBwYXJhbWV0ZXJzLiBXaGVuIGEgc3RhdGUgaXMgbmF2aWdhdGVkIG9yXG5cdCAgICAgKiAgIHRyYW5zaXRpb25lZCB0bywgdGhlIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhbnlcblx0ICAgICAqICAgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkLlxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSdwYXJhbXMnPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYHBhcmFtc2AqKiAtIHtvYmplY3Q9fSAtIEFuIGFycmF5IG9mIHBhcmFtZXRlciBuYW1lcyBvciByZWd1bGFyIGV4cHJlc3Npb25zLiBPbmx5XG5cdCAgICAgKiAgIHVzZSB0aGlzIHdpdGhpbiBhIHN0YXRlIGlmIHlvdSBhcmUgbm90IHVzaW5nIHVybC4gT3RoZXJ3aXNlIHlvdSBjYW4gc3BlY2lmeSB5b3VyXG5cdCAgICAgKiAgIHBhcmFtZXRlcnMgd2l0aGluIHRoZSB1cmwuIFdoZW4gYSBzdGF0ZSBpcyBuYXZpZ2F0ZWQgb3IgdHJhbnNpdGlvbmVkIHRvLCB0aGVcblx0ICAgICAqICAgJHN0YXRlUGFyYW1zIHNlcnZpY2Ugd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhbnkgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkLlxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSd2aWV3cyc+PC9hPlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgdmlld3NgKiogLSB7b2JqZWN0PX0gLSBVc2UgdGhlIHZpZXdzIHByb3BlcnR5IHRvIHNldCB1cCBtdWx0aXBsZSB2aWV3cyBvciB0byB0YXJnZXQgdmlld3Ncblx0ICAgICAqICAgbWFudWFsbHkvZXhwbGljaXRseS5cblx0ICAgICAqXG5cdCAgICAgKiA8YSBpZD0nYWJzdHJhY3QnPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYGFic3RyYWN0YCoqIC0ge2Jvb2xlYW49fSAtIEFuIGFic3RyYWN0IHN0YXRlIHdpbGwgbmV2ZXIgYmUgZGlyZWN0bHkgYWN0aXZhdGVkLFxuXHQgICAgICogICBidXQgY2FuIHByb3ZpZGUgaW5oZXJpdGVkIHByb3BlcnRpZXMgdG8gaXRzIGNvbW1vbiBjaGlsZHJlbiBzdGF0ZXMuXG5cdCAgICAgKlxuXHQgICAgICogPGEgaWQ9J29uRW50ZXInPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYG9uRW50ZXJgKiogLSB7b2JqZWN0PX0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3Igd2hlbiBhIHN0YXRlIGlzIGVudGVyZWQuIEdvb2Qgd2F5XG5cdCAgICAgKiAgIHRvIHRyaWdnZXIgYW4gYWN0aW9uIG9yIGRpc3BhdGNoIGFuIGV2ZW50LCBzdWNoIGFzIG9wZW5pbmcgYSBkaWFsb2cuXG5cdCAgICAgKiBJZiBtaW5pZnlpbmcgeW91ciBzY3JpcHRzLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBgWydpbmplY3Rpb24xJywgJ2luamVjdGlvbjInLCBmdW5jdGlvbihpbmplY3Rpb24xLCBpbmplY3Rpb24yKXt9XWAgc3ludGF4LlxuXHQgICAgICpcblx0ICAgICAqIDxhIGlkPSdvbkV4aXQnPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYG9uRXhpdGAqKiAtIHtvYmplY3Q9fSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIGEgc3RhdGUgaXMgZXhpdGVkLiBHb29kIHdheSB0b1xuXHQgICAgICogICB0cmlnZ2VyIGFuIGFjdGlvbiBvciBkaXNwYXRjaCBhbiBldmVudCwgc3VjaCBhcyBvcGVuaW5nIGEgZGlhbG9nLlxuXHQgICAgICogSWYgbWluaWZ5aW5nIHlvdXIgc2NyaXB0cywgbWFrZSBzdXJlIHRvIHVzZSB0aGUgYFsnaW5qZWN0aW9uMScsICdpbmplY3Rpb24yJywgZnVuY3Rpb24oaW5qZWN0aW9uMSwgaW5qZWN0aW9uMil7fV1gIHN5bnRheC5cblx0ICAgICAqXG5cdCAgICAgKiA8YSBpZD0ncmVsb2FkT25TZWFyY2gnPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYHJlbG9hZE9uU2VhcmNoID0gdHJ1ZWAqKiAtIHtib29sZWFuPX0gLSBJZiBgZmFsc2VgLCB3aWxsIG5vdCByZXRyaWdnZXIgdGhlIHNhbWUgc3RhdGVcblx0ICAgICAqICAganVzdCBiZWNhdXNlIGEgc2VhcmNoL3F1ZXJ5IHBhcmFtZXRlciBoYXMgY2hhbmdlZCAodmlhICRsb2NhdGlvbi5zZWFyY2goKSBvciAkbG9jYXRpb24uaGFzaCgpKS5cblx0ICAgICAqICAgVXNlZnVsIGZvciB3aGVuIHlvdSdkIGxpa2UgdG8gbW9kaWZ5ICRsb2NhdGlvbi5zZWFyY2goKSB3aXRob3V0IHRyaWdnZXJpbmcgYSByZWxvYWQuXG5cdCAgICAgKlxuXHQgICAgICogPGEgaWQ9J2RhdGEnPjwvYT5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqYGRhdGFgKiogLSB7b2JqZWN0PX0gLSBBcmJpdHJhcnkgZGF0YSBvYmplY3QsIHVzZWZ1bCBmb3IgY3VzdG9tIGNvbmZpZ3VyYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiAvLyBTb21lIHN0YXRlIG5hbWUgZXhhbXBsZXNcblx0ICAgICAqXG5cdCAgICAgKiAvLyBzdGF0ZU5hbWUgY2FuIGJlIGEgc2luZ2xlIHRvcC1sZXZlbCBuYW1lIChtdXN0IGJlIHVuaXF1ZSkuXG5cdCAgICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge30pO1xuXHQgICAgICpcblx0ICAgICAqIC8vIE9yIGl0IGNhbiBiZSBhIG5lc3RlZCBzdGF0ZSBuYW1lLiBUaGlzIHN0YXRlIGlzIGEgY2hpbGQgb2YgdGhlXG5cdCAgICAgKiAvLyBhYm92ZSBcImhvbWVcIiBzdGF0ZS5cblx0ICAgICAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZS5uZXdlc3RcIiwge30pO1xuXHQgICAgICpcblx0ICAgICAqIC8vIE5lc3Qgc3RhdGVzIGFzIGRlZXBseSBhcyBuZWVkZWQuXG5cdCAgICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWUubmV3ZXN0LmFiYy54eXouaW5jZXB0aW9uXCIsIHt9KTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyBzdGF0ZSgpIHJldHVybnMgJHN0YXRlUHJvdmlkZXIsIHNvIHlvdSBjYW4gY2hhaW4gc3RhdGUgZGVjbGFyYXRpb25zLlxuXHQgICAgICogJHN0YXRlUHJvdmlkZXJcblx0ICAgICAqICAgLnN0YXRlKFwiaG9tZVwiLCB7fSlcblx0ICAgICAqICAgLnN0YXRlKFwiYWJvdXRcIiwge30pXG5cdCAgICAgKiAgIC5zdGF0ZShcImNvbnRhY3RzXCIsIHt9KTtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdW5pcXVlIHN0YXRlIG5hbWUsIGUuZy4gXCJob21lXCIsIFwiYWJvdXRcIiwgXCJjb250YWN0c1wiLlxuXHQgICAgICogVG8gY3JlYXRlIGEgcGFyZW50L2NoaWxkIHN0YXRlIHVzZSBhIGRvdCwgZS5nLiBcImFib3V0LnNhbGVzXCIsIFwiaG9tZS5uZXdlc3RcIi5cblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZpbml0aW9uIFN0YXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICBTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc09iamVjdChuYW1lKSkge1xuXHQgICAgICAgICAgICBkZWZpbml0aW9uID0gbmFtZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuc3RhdGVSZWdpc3RyeS5yZWdpc3RlcihkZWZpbml0aW9uKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVByb3ZpZGVyI29uSW52YWxpZFxuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVQcm92aWRlclxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgaW5qZWN0ZWQgYW5kIGludm9rZWQgd2hlbiB0cmFuc2l0aW9uVG8gaGFzIGJlZW4gY2FsbGVkIHdpdGggYW4gaW52YWxpZFxuXHQgICAgICogc3RhdGUgcmVmZXJlbmNlIHBhcmFtZXRlclxuXHQgICAgICpcblx0ICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGluamVjdGVkIHdpdGggb25lIHNvbWUgc3BlY2lhbCB2YWx1ZXM6XG5cdCAgICAgKiAtICoqYCR0byRgKio6IFRhcmdldFN0YXRlXG5cdCAgICAgKiAtICoqYCRmcm9tJGAqKjogVGFyZ2V0U3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgICAgICogICBUaGUgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbmplY3RlZCBhbmQgaW52b2tlZCwgd2hlbiBhIG1hdGNoaW5nIHRyYW5zaXRpb24gaXMgc3RhcnRlZC5cblx0ICAgICAqICAgVGhlIGZ1bmN0aW9uIG1heSBvcHRpb25hbGx5IHJldHVybiBhIHtUYXJnZXRTdGF0ZX0gb3IgYSBQcm9taXNlIGZvciBhIFRhcmdldFN0YXRlLiAgSWYgb25lXG5cdCAgICAgKiAgIGlzIHJldHVybmVkLCBpdCBpcyB0cmVhdGVkIGFzIGEgcmVkaXJlY3QuXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLm9uSW52YWxpZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuaW52YWxpZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3RhdGVQcm92aWRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5TdGF0ZVByb3ZpZGVyID0gU3RhdGVQcm92aWRlcjtcblxuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHByZWRpY2F0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBob2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBtb2R1bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgcGFyc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG5cdCAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyh1cmwpKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciByb290ID0gdXJsLmNoYXJBdCgwKSA9PT0gJ14nO1xuXHQgICAgcmV0dXJuIHsgdmFsOiByb290ID8gdXJsLnN1YnN0cmluZygxKSA6IHVybCwgcm9vdDogcm9vdCB9O1xuXHR9O1xuXHQvKipcblx0ICogQGludGVybmFsYXBpIEEgaW50ZXJuYWwgZ2xvYmFsIHNlcnZpY2Vcblx0ICpcblx0ICogU3RhdGVCdWlsZGVyIGlzIGEgZmFjdG9yeSBmb3IgdGhlIGludGVybmFsIFtbU3RhdGVdXSBvYmplY3RzLlxuXHQgKlxuXHQgKiBXaGVuIHlvdSByZWdpc3RlciBhIHN0YXRlIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLCB5b3UgcmVnaXN0ZXIgYSBwbGFpbiBvbGQgamF2YXNjcmlwdCBvYmplY3Qgd2hpY2hcblx0ICogY29uZm9ybXMgdG8gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dIGludGVyZmFjZS4gIFRoaXMgZmFjdG9yeSB0YWtlcyB0aGF0IG9iamVjdCBhbmQgYnVpbGRzIHRoZSBjb3JyZXNwb25kaW5nXG5cdCAqIFtbU3RhdGVdXSBvYmplY3QsIHdoaWNoIGhhcyBhbiBBUEkgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cblx0ICpcblx0ICogQ3VzdG9tIHByb3BlcnRpZXMgb3IgQVBJIG1heSBiZSBhZGRlZCB0byB0aGUgaW50ZXJuYWwgW1tTdGF0ZV1dIG9iamVjdCBieSByZWdpc3RlcmluZyBhIGRlY29yYXRvciBmdW5jdGlvblxuXHQgKiB1c2luZyB0aGUgW1tidWlsZGVyXV0gbWV0aG9kLlxuXHQgKi9cblx0dmFyIFN0YXRlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBTdGF0ZUJ1aWxkZXIobWF0Y2hlciwgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXIpIHtcblx0ICAgICAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgICB2YXIgaXNSb290ID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5uYW1lID09PSBcIlwiOyB9O1xuXHQgICAgICAgIHZhciByb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlci5maW5kKFwiXCIpOyB9O1xuXHQgICAgICAgIHRoaXMuYnVpbGRlcnMgPSB7XG5cdCAgICAgICAgICAgIHNlbGY6IFtmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZWxmLiQkc3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc2VsZjtcblx0ICAgICAgICAgICAgICAgIH1dLFxuXHQgICAgICAgICAgICBwYXJlbnQ6IFtmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNSb290KHN0YXRlKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuZmluZChzZWxmLnBhcmVudE5hbWUoc3RhdGUpKSB8fCByb290KCk7XG5cdCAgICAgICAgICAgICAgICB9XSxcblx0ICAgICAgICAgICAgZGF0YTogW2Z1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGNvbW1vbl8xLmluaGVyaXQoc3RhdGUucGFyZW50LmRhdGEsIHN0YXRlLmRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZGF0YTtcblx0ICAgICAgICAgICAgICAgIH1dLFxuXHQgICAgICAgICAgICAvLyBCdWlsZCBhIFVSTE1hdGNoZXIgaWYgbmVjZXNzYXJ5LCBlaXRoZXIgdmlhIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMXG5cdCAgICAgICAgICAgIHVybDogW2Z1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZURlYyA9IHN0YXRlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVVybChzdGF0ZURlYy51cmwpLCBwYXJlbnQgPSBzdGF0ZS5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9ICFwYXJzZWQgPyBzdGF0ZURlYy51cmwgOiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5jb21waWxlKHBhcnNlZC52YWwsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZS5wYXJhbXMgfHwge30sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtTWFwOiBmdW5jdGlvbiAocGFyYW1Db25maWcsIGlzU2VhcmNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVEZWMucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIGlzU2VhcmNoKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtQ29uZmlnID0gY29tbW9uXzEuZXh0ZW5kKHBhcmFtQ29uZmlnIHx8IHt9LCB7IGR5bmFtaWM6IHRydWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1Db25maWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXVybClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5pc01hdGNoZXIodXJsKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5yb290KSA/IHVybCA6ICgocGFyZW50ICYmIHBhcmVudC5uYXZpZ2FibGUpIHx8IHJvb3QoKSkudXJsLmFwcGVuZCh1cmwpO1xuXHQgICAgICAgICAgICAgICAgfV0sXG5cdCAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igc3RhdGUgdGhhdCBoYXMgYSBVUkwgKGkuZS4gaXMgbmF2aWdhYmxlKVxuXHQgICAgICAgICAgICBuYXZpZ2FibGU6IFtmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzUm9vdChzdGF0ZSkgJiYgc3RhdGUudXJsID8gc3RhdGUgOiAoc3RhdGUucGFyZW50ID8gc3RhdGUucGFyZW50Lm5hdmlnYWJsZSA6IG51bGwpO1xuXHQgICAgICAgICAgICAgICAgfV0sXG5cdCAgICAgICAgICAgIHBhcmFtczogW2Z1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtYWtlQ29uZmlnUGFyYW0gPSBmdW5jdGlvbiAoY29uZmlnLCBpZCkgeyByZXR1cm4gbW9kdWxlXzEuUGFyYW0uZnJvbUNvbmZpZyhpZCwgbnVsbCwgY29uZmlnKTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdXJsUGFyYW1zID0gKHN0YXRlLnVybCAmJiBzdGF0ZS51cmwucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pKSB8fCBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbm9uVXJsUGFyYW1zID0gY29tbW9uXzEudmFsdWVzKGNvbW1vbl8xLm1hcChjb21tb25fMS5vbWl0KHN0YXRlLnBhcmFtcyB8fCB7fSwgdXJsUGFyYW1zLm1hcChob2ZfMS5wcm9wKCdpZCcpKSksIG1ha2VDb25maWdQYXJhbSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxQYXJhbXMuY29uY2F0KG5vblVybFBhcmFtcykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBbcC5pZCwgcF07IH0pLnJlZHVjZShjb21tb25fMS5hcHBseVBhaXJzLCB7fSk7XG5cdCAgICAgICAgICAgICAgICB9XSxcblx0ICAgICAgICAgICAgLy8gRWFjaCBmcmFtZXdvcmstc3BlY2lmaWMgdWktcm91dGVyIGltcGxlbWVudGF0aW9uIHNob3VsZCBkZWZpbmUgaXRzIG93biBgdmlld3NgIGJ1aWxkZXJcblx0ICAgICAgICAgICAgLy8gZS5nLiwgc3JjL25nMS92aWV3c0J1aWxkZXIudHNcblx0ICAgICAgICAgICAgdmlld3M6IFtdLFxuXHQgICAgICAgICAgICAvLyBLZWVwIGEgZnVsbCBwYXRoIGZyb20gdGhlIHJvb3QgZG93biB0byB0aGlzIHN0YXRlIGFzIHRoaXMgaXMgbmVlZGVkIGZvciBzdGF0ZSBhY3RpdmF0aW9uLlxuXHQgICAgICAgICAgICBwYXRoOiBbZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiBbc3RhdGVdO1xuXHQgICAgICAgICAgICAgICAgfV0sXG5cdCAgICAgICAgICAgIC8vIFNwZWVkIHVwICRzdGF0ZS5pbmNsdWRlcygpIGFzIGl0J3MgdXNlZCBhIGxvdFxuXHQgICAgICAgICAgICBpbmNsdWRlczogW2Z1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlcyA9IHN0YXRlLnBhcmVudCA/IGNvbW1vbl8xLmV4dGVuZCh7fSwgc3RhdGUucGFyZW50LmluY2x1ZGVzKSA6IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVzW3N0YXRlLm5hbWVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5jbHVkZXM7XG5cdCAgICAgICAgICAgICAgICB9XVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJlZ2lzdGVycyBhIFtbQnVpbGRlckZ1bmN0aW9uXV0gZm9yIGEgc3BlY2lmaWMgW1tTdGF0ZV1dIHByb3BlcnR5IChlLmcuLCBgcGFyZW50YCwgYHVybGAsIG9yIGBwYXRoYCkuXG5cdCAgICAgKiBNb3JlIHRoYW4gb25lIEJ1aWxkZXJGdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgQnVpbGRlckZ1bmN0aW9uKHMpIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIHByb3BlcnR5IG9uIGFueSBzdWJzZXF1ZW50bHkgYnVpbHQgW1tTdGF0ZV1dIG9iamVjdHMuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFN0YXRlIHByb3BlcnR5IGJlaW5nIHJlZ2lzdGVyZWQgZm9yLlxuXHQgICAgICogQHBhcmFtIGZuIFRoZSBCdWlsZGVyRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBTdGF0ZSBwcm9wZXJ0eVxuXHQgICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBkZXJlZ2lzdGVycyB0aGUgQnVpbGRlckZ1bmN0aW9uXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRlciA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuXHQgICAgICAgIHZhciBidWlsZGVycyA9IHRoaXMuYnVpbGRlcnM7XG5cdCAgICAgICAgdmFyIGFycmF5ID0gYnVpbGRlcnNbbmFtZV0gfHwgW107XG5cdCAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdDogaWYgb25seSBvbmUgYnVpbGRlciBleGlzdHMsIHJldHVybiBpdCwgZWxzZSByZXR1cm4gd2hvbGUgYXJhcnkuXG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSAmJiAhcHJlZGljYXRlc18xLmlzRGVmaW5lZChmbikpXG5cdCAgICAgICAgICAgIHJldHVybiBhcnJheS5sZW5ndGggPiAxID8gYXJyYXkgOiBhcnJheVswXTtcblx0ICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSB8fCAhcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZm4pKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgYnVpbGRlcnNbbmFtZV0gPSBhcnJheTtcblx0ICAgICAgICBidWlsZGVyc1tuYW1lXS5wdXNoKGZuKTtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRlcnNbbmFtZV0uc3BsaWNlKGJ1aWxkZXJzW25hbWVdLmluZGV4T2YoZm4sIDEpKSAmJiBudWxsOyB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQnVpbGRzIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvbiBhbiBlc3NlbnRpYWxseSBibGFuayBTdGF0ZSBvYmplY3QsIHJldHVybmluZyBhIFN0YXRlIG9iamVjdCB3aGljaCBoYXMgYWxsIGl0c1xuXHQgICAgICogcHJvcGVydGllcyBhbmQgQVBJIGJ1aWx0LlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBzdGF0ZSBhbiB1bmluaXRpYWxpemVkIFN0YXRlIG9iamVjdFxuXHQgICAgICogQHJldHVybnMgdGhlIGJ1aWx0IFN0YXRlIG9iamVjdFxuXHQgICAgICovXG5cdCAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcywgbWF0Y2hlciA9IF9hLm1hdGNoZXIsIGJ1aWxkZXJzID0gX2EuYnVpbGRlcnM7XG5cdCAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50TmFtZShzdGF0ZSk7XG5cdCAgICAgICAgaWYgKHBhcmVudCAmJiAhbWF0Y2hlci5maW5kKHBhcmVudCkpXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBidWlsZGVycykge1xuXHQgICAgICAgICAgICBpZiAoIWJ1aWxkZXJzLmhhc093blByb3BlcnR5KGtleSkpXG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgdmFyIGNoYWluID0gYnVpbGRlcnNba2V5XS5yZWR1Y2UoZnVuY3Rpb24gKHBhcmVudEZuLCBzdGVwKSB7IHJldHVybiBmdW5jdGlvbiAoX3N0YXRlKSB7IHJldHVybiBzdGVwKF9zdGF0ZSwgcGFyZW50Rm4pOyB9OyB9LCBjb21tb25fMS5ub29wKTtcblx0ICAgICAgICAgICAgc3RhdGVba2V5XSA9IGNoYWluKHN0YXRlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0YXRlO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUucGFyZW50TmFtZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZSB8fCBcIlwiO1xuXHQgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTEpXG5cdCAgICAgICAgICAgIHJldHVybiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpO1xuXHQgICAgICAgIGlmICghc3RhdGUucGFyZW50KVxuXHQgICAgICAgICAgICByZXR1cm4gXCJcIjtcblx0ICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcblx0ICAgIH07XG5cdCAgICBTdGF0ZUJ1aWxkZXIucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XG5cdCAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpICE9PSAtMSB8fCAhc3RhdGUucGFyZW50KVxuXHQgICAgICAgICAgICByZXR1cm4gbmFtZTtcblx0ICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZS5wYXJlbnQpID8gc3RhdGUucGFyZW50IDogc3RhdGUucGFyZW50Lm5hbWU7XG5cdCAgICAgICAgcmV0dXJuIHBhcmVudE5hbWUgPyBwYXJlbnROYW1lICsgXCIuXCIgKyBuYW1lIDogbmFtZTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3RhdGVCdWlsZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRlQnVpbGRlciA9IFN0YXRlQnVpbGRlcjtcblxuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRmdW5jdGlvbiBfX2V4cG9ydChtKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG5cdH1cblx0LyoqXG5cdCAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGNvZGUgZm9yIFN0YXRlIFBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqIFNlZSBbW1BhcmFtRGVjbGFyYXRpb25dXVxuXHQgKiBAbW9kdWxlIHBhcmFtc1xuXHQgKiBAcHJlZmVycmVkIGRvY1xuXHQgKi9cblx0LyoqIGZvciB0eXBlZG9jICovXG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMjMpKTtcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBwYXJhbXMgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBob2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgdXJsTWF0Y2hlckNvbmZpZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdHZhciB0eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0dmFyIHBhcmFtVHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXHR2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIGlzU2hvcnRoYW5kID0gZnVuY3Rpb24gKGNmZykgeyByZXR1cm4gW1widmFsdWVcIiwgXCJ0eXBlXCIsIFwic3F1YXNoXCIsIFwiYXJyYXlcIiwgXCJkeW5hbWljXCJdLmZpbHRlcihoYXNPd24uYmluZChjZmcgfHwge30pKS5sZW5ndGggPT09IDA7IH07XG5cdChmdW5jdGlvbiAoRGVmVHlwZSkge1xuXHQgICAgRGVmVHlwZVtEZWZUeXBlW1wiUEFUSFwiXSA9IDBdID0gXCJQQVRIXCI7XG5cdCAgICBEZWZUeXBlW0RlZlR5cGVbXCJTRUFSQ0hcIl0gPSAxXSA9IFwiU0VBUkNIXCI7XG5cdCAgICBEZWZUeXBlW0RlZlR5cGVbXCJDT05GSUdcIl0gPSAyXSA9IFwiQ09ORklHXCI7XG5cdH0pKGV4cG9ydHMuRGVmVHlwZSB8fCAoZXhwb3J0cy5EZWZUeXBlID0ge30pKTtcblx0dmFyIERlZlR5cGUgPSBleHBvcnRzLkRlZlR5cGU7XG5cdGZ1bmN0aW9uIHVud3JhcFNob3J0aGFuZChjZmcpIHtcblx0ICAgIGNmZyA9IGlzU2hvcnRoYW5kKGNmZykgJiYgeyB2YWx1ZTogY2ZnIH0gfHwgY2ZnO1xuXHQgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChjZmcsIHtcblx0ICAgICAgICAkJGZuOiBwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKGNmZy52YWx1ZSkgPyBjZmcudmFsdWUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjZmcudmFsdWU7IH1cblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFR5cGUoY2ZnLCB1cmxUeXBlLCBsb2NhdGlvbiwgaWQpIHtcblx0ICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSAhPT0gJ3N0cmluZycpXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW0gJ1wiICsgaWQgKyBcIicgaGFzIHR3byB0eXBlIGNvbmZpZ3VyYXRpb25zLlwiKTtcblx0ICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSA9PT0gJ3N0cmluZycgJiYgcGFyYW1UeXBlc18xLnBhcmFtVHlwZXMudHlwZShjZmcudHlwZSkpXG5cdCAgICAgICAgcmV0dXJuIHBhcmFtVHlwZXNfMS5wYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xuXHQgICAgaWYgKHVybFR5cGUpXG5cdCAgICAgICAgcmV0dXJuIHVybFR5cGU7XG5cdCAgICBpZiAoIWNmZy50eXBlKVxuXHQgICAgICAgIHJldHVybiAobG9jYXRpb24gPT09IERlZlR5cGUuQ09ORklHID8gcGFyYW1UeXBlc18xLnBhcmFtVHlwZXMudHlwZShcImFueVwiKSA6IHBhcmFtVHlwZXNfMS5wYXJhbVR5cGVzLnR5cGUoXCJzdHJpbmdcIikpO1xuXHQgICAgcmV0dXJuIGNmZy50eXBlIGluc3RhbmNlb2YgdHlwZV8xLlR5cGUgPyBjZmcudHlwZSA6IHBhcmFtVHlwZXNfMS5wYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xuXHR9XG5cdC8qKlxuXHQgKiByZXR1cm5zIGZhbHNlLCB0cnVlLCBvciB0aGUgc3F1YXNoIHZhbHVlIHRvIGluZGljYXRlIHRoZSBcImRlZmF1bHQgcGFyYW1ldGVyIHVybCBzcXVhc2ggcG9saWN5XCIuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsKSB7XG5cdCAgICB2YXIgc3F1YXNoID0gY29uZmlnLnNxdWFzaDtcblx0ICAgIGlmICghaXNPcHRpb25hbCB8fCBzcXVhc2ggPT09IGZhbHNlKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzcXVhc2gpIHx8IHNxdWFzaCA9PSBudWxsKVxuXHQgICAgICAgIHJldHVybiB1cmxNYXRjaGVyQ29uZmlnXzEubWF0Y2hlckNvbmZpZy5kZWZhdWx0U3F1YXNoUG9saWN5KCk7XG5cdCAgICBpZiAoc3F1YXNoID09PSB0cnVlIHx8IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuXHQgICAgICAgIHJldHVybiBzcXVhc2g7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6ICdcIiArIHNxdWFzaCArIFwiJy4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBvciBhcmJpdHJhcnkgc3RyaW5nXCIpO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCkge1xuXHQgICAgdmFyIHJlcGxhY2UsIGNvbmZpZ3VyZWRLZXlzLCBkZWZhdWx0UG9saWN5ID0gW1xuXHQgICAgICAgIHsgZnJvbTogXCJcIiwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6IFwiXCIpIH0sXG5cdCAgICAgICAgeyBmcm9tOiBudWxsLCB0bzogKGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogXCJcIikgfVxuXHQgICAgXTtcblx0ICAgIHJlcGxhY2UgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb25maWcucmVwbGFjZSkgPyBjb25maWcucmVwbGFjZSA6IFtdO1xuXHQgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuXHQgICAgICAgIHJlcGxhY2UucHVzaCh7IGZyb206IHNxdWFzaCwgdG86IHVuZGVmaW5lZCB9KTtcblx0ICAgIGNvbmZpZ3VyZWRLZXlzID0gY29tbW9uXzEubWFwKHJlcGxhY2UsIGhvZl8xLnByb3AoXCJmcm9tXCIpKTtcblx0ICAgIHJldHVybiBjb21tb25fMS5maWx0ZXIoZGVmYXVsdFBvbGljeSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGNvbmZpZ3VyZWRLZXlzLmluZGV4T2YoaXRlbS5mcm9tKSA9PT0gLTE7IH0pLmNvbmNhdChyZXBsYWNlKTtcblx0fVxuXHR2YXIgUGFyYW0gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgbG9jYXRpb24pIHtcblx0ICAgICAgICBjb25maWcgPSB1bndyYXBTaG9ydGhhbmQoY29uZmlnKTtcblx0ICAgICAgICB0eXBlID0gZ2V0VHlwZShjb25maWcsIHR5cGUsIGxvY2F0aW9uLCBpZCk7XG5cdCAgICAgICAgdmFyIGFycmF5TW9kZSA9IGdldEFycmF5TW9kZSgpO1xuXHQgICAgICAgIHR5cGUgPSBhcnJheU1vZGUgPyB0eXBlLiRhc0FycmF5KGFycmF5TW9kZSwgbG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIKSA6IHR5cGU7XG5cdCAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBjb25maWcudmFsdWUgIT09IHVuZGVmaW5lZDtcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IGNvbmZpZy5keW5hbWljID09PSB0cnVlO1xuXHQgICAgICAgIHZhciBzcXVhc2ggPSBnZXRTcXVhc2hQb2xpY3koY29uZmlnLCBpc09wdGlvbmFsKTtcblx0ICAgICAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCk7XG5cdCAgICAgICAgLy8gYXJyYXkgY29uZmlnOiBwYXJhbSBuYW1lIChwYXJhbVtdKSBvdmVycmlkZXMgZGVmYXVsdCBzZXR0aW5ncy4gIGV4cGxpY2l0IGNvbmZpZyBvdmVycmlkZXMgcGFyYW0gbmFtZS5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRBcnJheU1vZGUoKSB7XG5cdCAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHRzID0geyBhcnJheTogKGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCA/IFwiYXV0b1wiIDogZmFsc2UpIH07XG5cdCAgICAgICAgICAgIHZhciBhcnJheVBhcmFtTm9tZW5jbGF0dXJlID0gaWQubWF0Y2goL1xcW1xcXSQvKSA/IHsgYXJyYXk6IHRydWUgfSA6IHt9O1xuXHQgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFycmF5RGVmYXVsdHMsIGFycmF5UGFyYW1Ob21lbmNsYXR1cmUsIGNvbmZpZykuYXJyYXk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7IGlkOiBpZCwgdHlwZTogdHlwZSwgbG9jYXRpb246IGxvY2F0aW9uLCBzcXVhc2g6IHNxdWFzaCwgcmVwbGFjZTogcmVwbGFjZSwgaXNPcHRpb25hbDogaXNPcHRpb25hbCwgZHluYW1pYzogZHluYW1pYywgY29uZmlnOiBjb25maWcsIGFycmF5OiBhcnJheU1vZGUgfSk7XG5cdCAgICB9XG5cdCAgICBQYXJhbS5wcm90b3R5cGUuaXNEZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pc09wdGlvbmFsICYmIHRoaXMudHlwZS5lcXVhbHModGhpcy52YWx1ZSgpLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBbSW50ZXJuYWxdIEdldHMgdGhlIGRlY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYSB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlLCByZXR1cm5zIHRoZVxuXHQgICAgICogZGVmYXVsdCB2YWx1ZSwgd2hpY2ggbWF5IGJlIHRoZSByZXN1bHQgb2YgYW4gaW5qZWN0YWJsZSBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgUGFyYW0ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBbSW50ZXJuYWxdIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHBhcmFtZXRlciwgd2hpY2ggbWF5IGJlIGFuIGluamVjdGFibGUgZnVuY3Rpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyICQkZ2V0RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoIWNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvcilcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lXCIpO1xuXHQgICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShfdGhpcy5jb25maWcuJCRmbik7XG5cdCAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIV90aGlzLnR5cGUuaXMoZGVmYXVsdFZhbHVlKSlcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgKFwiICsgZGVmYXVsdFZhbHVlICsgXCIpIGZvciBwYXJhbWV0ZXIgJ1wiICsgX3RoaXMuaWQgKyBcIicgaXMgbm90IGFuIGluc3RhbmNlIG9mIFR5cGUgKFwiICsgX3RoaXMudHlwZS5uYW1lICsgXCIpXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyICRyZXBsYWNlID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjb21tb25fMS5tYXAoY29tbW9uXzEuZmlsdGVyKF90aGlzLnJlcGxhY2UsIGhvZl8xLnByb3BFcSgnZnJvbScsIHZhbCkpLCBob2ZfMS5wcm9wKFwidG9cIikpO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQubGVuZ3RoID8gcmVwbGFjZW1lbnRbMF0gOiB2YWw7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YWx1ZSA9ICRyZXBsYWNlKHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gJCRnZXREZWZhdWx0VmFsdWUoKSA6IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBQYXJhbS5wcm90b3R5cGUuaXNTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtLnByb3RvdHlwZS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG5cdCAgICAgICAgaWYgKCghcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpICYmIHRoaXMuaXNPcHRpb25hbClcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgLy8gVGhlIHZhbHVlIHdhcyBub3Qgb2YgdGhlIGNvcnJlY3QgVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFR5cGVcblx0ICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcblx0ICAgICAgICBpZiAoIXRoaXMudHlwZS5pcyhub3JtYWxpemVkKSlcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgVHlwZSdzIHJlZ2V4cFxuXHQgICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy50eXBlLmVuY29kZShub3JtYWxpemVkKTtcblx0ICAgICAgICByZXR1cm4gIShwcmVkaWNhdGVzXzEuaXNTdHJpbmcoZW5jb2RlZCkgJiYgIXRoaXMudHlwZS5wYXR0ZXJuLmV4ZWMoZW5jb2RlZCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJ7UGFyYW06XCIgKyB0aGlzLmlkICsgXCIgXCIgKyB0aGlzLnR5cGUgKyBcIiBzcXVhc2g6ICdcIiArIHRoaXMuc3F1YXNoICsgXCInIG9wdGlvbmFsOiBcIiArIHRoaXMuaXNPcHRpb25hbCArIFwifVwiO1xuXHQgICAgfTtcblx0ICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgQ09ORklHIGJsb2NrICovXG5cdCAgICBQYXJhbS5mcm9tQ29uZmlnID0gZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFBhcmFtKGlkLCB0eXBlLCBjb25maWcsIERlZlR5cGUuQ09ORklHKTtcblx0ICAgIH07XG5cdCAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIHVybCBQQVRIICovXG5cdCAgICBQYXJhbS5mcm9tUGF0aCA9IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQYXJhbShpZCwgdHlwZSwgY29uZmlnLCBEZWZUeXBlLlBBVEgpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgdXJsIFNFQVJDSCAqL1xuXHQgICAgUGFyYW0uZnJvbVNlYXJjaCA9IGZ1bmN0aW9uIChpZCwgdHlwZSwgY29uZmlnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQYXJhbShpZCwgdHlwZSwgY29uZmlnLCBEZWZUeXBlLlNFQVJDSCk7XG5cdCAgICB9O1xuXHQgICAgUGFyYW0udmFsdWVzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG5cdCAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBbcGFyYW0uaWQsIHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pXTsgfSkucmVkdWNlKGNvbW1vbl8xLmFwcGx5UGFpcnMsIHt9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEZpbmRzIFtbUGFyYW1dXSBvYmplY3RzIHdoaWNoIGhhdmUgZGlmZmVyZW50IHBhcmFtIHZhbHVlc1xuXHQgICAgICpcblx0ICAgICAqIEZpbHRlcnMgYSBsaXN0IG9mIFtbUGFyYW1dXSBvYmplY3RzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIgaW4gdHdvIHBhcmFtIHZhbHVlIG9iamVjdHNcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcGFyYW1zOiBUaGUgbGlzdCBvZiBQYXJhbSBvYmplY3RzIHRvIGZpbHRlclxuXHQgICAgICogQHBhcmFtIHZhbHVlczE6IFRoZSBmaXJzdCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuXHQgICAgICogQHBhcmFtIHZhbHVlczI6IHRoZSBzZWNvbmQgc2V0IG9mIHBhcmFtZXRlciB2YWx1ZXNcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyBhbnkgUGFyYW0gb2JqZWN0cyB3aG9zZSB2YWx1ZXMgd2VyZSBkaWZmZXJlbnQgYmV0d2VlbiB2YWx1ZXMxIGFuZCB2YWx1ZXMyXG5cdCAgICAgKi9cblx0ICAgIFBhcmFtLmNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlczEgPT09IHZvaWQgMCkgeyB2YWx1ZXMxID0ge307IH1cblx0ICAgICAgICBpZiAodmFsdWVzMiA9PT0gdm9pZCAwKSB7IHZhbHVlczIgPSB7fTsgfVxuXHQgICAgICAgIHJldHVybiBwYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLnR5cGUuZXF1YWxzKHZhbHVlczFbcGFyYW0uaWRdLCB2YWx1ZXMyW3BhcmFtLmlkXSk7IH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIHR3byBwYXJhbSB2YWx1ZSBvYmplY3RzIGFyZSBlcXVhbCAoZm9yIGEgc2V0IG9mIFtbUGFyYW1dXSBvYmplY3RzKVxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIGxpc3Qgb2YgW1tQYXJhbV1dIG9iamVjdHMgdG8gY2hlY2tcblx0ICAgICAqIEBwYXJhbSB2YWx1ZXMxIFRoZSBmaXJzdCBzZXQgb2YgcGFyYW0gdmFsdWVzXG5cdCAgICAgKiBAcGFyYW0gdmFsdWVzMiBUaGUgc2Vjb25kIHNldCBvZiBwYXJhbSB2YWx1ZXNcblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwYXJhbSB2YWx1ZXMgaW4gdmFsdWVzMSBhbmQgdmFsdWVzMiBhcmUgZXF1YWxcblx0ICAgICAqL1xuXHQgICAgUGFyYW0uZXF1YWxzID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzMSwgdmFsdWVzMikge1xuXHQgICAgICAgIGlmICh2YWx1ZXMxID09PSB2b2lkIDApIHsgdmFsdWVzMSA9IHt9OyB9XG5cdCAgICAgICAgaWYgKHZhbHVlczIgPT09IHZvaWQgMCkgeyB2YWx1ZXMyID0ge307IH1cblx0ICAgICAgICByZXR1cm4gUGFyYW0uY2hhbmdlZChwYXJhbXMsIHZhbHVlczEsIHZhbHVlczIpLmxlbmd0aCA9PT0gMDtcblx0ICAgIH07XG5cdCAgICAvKiogUmV0dXJucyB0cnVlIGlmIGEgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHZhbGlkLCBhY2NvcmRpbmcgdG8gdGhlIFBhcmFtIGRlZmluaXRpb25zICovXG5cdCAgICBQYXJhbS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMpIHtcblx0ICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cblx0ICAgICAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLnZhbGlkYXRlcyh2YWx1ZXNbcGFyYW0uaWRdKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFsbFRydWVSLCB0cnVlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUGFyYW07XG5cdH0oKSk7XG5cdGV4cG9ydHMuUGFyYW0gPSBQYXJhbTtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSB1cmwgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgTWF0Y2hlckNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBNYXRjaGVyQ29uZmlnKCkge1xuXHQgICAgICAgIHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5faXNTdHJpY3RNb2RlID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBNYXRjaGVyQ29uZmlnLnByb3RvdHlwZS5jYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNDYXNlSW5zZW5zaXRpdmU7XG5cdCAgICB9O1xuXHQgICAgTWF0Y2hlckNvbmZpZy5wcm90b3R5cGUuc3RyaWN0TW9kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9pc1N0cmljdE1vZGUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNTdHJpY3RNb2RlO1xuXHQgICAgfTtcblx0ICAgIE1hdGNoZXJDb25maWcucHJvdG90eXBlLmRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlICYmICFwcmVkaWNhdGVzXzEuaXNTdHJpbmcodmFsdWUpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNxdWFzaCBwb2xpY3k6IFwiICsgdmFsdWUgKyBcIi4gVmFsaWQgcG9saWNpZXM6IGZhbHNlLCB0cnVlLCBhcmJpdHJhcnktc3RyaW5nXCIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3k7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE1hdGNoZXJDb25maWc7XG5cdH0oKSk7XG5cdGV4cG9ydHMuTWF0Y2hlckNvbmZpZyA9IE1hdGNoZXJDb25maWc7XG5cdC8vIFRPRE86IERvIG5vdCBleHBvcnQgZ2xvYmFsIGluc3RhbmNlOyBjcmVhdGUgb25lIGluIFVJUm91dGVyKCkgY29uc3RydWN0b3Jcblx0ZXhwb3J0cy5tYXRjaGVyQ29uZmlnID0gbmV3IE1hdGNoZXJDb25maWcoKTtcblxuXG4vKioqLyB9LFxuLyogMjMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBwYXJhbXMgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHQvKipcblx0ICogV3JhcHMgdXAgYSBgVHlwZWAgb2JqZWN0IHRvIGhhbmRsZSBhcnJheSB2YWx1ZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBBcnJheVR5cGUodHlwZSwgbW9kZSkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgIC8vIFdyYXAgbm9uLWFycmF5IHZhbHVlIGFzIGFycmF5XG5cdCAgICBmdW5jdGlvbiBhcnJheVdyYXAodmFsKSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheSh2YWwpID8gdmFsIDogKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsKSA/IFt2YWxdIDogW10pOyB9XG5cdCAgICAvLyBVbndyYXAgYXJyYXkgdmFsdWUgZm9yIFwiYXV0b1wiIG1vZGUuIFJldHVybiB1bmRlZmluZWQgZm9yIGVtcHR5IGFycmF5LlxuXHQgICAgZnVuY3Rpb24gYXJyYXlVbndyYXAodmFsKSB7XG5cdCAgICAgICAgc3dpdGNoICh2YWwubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbW9kZSA9PT0gXCJhdXRvXCIgPyB2YWxbMF0gOiB2YWw7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gV3JhcHMgdHlwZSAoLmlzLy5lbmNvZGUvLmRlY29kZSkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gZWFjaCB2YWx1ZSBvZiBhbiBhcnJheVxuXHQgICAgZnVuY3Rpb24gYXJyYXlIYW5kbGVyKGNhbGxiYWNrLCBhbGxUcnV0aHlNb2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCkge1xuXHQgICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgdmFyIGFyciA9IGFycmF5V3JhcCh2YWwpO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tbW9uXzEubWFwKGFyciwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgICByZXR1cm4gKGFsbFRydXRoeU1vZGUgPT09IHRydWUpID8gY29tbW9uXzEuZmlsdGVyKHJlc3VsdCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICF4OyB9KS5sZW5ndGggPT09IDAgOiBhcnJheVVud3JhcChyZXN1bHQpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvLyBXcmFwcyB0eXBlICguZXF1YWxzKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG5cdCAgICBmdW5jdGlvbiBhcnJheUVxdWFsc0hhbmRsZXIoY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsMSwgdmFsMikge1xuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGFycmF5V3JhcCh2YWwxKSwgcmlnaHQgPSBhcnJheVdyYXAodmFsMik7XG5cdCAgICAgICAgICAgIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2sobGVmdFtpXSwgcmlnaHRbaV0pKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgWydlbmNvZGUnLCAnZGVjb2RlJywgJ2VxdWFscycsICckbm9ybWFsaXplJ10ubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgX3RoaXNbbmFtZV0gPSAobmFtZSA9PT0gJ2VxdWFscycgPyBhcnJheUVxdWFsc0hhbmRsZXIgOiBhcnJheUhhbmRsZXIpKHR5cGVbbmFtZV0uYmluZCh0eXBlKSk7XG5cdCAgICB9KTtcblx0ICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7XG5cdCAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuXHQgICAgICAgIHBhdHRlcm46IHR5cGUucGF0dGVybixcblx0ICAgICAgICBpczogYXJyYXlIYW5kbGVyKHR5cGUuaXMuYmluZCh0eXBlKSwgdHJ1ZSksXG5cdCAgICAgICAgJGFycmF5TW9kZTogbW9kZVxuXHQgICAgfSk7XG5cdH1cblx0LyoqXG5cdCAqIEltcGxlbWVudHMgYW4gaW50ZXJmYWNlIHRvIGRlZmluZSBjdXN0b20gcGFyYW1ldGVyIHR5cGVzIHRoYXQgY2FuIGJlIGRlY29kZWQgZnJvbSBhbmQgZW5jb2RlZCB0b1xuXHQgKiBzdHJpbmcgcGFyYW1ldGVycyBtYXRjaGVkIGluIGEgVVJMLiBVc2VkIGJ5IFtbVXJsTWF0Y2hlcl1dXG5cdCAqIG9iamVjdHMgd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBvciB2YWxpZGF0aW5nIHBhcmFtZXRlciB2YWx1ZXMuXG5cdCAqXG5cdCAqIFNlZSBbW1VybE1hdGNoZXJGYWN0b3J5LnR5cGVdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiByZWdpc3RlcmluZyBjdXN0b20gdHlwZXMuXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIGBgYFxuXHQgKlxuXHQgKiB7XG5cdCAqICAgZGVjb2RlOiBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApOyB9LFxuXHQgKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG5cdCAqICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiB0aGlzLmlzKGEpICYmIGEgPT09IGI7IH0sXG5cdCAqICAgaXM6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gYW5ndWxhci5pc051bWJlcih2YWwpICYmIGlzRmluaXRlKHZhbCkgJiYgdmFsICUgMSA9PT0gMDsgfSxcblx0ICogICBwYXR0ZXJuOiAvXFxkKy9cblx0ICogfVxuXHQgKiBgYGBcblx0ICovXG5cdHZhciBUeXBlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8qKlxuXHQgICAgICogQHBhcmFtIGRlZiAgQSBjb25maWd1cmF0aW9uIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY3VzdG9tIHR5cGUgZGVmaW5pdGlvbi4gIFRoZSBvYmplY3Qnc1xuXHQgICAgICogICAgICAgIHByb3BlcnRpZXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2RzIGFuZC9vciBwYXR0ZXJuIGluIGBUeXBlYCdzIHB1YmxpYyBpbnRlcmZhY2UuXG5cdCAgICAgKiBAcmV0dXJucyBhIG5ldyBUeXBlIG9iamVjdFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBUeXBlKGRlZikge1xuXHQgICAgICAgIHRoaXMucGF0dGVybiA9IC8uKi87XG5cdCAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGRlZik7XG5cdCAgICB9XG5cdCAgICAvLyBjb25zaWRlciB0aGVzZSBmb3VyIG1ldGhvZHMgdG8gYmUgXCJhYnN0cmFjdCBtZXRob2RzXCIgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGRlblxuXHQgICAgLyoqIEBpbmhlcml0ZG9jICovXG5cdCAgICBUeXBlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdHJ1ZTsgfTtcblx0ICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuXHQgICAgVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiB2YWw7IH07XG5cdCAgICAvKiogQGluaGVyaXRkb2MgKi9cblx0ICAgIFR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdmFsOyB9O1xuXHQgICAgLyoqIEBpbmhlcml0ZG9jICovXG5cdCAgICBUeXBlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PSBiOyB9O1xuXHQgICAgVHlwZS5wcm90b3R5cGUuJHN1YlBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuXHQgICAgICAgIHJldHVybiBzdWIuc3Vic3RyKDEsIHN1Yi5sZW5ndGggLSAyKTtcblx0ICAgIH07XG5cdCAgICBUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJ7VHlwZTpcIiArIHRoaXMubmFtZSArIFwifVwiO1xuXHQgICAgfTtcblx0ICAgIC8qKiBHaXZlbiBhbiBlbmNvZGVkIHN0cmluZywgb3IgYSBkZWNvZGVkIG9iamVjdCwgcmV0dXJucyBhIGRlY29kZWQgb2JqZWN0ICovXG5cdCAgICBUeXBlLnByb3RvdHlwZS4kbm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmlzKHZhbCkgPyB2YWwgOiB0aGlzLmRlY29kZSh2YWwpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogV3JhcHMgYW4gZXhpc3RpbmcgY3VzdG9tIFR5cGUgYXMgYW4gYXJyYXkgb2YgVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cblx0ICAgICAqIGUuZy46XG5cdCAgICAgKiAtIHVybG1hdGNoZXIgcGF0dGVybiBcIi9wYXRoP3txdWVyeVBhcmFtW106aW50fVwiXG5cdCAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG5cdCAgICAgKiAtICRzdGF0ZVBhcmFtcy5xdWVyeVBhcmFtIHdpbGwgYmUgWzEsIDJdXG5cdCAgICAgKiBpZiBgbW9kZWAgaXMgXCJhdXRvXCIsIHRoZW5cblx0ICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuXHQgICAgICogLSB1cmw6IFwiL3BhdGg/cXVlcnlQYXJhbT0xJnF1ZXJ5UGFyYW09MiB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogWzEsIDJdXG5cdCAgICAgKi9cblx0ICAgIFR5cGUucHJvdG90eXBlLiRhc0FycmF5ID0gZnVuY3Rpb24gKG1vZGUsIGlzU2VhcmNoKSB7XG5cdCAgICAgICAgaWYgKCFtb2RlKVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgJiYgIWlzU2VhcmNoKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInYXV0bycgYXJyYXkgbW9kZSBpcyBmb3IgcXVlcnkgcGFyYW1ldGVycyBvbmx5XCIpO1xuXHQgICAgICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHRoaXMsIG1vZGUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUeXBlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlR5cGUgPSBUeXBlO1xuXG5cbi8qKiovIH0sXG4vKiAyNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHBhcmFtcyAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHByZWRpY2F0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBob2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBjb3Jlc2VydmljZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciB0eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0Ly8gVXNlIHRpbGRlcyB0byBwcmUtZW5jb2RlIHNsYXNoZXMuXG5cdC8vIElmIHRoZSBzbGFzaGVzIGFyZSBzaW1wbHkgVVJMRW5jb2RlZCwgdGhlIGJyb3dzZXIgY2FuIGNob29zZSB0byBwcmUtZGVjb2RlIHRoZW0sXG5cdC8vIGFuZCBiaWRpcmVjdGlvbmFsIGVuY29kaW5nL2RlY29kaW5nIGZhaWxzLlxuXHQvLyBUaWxkZSB3YXMgY2hvc2VuIGJlY2F1c2UgaXQncyBub3QgYSBSRkMgMzk4NiBzZWN0aW9uIDIuMiBSZXNlcnZlZCBDaGFyYWN0ZXJcblx0ZnVuY3Rpb24gdmFsVG9TdHJpbmcodmFsKSB7IHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpLnJlcGxhY2UoL34vZywgXCJ+flwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MkZcIikgOiB2YWw7IH1cblx0ZnVuY3Rpb24gdmFsRnJvbVN0cmluZyh2YWwpIHsgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsLnRvU3RyaW5nKCkucmVwbGFjZSgvfjJGL2csIFwiL1wiKS5yZXBsYWNlKC9+fi9nLCBcIn5cIikgOiB2YWw7IH1cblx0dmFyIFBhcmFtVHlwZXMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUGFyYW1UeXBlcygpIHtcblx0ICAgICAgICB0aGlzLmVucXVldWUgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMudHlwZVF1ZXVlID0gW107XG5cdCAgICAgICAgdGhpcy5kZWZhdWx0VHlwZXMgPSB7XG5cdCAgICAgICAgICAgIFwiaGFzaFwiOiB7XG5cdCAgICAgICAgICAgICAgICBlbmNvZGU6IHZhbFRvU3RyaW5nLFxuXHQgICAgICAgICAgICAgICAgZGVjb2RlOiB2YWxGcm9tU3RyaW5nLFxuXHQgICAgICAgICAgICAgICAgaXM6IGhvZl8xLmlzKFN0cmluZyksXG5cdCAgICAgICAgICAgICAgICBwYXR0ZXJuOiAvLiovLFxuXHQgICAgICAgICAgICAgICAgZXF1YWxzOiBob2ZfMS52YWwodHJ1ZSlcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgXCJzdHJpbmdcIjoge1xuXHQgICAgICAgICAgICAgICAgZW5jb2RlOiB2YWxUb1N0cmluZyxcblx0ICAgICAgICAgICAgICAgIGRlY29kZTogdmFsRnJvbVN0cmluZyxcblx0ICAgICAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhTdHJpbmcpLFxuXHQgICAgICAgICAgICAgICAgcGF0dGVybjogL1teL10qL1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBcImludFwiOiB7XG5cdCAgICAgICAgICAgICAgICBlbmNvZGU6IHZhbFRvU3RyaW5nLFxuXHQgICAgICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcblx0ICAgICAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbCkgJiYgdGhpcy5kZWNvZGUodmFsLnRvU3RyaW5nKCkpID09PSB2YWw7IH0sXG5cdCAgICAgICAgICAgICAgICBwYXR0ZXJuOiAvLT9cXGQrL1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBcImJvb2xcIjoge1xuXHQgICAgICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgJiYgMSB8fCAwOyB9LFxuXHQgICAgICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKSAhPT0gMDsgfSxcblx0ICAgICAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhCb29sZWFuKSxcblx0ICAgICAgICAgICAgICAgIHBhdHRlcm46IC8wfDEvXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIFwiZGF0ZVwiOiB7XG5cdCAgICAgICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuaXModmFsKSA/IHVuZGVmaW5lZCA6IFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsLmdldEZ1bGxZZWFyKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICgnMCcgKyAodmFsLmdldE1vbnRoKCkgKyAxKSkuc2xpY2UoLTIpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAoJzAnICsgdmFsLmdldERhdGUoKSkuc2xpY2UoLTIpXG5cdCAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiLVwiKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pcyh2YWwpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuY2FwdHVyZS5leGVjKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbmV3IERhdGUobWF0Y2hbMV0sIG1hdGNoWzJdIC0gMSwgbWF0Y2hbM10pIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWwudmFsdWVPZigpKTsgfSxcblx0ICAgICAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKGwsIHIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydnZXRGdWxsWWVhcicsICdnZXRNb250aCcsICdnZXREYXRlJ11cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmbikgeyByZXR1cm4gYWNjICYmIGxbZm5dKCkgPT09IHJbZm5dKCk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHBhdHRlcm46IC9bMC05XXs0fS0oPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcblx0ICAgICAgICAgICAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS9cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgXCJqc29uXCI6IHtcblx0ICAgICAgICAgICAgICAgIGVuY29kZTogY29tbW9uXzEudG9Kc29uLFxuXHQgICAgICAgICAgICAgICAgZGVjb2RlOiBjb21tb25fMS5mcm9tSnNvbixcblx0ICAgICAgICAgICAgICAgIGlzOiBob2ZfMS5pcyhPYmplY3QpLFxuXHQgICAgICAgICAgICAgICAgZXF1YWxzOiBjb21tb25fMS5lcXVhbHMsXG5cdCAgICAgICAgICAgICAgICBwYXR0ZXJuOiAvW14vXSovXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIFwiYW55XCI6IHtcblx0ICAgICAgICAgICAgICAgIGVuY29kZTogY29tbW9uXzEuaWRlbnRpdHksXG5cdCAgICAgICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmlkZW50aXR5LFxuXHQgICAgICAgICAgICAgICAgZXF1YWxzOiBjb21tb25fMS5lcXVhbHMsXG5cdCAgICAgICAgICAgICAgICBwYXR0ZXJuOiAvLiovXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIFJlZ2lzdGVyIGRlZmF1bHQgdHlwZXMuIFN0b3JlIHRoZW0gaW4gdGhlIHByb3RvdHlwZSBvZiB0aGlzLnR5cGVzLlxuXHQgICAgICAgIHZhciBtYWtlVHlwZSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBuYW1lKSB7IHJldHVybiBuZXcgdHlwZV8xLlR5cGUoY29tbW9uXzEuZXh0ZW5kKHsgbmFtZTogbmFtZSB9LCBkZWZpbml0aW9uKSk7IH07XG5cdCAgICAgICAgdGhpcy50eXBlcyA9IGNvbW1vbl8xLmluaGVyaXQoY29tbW9uXzEubWFwKHRoaXMuZGVmYXVsdFR5cGVzLCBtYWtlVHlwZSksIHt9KTtcblx0ICAgIH1cblx0ICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGRlZmluaXRpb24pKVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1tuYW1lXTtcblx0ICAgICAgICBpZiAodGhpcy50eXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSB0eXBlIG5hbWVkICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlwiKTtcblx0ICAgICAgICB0aGlzLnR5cGVzW25hbWVdID0gbmV3IHR5cGVfMS5UeXBlKGNvbW1vbl8xLmV4dGVuZCh7IG5hbWU6IG5hbWUgfSwgZGVmaW5pdGlvbikpO1xuXHQgICAgICAgIGlmIChkZWZpbml0aW9uRm4pIHtcblx0ICAgICAgICAgICAgdGhpcy50eXBlUXVldWUucHVzaCh7IG5hbWU6IG5hbWUsIGRlZjogZGVmaW5pdGlvbkZuIH0pO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZW5xdWV1ZSlcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoVHlwZVF1ZXVlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLl9mbHVzaFR5cGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB3aGlsZSAodGhpcy50eXBlUXVldWUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlUXVldWUuc2hpZnQoKTtcblx0ICAgICAgICAgICAgaWYgKHR5cGUucGF0dGVybilcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgb3ZlcnJpZGUgYSB0eXBlJ3MgLnBhdHRlcm4gYXQgcnVudGltZS5cIik7XG5cdCAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLnR5cGVzW3R5cGUubmFtZV0sIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFBhcmFtVHlwZXM7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUGFyYW1UeXBlcyA9IFBhcmFtVHlwZXM7XG5cdGV4cG9ydHMucGFyYW1UeXBlcyA9IG5ldyBQYXJhbVR5cGVzKCk7XG5cblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgcGFyYW1zICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgU3RhdGVQYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGVQYXJhbXMocGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG5cdCAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIE1lcmdlcyBhIHNldCBvZiBwYXJhbWV0ZXJzIHdpdGggYWxsIHBhcmFtZXRlcnMgaW5oZXJpdGVkIGJldHdlZW4gdGhlIGNvbW1vbiBwYXJlbnRzIG9mIHRoZVxuXHQgICAgICogY3VycmVudCBzdGF0ZSBhbmQgYSBnaXZlbiBkZXN0aW5hdGlvbiBzdGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3UGFyYW1zIFRoZSBzZXQgb2YgcGFyYW1ldGVycyB3aGljaCB3aWxsIGJlIGNvbXBvc2l0ZWQgd2l0aCBpbmhlcml0ZWQgcGFyYW1zLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9ICRjdXJyZW50IEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlUGFyYW1zLnByb3RvdHlwZS4kaW5oZXJpdCA9IGZ1bmN0aW9uIChuZXdQYXJhbXMsICRjdXJyZW50LCAkdG8pIHtcblx0ICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgcGFyZW50UGFyYW1zLCBpbmhlcml0ZWQgPSB7fSwgaW5oZXJpdExpc3QgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpIGluIHBhcmVudHMpIHtcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcylcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICBwYXJlbnRQYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzW2ldLnBhcmFtcyk7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50UGFyYW1zLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqIGluIHBhcmVudFBhcmFtcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKVxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgaW5oZXJpdExpc3QucHVzaChwYXJlbnRQYXJhbXNbal0pO1xuXHQgICAgICAgICAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIHJldHVybiBTdGF0ZVBhcmFtcztcblx0fSgpKTtcblx0ZXhwb3J0cy5TdGF0ZVBhcmFtcyA9IFN0YXRlUGFyYW1zO1xuXG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgcGFyYW1fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHR2YXIgcmVqZWN0RmFjdG9yeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdHZhciB0YXJnZXRTdGF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cdHZhciB2aWV3SG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXHR2YXIgZW50ZXJFeGl0SG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHR2YXIgcmVzb2x2ZUhvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0dmFyIGNvcmVzZXJ2aWNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0LyoqXG5cdCAqIFRoaXMgY2xhc3M6XG5cdCAqXG5cdCAqICogVGFrZXMgYSBibGFuayB0cmFuc2l0aW9uIG9iamVjdCBhbmQgYWRkcyBhbGwgdGhlIGhvb2tzIG5lY2Vzc2FyeSBmb3IgaXQgdG8gYmVoYXZlIGxpa2UgYSBzdGF0ZSB0cmFuc2l0aW9uLlxuXHQgKlxuXHQgKiAqIFJ1bnMgdGhlIHRyYW5zaXRpb24sIHJldHVybmluZyBhIGNoYWluZWQgcHJvbWlzZSB3aGljaDpcblx0ICogICAqIHRyYW5zZm9ybXMgdGhlIHJlc29sdmVkIFRyYW5zaXRpb24ucHJvbWlzZSB0byB0aGUgZmluYWwgZGVzdGluYXRpb24gc3RhdGUuXG5cdCAqICAgKiBtYW5hZ2VzIHRoZSByZWplY3RlZCBUcmFuc2l0aW9uLnByb21pc2UsIGNoZWNraW5nIGZvciBEeW5hbWljIG9yIFJlZGlyZWN0ZWQgdHJhbnNpdGlvbnNcblx0ICpcblx0ICogKiBSZWdpc3RlcnMgYSBoYW5kbGVyIHRvIHVwZGF0ZSBnbG9iYWwgJHN0YXRlIGRhdGEgc3VjaCBhcyBcImFjdGl2ZSB0cmFuc2l0aW9uc1wiIGFuZCBcImN1cnJlbnQgc3RhdGUvcGFyYW1zXCJcblx0ICpcblx0ICogKiBSZWdpc3RlcnMgdmlldyBob29rcywgd2hpY2ggbWFpbnRhaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIHZpZXcgY29uZmlncyBhbmQgc3luYyB3aXRoL3VwZGF0ZSB0aGUgdWktdmlld3Ncblx0ICpcblx0ICogKiBSZWdpc3RlcnMgb25FbnRlci9vblJldGFpbi9vbkV4aXQgaG9va3Mgd2hpY2ggZGVsZWdhdGUgdG8gdGhlIHN0YXRlJ3MgaG9va3Mgb2YgdGhlIHNhbWUgbmFtZSwgYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWVcblx0ICpcblx0ICogKiBSZWdpc3RlcnMgZWFnZXIgYW5kIGxhenkgcmVzb2x2ZSBob29rc1xuXHQgKi9cblx0dmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25NYW5hZ2VyKHRyYW5zaXRpb24sICR0cmFuc2l0aW9ucywgJHVybFJvdXRlciwgJHZpZXcsIC8vIHNlcnZpY2Vcblx0ICAgICAgICAkc3RhdGUsIGdsb2JhbHMpIHtcblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHQgICAgICAgIHRoaXMuJHRyYW5zaXRpb25zID0gJHRyYW5zaXRpb25zO1xuXHQgICAgICAgIHRoaXMuJHVybFJvdXRlciA9ICR1cmxSb3V0ZXI7XG5cdCAgICAgICAgdGhpcy4kdmlldyA9ICR2aWV3O1xuXHQgICAgICAgIHRoaXMuJHN0YXRlID0gJHN0YXRlO1xuXHQgICAgICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHM7XG5cdCAgICAgICAgdGhpcy4kcSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxO1xuXHQgICAgICAgIHRoaXMudmlld0hvb2tzID0gbmV3IHZpZXdIb29rc18xLlZpZXdIb29rcyh0cmFuc2l0aW9uLCAkdmlldyk7XG5cdCAgICAgICAgdGhpcy5lbnRlckV4aXRIb29rcyA9IG5ldyBlbnRlckV4aXRIb29rc18xLkVudGVyRXhpdEhvb2tzKHRyYW5zaXRpb24pO1xuXHQgICAgICAgIHRoaXMucmVzb2x2ZUhvb2tzID0gbmV3IHJlc29sdmVIb29rc18xLlJlc29sdmVIb29rcyh0cmFuc2l0aW9uKTtcblx0ICAgICAgICB0aGlzLnRyZWVDaGFuZ2VzID0gdHJhbnNpdGlvbi50cmVlQ2hhbmdlcygpO1xuXHQgICAgICAgIHRoaXMucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSgpO1xuXHQgICAgICAgIHRoaXMudmlld0hvb2tzLnJlZ2lzdGVySG9va3MoKTtcblx0ICAgICAgICB0aGlzLmVudGVyRXhpdEhvb2tzLnJlZ2lzdGVySG9va3MoKTtcblx0ICAgICAgICB0aGlzLnJlc29sdmVIb29rcy5yZWdpc3Rlckhvb2tzKCk7XG5cdCAgICB9XG5cdCAgICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUucnVuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5lbnF1ZXVlKHRoaXMudHJhbnNpdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5ydW4oKVxuXHQgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHJhbnMpIHsgcmV0dXJuIHRyYW5zLnRvKCk7IH0pIC8vIHJlc29sdmUgdG8gdGhlIGZpbmFsIHN0YXRlIChUT0RPOiBnb29kPyBiYWQ/KVxuXHQgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBfdGhpcy50cmFuc1JlamVjdGVkKGVycm9yKTsgfSk7IC8vIGlmIHJlamVjdGVkLCBoYW5kbGUgZHluYW1pYyBhbmQgcmVkaXJlY3Rcblx0ICAgIH07XG5cdCAgICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBBZnRlciBnbG9iYWxzLmN1cnJlbnQgaXMgdXBkYXRlZCBhdCBwcmlvcml0eTogMTAwMDBcblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb24ub25TdWNjZXNzKHt9LCB0aGlzLnVwZGF0ZVVybC5iaW5kKHRoaXMpLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xuXHQgICAgfTtcblx0ICAgIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS50cmFuc1JlamVjdGVkID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcywgdHJhbnNpdGlvbiA9IF9hLnRyYW5zaXRpb24sICRzdGF0ZSA9IF9hLiRzdGF0ZSwgJHEgPSBfYS4kcTtcblx0ICAgICAgICAvLyBIYW5kbGUgcmVkaXJlY3QgYW5kIGFib3J0XG5cdCAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgcmVqZWN0RmFjdG9yeV8xLlRyYW5zaXRpb25SZWplY3Rpb24pIHtcblx0ICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IHJlamVjdEZhY3RvcnlfMS5SZWplY3RUeXBlLklHTk9SRUQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSAkc3RhdGVQYXJtYXMvJHN0YXRlLnBhcmFtcy8kbG9jYXRpb24udXJsIGlmIHRyYW5zaXRpb24gaWdub3JlZCwgYnV0IGR5bmFtaWMgcGFyYW1zIGhhdmUgY2hhbmdlZC5cblx0ICAgICAgICAgICAgICAgIHZhciBkeW5hbWljID0gJHN0YXRlLiRjdXJyZW50LnBhcmFtZXRlcnMoKS5maWx0ZXIoaG9mXzEucHJvcCgnZHluYW1pYycpKTtcblx0ICAgICAgICAgICAgICAgIGlmICghcGFyYW1fMS5QYXJhbS5lcXVhbHMoZHluYW1pYywgJHN0YXRlLnBhcmFtcywgdHJhbnNpdGlvbi5wYXJhbXMoKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVVybCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICRzdGF0ZS5jdXJyZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5TVVBFUlNFREVEICYmIGVycm9yLnJlZGlyZWN0ZWQgJiYgZXJyb3IuZGV0YWlsIGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZGlyZWN0TWdyKHRyYW5zaXRpb24ucmVkaXJlY3QoZXJyb3IuZGV0YWlsKSkucnVuVHJhbnNpdGlvbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5BQk9SVEVEKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLiR1cmxSb3V0ZXIudXBkYXRlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy4kdHJhbnNpdGlvbnMuZGVmYXVsdEVycm9ySGFuZGxlcigpKGVycm9yKTtcblx0ICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcblx0ICAgIH07XG5cdCAgICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUudXBkYXRlVXJsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uO1xuXHQgICAgICAgIHZhciBfYSA9IHRoaXMsICR1cmxSb3V0ZXIgPSBfYS4kdXJsUm91dGVyLCAkc3RhdGUgPSBfYS4kc3RhdGU7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0cmFuc2l0aW9uLm9wdGlvbnMoKTtcblx0ICAgICAgICB2YXIgdG9TdGF0ZSA9IHRyYW5zaXRpb24uJHRvKCk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb24gJiYgJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSkge1xuXHQgICAgICAgICAgICAkdXJsUm91dGVyLnB1c2goJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZS51cmwsICRzdGF0ZS5wYXJhbXMsIHsgcmVwbGFjZTogb3B0aW9ucy5sb2NhdGlvbiA9PT0gJ3JlcGxhY2UnIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcblx0ICAgIH07XG5cdCAgICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuX3JlZGlyZWN0TWdyID0gZnVuY3Rpb24gKHJlZGlyZWN0KSB7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcywgJHRyYW5zaXRpb25zID0gX2EuJHRyYW5zaXRpb25zLCAkdXJsUm91dGVyID0gX2EuJHVybFJvdXRlciwgJHZpZXcgPSBfYS4kdmlldywgJHN0YXRlID0gX2EuJHN0YXRlLCBnbG9iYWxzID0gX2EuZ2xvYmFscztcblx0ICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb25NYW5hZ2VyKHJlZGlyZWN0LCAkdHJhbnNpdGlvbnMsICR1cmxSb3V0ZXIsICR2aWV3LCAkc3RhdGUsIGdsb2JhbHMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUcmFuc2l0aW9uTWFuYWdlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5UcmFuc2l0aW9uTWFuYWdlciA9IFRyYW5zaXRpb25NYW5hZ2VyO1xuXG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKipcblx0ICogQG5nZG9jIG9iamVjdFxuXHQgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUudHlwZTpUYXJnZXRTdGF0ZVxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogRW5jYXBzdWxhdGUgdGhlIGRlc2lyZWQgdGFyZ2V0IG9mIGEgdHJhbnNpdGlvbi5cblx0ICogV3JhcHMgYW4gaWRlbnRpZmllciBmb3IgYSBzdGF0ZSwgYSBzZXQgb2YgcGFyYW1ldGVycywgYW5kIHRyYW5zaXRpb24gb3B0aW9ucyB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBzdGF0ZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdGF0ZU9yTmFtZX0gX2lkZW50aWZpZXIgIEFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGUuIEVpdGhlciBhIGZ1bGx5LXF1YWxpZmllZCBwYXRoLCBvciB0aGUgb2JqZWN0XG5cdCAqICAgICAgICAgICAgdXNlZCB0byBkZWZpbmUgdGhlIHN0YXRlLlxuXHQgKiBAcGFyYW0ge0lTdGF0ZX0gX2RlZmluaXRpb24gVGhlIGBTdGF0ZWAgb2JqZWN0IGRlZmluaXRpb24uXG5cdCAqIEBwYXJhbSB7UGFyYW1zT3JBcnJheX0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG5cdCAqIEBwYXJhbSB7VHJhbnNpdGlvbk9wdGlvbnN9IF9vcHRpb25zIFRyYW5zaXRpb24gb3B0aW9ucy5cblx0ICovXG5cdHZhciBUYXJnZXRTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBUYXJnZXRTdGF0ZShfaWRlbnRpZmllciwgX2RlZmluaXRpb24sIF9wYXJhbXMsIF9vcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKF9wYXJhbXMgPT09IHZvaWQgMCkgeyBfcGFyYW1zID0ge307IH1cblx0ICAgICAgICBpZiAoX29wdGlvbnMgPT09IHZvaWQgMCkgeyBfb3B0aW9ucyA9IHt9OyB9XG5cdCAgICAgICAgdGhpcy5faWRlbnRpZmllciA9IF9pZGVudGlmaWVyO1xuXHQgICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBfZGVmaW5pdGlvbjtcblx0ICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG5cdCAgICAgICAgdGhpcy5fcGFyYW1zID0gX3BhcmFtcyB8fCB7fTtcblx0ICAgIH1cblx0ICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSB8fCB0aGlzLl9pZGVudGlmaWVyO1xuXHQgICAgfTtcblx0ICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5pZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuXHQgICAgfTtcblx0ICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcztcblx0ICAgIH07XG5cdCAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuJHN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHQgICAgfTtcblx0ICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbiAmJiB0aGlzLl9kZWZpbml0aW9uLnNlbGY7XG5cdCAgICB9O1xuXHQgICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG5cdCAgICB9O1xuXHQgICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gISEodGhpcy5fZGVmaW5pdGlvbiAmJiB0aGlzLl9kZWZpbml0aW9uLnNlbGYpO1xuXHQgICAgfTtcblx0ICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gIXRoaXMuZXJyb3IoKTtcblx0ICAgIH07XG5cdCAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm9wdGlvbnMoKS5yZWxhdGl2ZTtcblx0ICAgICAgICBpZiAoIXRoaXMuX2RlZmluaXRpb24gJiYgISFiYXNlKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZU5hbWUgPSBiYXNlLm5hbWUgPyBiYXNlLm5hbWUgOiBiYXNlO1xuXHQgICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBmcm9tIHN0YXRlICdcIiArIHN0YXRlTmFtZSArIFwiJ1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXRoaXMuX2RlZmluaXRpb24pXG5cdCAgICAgICAgICAgIHJldHVybiBcIk5vIHN1Y2ggc3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIjtcblx0ICAgICAgICBpZiAoIXRoaXMuX2RlZmluaXRpb24uc2VsZilcblx0ICAgICAgICAgICAgcmV0dXJuIFwiU3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIicgaGFzIGFuIGludmFsaWQgZGVmaW5pdGlvblwiO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUYXJnZXRTdGF0ZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5UYXJnZXRTdGF0ZSA9IFRhcmdldFN0YXRlO1xuXG5cbi8qKiovIH0sXG4vKiAyOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgVmlld0hvb2tzID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFZpZXdIb29rcyh0cmFuc2l0aW9uLCAkdmlldykge1xuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdCAgICAgICAgdGhpcy4kdmlldyA9ICR2aWV3O1xuXHQgICAgICAgIHRoaXMudHJlZUNoYW5nZXMgPSB0cmFuc2l0aW9uLnRyZWVDaGFuZ2VzKCk7XG5cdCAgICAgICAgdGhpcy5lbnRlcmluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImVudGVyaW5nXCIpO1xuXHQgICAgICAgIHRoaXMuZXhpdGluZ1ZpZXdzID0gdHJhbnNpdGlvbi52aWV3cyhcImV4aXRpbmdcIik7XG5cdCAgICB9XG5cdCAgICBWaWV3SG9va3MucHJvdG90eXBlLmxvYWRBbGxFbnRlcmluZ1ZpZXdzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5hbGwodGhpcy5lbnRlcmluZ1ZpZXdzLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5sb2FkKCk7IH0pKS50aGVuKGNvbW1vbl8xLm5vb3ApO1xuXHQgICAgfTtcblx0ICAgIFZpZXdIb29rcy5wcm90b3R5cGUudXBkYXRlVmlld3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyICR2aWV3ID0gdGhpcy4kdmlldztcblx0ICAgICAgICB0aGlzLmV4aXRpbmdWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7IHJldHVybiAkdmlldy5kZWFjdGl2YXRlVmlld0NvbmZpZyh2aWV3Q29uZmlnKTsgfSk7XG5cdCAgICAgICAgdGhpcy5lbnRlcmluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXdDb25maWcpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2aWV3Q29uZmlnKTsgfSk7XG5cdCAgICAgICAgJHZpZXcuc3luYygpO1xuXHQgICAgfTtcblx0ICAgIFZpZXdIb29rcy5wcm90b3R5cGUucmVnaXN0ZXJIb29rcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5lbnRlcmluZ1ZpZXdzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24ub25TdGFydCh7fSwgdGhpcy5sb2FkQWxsRW50ZXJpbmdWaWV3cy5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuZXhpdGluZ1ZpZXdzLmxlbmd0aCB8fCB0aGlzLmVudGVyaW5nVmlld3MubGVuZ3RoKVxuXHQgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24ub25TdWNjZXNzKHt9LCB0aGlzLnVwZGF0ZVZpZXdzLmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBWaWV3SG9va3M7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVmlld0hvb2tzID0gVmlld0hvb2tzO1xuXG5cbi8qKiovIH0sXG4vKiAyOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBFbnRlckV4aXRIb29rcyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBFbnRlckV4aXRIb29rcyh0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0ICAgIH1cblx0ICAgIEVudGVyRXhpdEhvb2tzLnByb3RvdHlwZS5yZWdpc3Rlckhvb2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucmVnaXN0ZXJPbkVudGVySG9va3MoKTtcblx0ICAgICAgICB0aGlzLnJlZ2lzdGVyT25SZXRhaW5Ib29rcygpO1xuXHQgICAgICAgIHRoaXMucmVnaXN0ZXJPbkV4aXRIb29rcygpO1xuXHQgICAgfTtcblx0ICAgIEVudGVyRXhpdEhvb2tzLnByb3RvdHlwZS5yZWdpc3Rlck9uRW50ZXJIb29rcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbi5lbnRlcmluZygpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUub25FbnRlcjsgfSlcblx0ICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBfdGhpcy50cmFuc2l0aW9uLm9uRW50ZXIoeyBlbnRlcmluZzogc3RhdGUubmFtZSB9LCBzdGF0ZS5vbkVudGVyKTsgfSk7XG5cdCAgICB9O1xuXHQgICAgRW50ZXJFeGl0SG9va3MucHJvdG90eXBlLnJlZ2lzdGVyT25SZXRhaW5Ib29rcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbi5yZXRhaW5lZCgpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUub25SZXRhaW47IH0pXG5cdCAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gX3RoaXMudHJhbnNpdGlvbi5vblJldGFpbih7IHJldGFpbmVkOiBzdGF0ZS5uYW1lIH0sIHN0YXRlLm9uUmV0YWluKTsgfSk7XG5cdCAgICB9O1xuXHQgICAgRW50ZXJFeGl0SG9va3MucHJvdG90eXBlLnJlZ2lzdGVyT25FeGl0SG9va3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb24uZXhpdGluZygpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUub25FeGl0OyB9KVxuXHQgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIF90aGlzLnRyYW5zaXRpb24ub25FeGl0KHsgZXhpdGluZzogc3RhdGUubmFtZSB9LCBzdGF0ZS5vbkV4aXQpOyB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRW50ZXJFeGl0SG9va3M7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRW50ZXJFeGl0SG9va3MgPSBFbnRlckV4aXRIb29rcztcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIGhvZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIGludGVyZmFjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdHZhciBob2ZfMiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciByZXNvbHZhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblx0dmFyIExBWlkgPSBpbnRlcmZhY2VfMS5SZXNvbHZlUG9saWN5W2ludGVyZmFjZV8xLlJlc29sdmVQb2xpY3kuTEFaWV07XG5cdHZhciBFQUdFUiA9IGludGVyZmFjZV8xLlJlc29sdmVQb2xpY3lbaW50ZXJmYWNlXzEuUmVzb2x2ZVBvbGljeS5FQUdFUl07XG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgRWFnZXIgYW5kIExhenkgKGZvciBlbnRlcmluZyBzdGF0ZXMpIHJlc29sdmUgaG9va3Ncblx0ICpcblx0ICogKiByZWdpc3RlcnMgYSBob29rIHRoYXQgcmVzb2x2ZXMgRUFHRVIgcmVzb2x2ZXMsIGZvciB0aGUgVG8gUGF0aCwgb25TdGFydCBvZiB0aGUgdHJhbnNpdGlvblxuXHQgKiAqIHJlZ2lzdGVycyBhIGhvb2sgdGhhdCByZXNvbHZlcyBMQVpZIHJlc29sdmVzLCBmb3IgZWFjaCBzdGF0ZSwgYmVmb3JlIGl0IGlzIGVudGVyZWRcblx0ICovXG5cdHZhciBSZXNvbHZlSG9va3MgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVzb2x2ZUhvb2tzKHRyYW5zaXRpb24pIHtcblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHQgICAgfVxuXHQgICAgUmVzb2x2ZUhvb2tzLnByb3RvdHlwZS5yZWdpc3Rlckhvb2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0cmVlQ2hhbmdlcyA9IHRoaXMudHJhbnNpdGlvbi50cmVlQ2hhbmdlcygpO1xuXHQgICAgICAgIC8qKiBhIGZ1bmN0aW9uIHdoaWNoIHJlc29sdmVzIGFueSBFQUdFUiBSZXNvbHZhYmxlcyBmb3IgYSBQYXRoICovXG5cdCAgICAgICAgJGVhZ2VyUmVzb2x2ZVBhdGguJGluamVjdCA9IFsnJHRyYW5zaXRpb24kJ107XG5cdCAgICAgICAgZnVuY3Rpb24gJGVhZ2VyUmVzb2x2ZVBhdGgoJHRyYW5zaXRpb24kKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKHRyZWVDaGFuZ2VzLnRvKS5yZXNvbHZlQ29udGV4dC5yZXNvbHZlUGF0aChjb21tb25fMS5leHRlbmQoeyB0cmFuc2l0aW9uOiAkdHJhbnNpdGlvbiQgfSwgeyByZXNvbHZlUG9saWN5OiBFQUdFUiB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggcHJlLXJlc29sdmVzIGFueSBMQVpZIFJlc29sdmFibGVzIGZvciBhIE5vZGUgaW4gYSBQYXRoICovXG5cdCAgICAgICAgJGxhenlSZXNvbHZlRW50ZXJpbmdTdGF0ZS4kaW5qZWN0ID0gWyckc3RhdGUkJywgJyR0cmFuc2l0aW9uJCddO1xuXHQgICAgICAgIGZ1bmN0aW9uICRsYXp5UmVzb2x2ZUVudGVyaW5nU3RhdGUoJHN0YXRlJCwgJHRyYW5zaXRpb24kKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZCh0cmVlQ2hhbmdlcy5lbnRlcmluZywgaG9mXzEucHJvcEVxKCdzdGF0ZScsICRzdGF0ZSQpKTtcblx0ICAgICAgICAgICAgLy8gQSBuZXcgUmVzb2x2YWJsZSBjb250YWlucyBhbGwgdGhlIHJlc29sdmVkIGRhdGEgaW4gdGhpcyBjb250ZXh0IGFzIGEgc2luZ2xlIG9iamVjdCwgZm9yIGluamVjdGlvbiBhcyBgJHJlc29sdmUkYFxuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IG5vZGUucmVzb2x2ZUNvbnRleHQ7XG5cdCAgICAgICAgICAgIHZhciAkcmVzb2x2ZSQgPSBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUoXCIkcmVzb2x2ZSRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEubWFwKGNvbnRleHQuZ2V0UmVzb2x2YWJsZXMoKSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuZGF0YTsgfSk7IH0pO1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7IHRyYW5zaXRpb246ICR0cmFuc2l0aW9uJCB9LCB7IHJlc29sdmVQb2xpY3k6IExBWlkgfSk7XG5cdCAgICAgICAgICAgIC8vIFJlc29sdmUgYWxsIHRoZSBMQVpZIHJlc29sdmVzLCB0aGVuIHJlc29sdmUgdGhlIGAkcmVzb2x2ZSRgIG9iamVjdCwgdGhlbiBhZGQgYCRyZXNvbHZlJGAgdG8gdGhlIGNvbnRleHRcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzb2x2ZVBhdGhFbGVtZW50KG5vZGUuc3RhdGUsIG9wdGlvbnMpXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiAkcmVzb2x2ZSQucmVzb2x2ZVJlc29sdmFibGUoY29udGV4dCk7IH0pXG5cdCAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb250ZXh0LmFkZFJlc29sdmFibGVzKHsgJHJlc29sdmUkOiAkcmVzb2x2ZSQgfSwgbm9kZS5zdGF0ZSk7IH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBSZXNvbHZlIGVhZ2VyIHJlc29sdmFibGVzIGJlZm9yZSB3aGVuIHRoZSB0cmFuc2l0aW9uIHN0YXJ0c1xuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbi5vblN0YXJ0KHt9LCAkZWFnZXJSZXNvbHZlUGF0aCwgeyBwcmlvcml0eTogMTAwMCB9KTtcblx0ICAgICAgICAvLyBSZXNvbHZlIGxhenkgcmVzb2x2YWJsZXMgYmVmb3JlIGVhY2ggc3RhdGUgaXMgZW50ZXJlZFxuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvbi5vbkVudGVyKHsgZW50ZXJpbmc6IGhvZl8yLnZhbCh0cnVlKSB9LCAkbGF6eVJlc29sdmVFbnRlcmluZ1N0YXRlLCB7IHByaW9yaXR5OiAxMDAwIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZXNvbHZlSG9va3M7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVzb2x2ZUhvb2tzID0gUmVzb2x2ZUhvb2tzO1xuXG5cbi8qKiovIH0sXG4vKiAzMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8vIERlZmluZXMgdGhlIGF2YWlsYWJsZSBwb2xpY2llcyBhbmQgdGhlaXIgb3JkaW5hbHMuXG5cdChmdW5jdGlvbiAoUmVzb2x2ZVBvbGljeSkge1xuXHQgICAgUmVzb2x2ZVBvbGljeVtSZXNvbHZlUG9saWN5W1wiSklUXCJdID0gMF0gPSBcIkpJVFwiO1xuXHQgICAgUmVzb2x2ZVBvbGljeVtSZXNvbHZlUG9saWN5W1wiTEFaWVwiXSA9IDFdID0gXCJMQVpZXCI7XG5cdCAgICBSZXNvbHZlUG9saWN5W1Jlc29sdmVQb2xpY3lbXCJFQUdFUlwiXSA9IDJdID0gXCJFQUdFUlwiOyAvLyBFYWdlciByZXNvbHZlcyBhcmUgcmVzb2x2ZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uIHN0YXJ0cy5cblx0fSkoZXhwb3J0cy5SZXNvbHZlUG9saWN5IHx8IChleHBvcnRzLlJlc29sdmVQb2xpY3kgPSB7fSkpO1xuXHR2YXIgUmVzb2x2ZVBvbGljeSA9IGV4cG9ydHMuUmVzb2x2ZVBvbGljeTtcblxuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSByZXNvbHZlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGNvcmVzZXJ2aWNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIHRyYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0LyoqXG5cdCAqIFRoZSBiYXNpYyBidWlsZGluZyBibG9jayBmb3IgdGhlIHJlc29sdmUgc3lzdGVtLlxuXHQgKlxuXHQgKiBSZXNvbHZhYmxlcyBlbmNhcHN1bGF0ZSBhIHN0YXRlJ3MgcmVzb2x2ZSdzIHJlc29sdmVGbiwgdGhlIHJlc29sdmVGbidzIGRlY2xhcmVkIGRlcGVuZGVuY2llcywgdGhlIHdyYXBwZWQgKC5wcm9taXNlKSxcblx0ICogYW5kIHRoZSB1bndyYXBwZWQtd2hlbi1jb21wbGV0ZSAoLmRhdGEpIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZUZuLlxuXHQgKlxuXHQgKiBSZXNvbHZhYmxlLmdldCgpIGVpdGhlciByZXRyaWV2ZXMgdGhlIFJlc29sdmFibGUncyBleGlzdGluZyBwcm9taXNlLCBvciBlbHNlIGludm9rZXMgcmVzb2x2ZSgpICh3aGljaCBpbnZva2VzIHRoZVxuXHQgKiByZXNvbHZlRm4pIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgcHJvbWlzZS5cblx0ICpcblx0ICogUmVzb2x2YWJsZS5nZXQoKSBhbmQgUmVzb2x2YWJsZS5yZXNvbHZlKCkgYm90aCBleGVjdXRlIHdpdGhpbiBhIGNvbnRleHQgcGF0aCwgd2hpY2ggaXMgcGFzc2VkIGFzIHRoZSBmaXJzdFxuXHQgKiBwYXJhbWV0ZXIgdG8gdGhvc2UgZm5zLlxuXHQgKi9cblx0dmFyIFJlc29sdmFibGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVzb2x2YWJsZShuYW1lLCByZXNvbHZlRm4sIHByZVJlc29sdmVkRGF0YSkge1xuXHQgICAgICAgIHRoaXMucHJvbWlzZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywge1xuXHQgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICByZXNvbHZlRm46IHJlc29sdmVGbixcblx0ICAgICAgICAgICAgZGVwczogY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHJlc29sdmVGbiwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLnN0cmljdERpKSxcblx0ICAgICAgICAgICAgZGF0YTogcHJlUmVzb2x2ZWREYXRhXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICAvLyBzeW5jaHJvbm91cyBwYXJ0OlxuXHQgICAgLy8gLSBzZXRzIHVwIHRoZSBSZXNvbHZhYmxlJ3MgcHJvbWlzZVxuXHQgICAgLy8gLSByZXRyaWV2ZXMgZGVwZW5kZW5jaWVzJyBwcm9taXNlc1xuXHQgICAgLy8gLSByZXR1cm5zIHByb21pc2UgZm9yIGFzeW5jIHBhcnRcblx0ICAgIC8vIGFzeW5jaHJvbm91cyBwYXJ0OlxuXHQgICAgLy8gLSB3YWl0IGZvciBkZXBlbmRlbmNpZXMgcHJvbWlzZXMgdG8gcmVzb2x2ZVxuXHQgICAgLy8gLSBpbnZva2UgdGhlIHJlc29sdmVGblxuXHQgICAgLy8gLSB3YWl0IGZvciByZXNvbHZlRm4gcHJvbWlzZSB0byByZXNvbHZlXG5cdCAgICAvLyAtIHN0b3JlIHVud3JhcHBlZCBkYXRhXG5cdCAgICAvLyAtIHJlc29sdmUgdGhlIFJlc29sdmFibGUncyBwcm9taXNlXG5cdCAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5yZXNvbHZlUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgb3B0aW9ucykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB2YXIgX2EgPSB0aGlzLCBuYW1lID0gX2EubmFtZSwgZGVwcyA9IF9hLmRlcHMsIHJlc29sdmVGbiA9IF9hLnJlc29sdmVGbjtcblx0ICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUmVzb2x2ZVJlc29sdmFibGUodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLy8gRmlyc3QsIHNldCB1cCBhbiBvdmVyYWxsIGRlZmVycmVkL3Byb21pc2UgZm9yIHRoaXMgUmVzb2x2YWJsZVxuXHQgICAgICAgIHZhciBkZWZlcnJlZCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmRlZmVyKCk7XG5cdCAgICAgICAgdGhpcy5wcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcblx0ICAgICAgICAvLyBMb2FkIGEgbWFwIG9mIGFsbCByZXNvbHZhYmxlcyBmb3IgdGhpcyBzdGF0ZSBmcm9tIHRoZSBjb250ZXh0IHBhdGhcblx0ICAgICAgICAvLyBPbWl0IHRoZSBjdXJyZW50IFJlc29sdmFibGUgZnJvbSB0aGUgcmVzdWx0LCBzbyB3ZSBkb24ndCB0cnkgdG8gaW5qZWN0IHRoaXMgaW50byB0aGlzXG5cdCAgICAgICAgdmFyIGFuY2VzdG9yc0J5TmFtZSA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGVzKG51bGwsIHsgb21pdE93bkxvY2FsczogW25hbWVdIH0pO1xuXHQgICAgICAgIC8vIExpbWl0IHRoZSBhbmNlc3RvcnMgUmVzb2x2YWJsZXMgbWFwIHRvIG9ubHkgdGhvc2UgdGhhdCB0aGUgY3VycmVudCBSZXNvbHZhYmxlIGZuJ3MgYW5ub3RhdGlvbnMgZGVwZW5kcyBvblxuXHQgICAgICAgIHZhciBkZXBSZXNvbHZhYmxlcyA9IGNvbW1vbl8xLnBpY2soYW5jZXN0b3JzQnlOYW1lLCBkZXBzKTtcblx0ICAgICAgICAvLyBHZXQgcHJvbWlzZXMgKG9yIHN5bmNocm9ub3VzbHkgaW52b2tlIHJlc29sdmVGbikgZm9yIGRlcHNcblx0ICAgICAgICB2YXIgZGVwUHJvbWlzZXMgPSBjb21tb25fMS5tYXAoZGVwUmVzb2x2YWJsZXMsIGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7IHJldHVybiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgb3B0aW9ucyk7IH0pO1xuXHQgICAgICAgIC8vIFJldHVybiBhIHByb21pc2UgY2hhaW4gdGhhdCB3YWl0cyBmb3IgYWxsIHRoZSBkZXBzIHRvIHJlc29sdmUsIHRoZW4gaW52b2tlcyB0aGUgcmVzb2x2ZUZuIHBhc3NpbmcgaW4gdGhlXG5cdCAgICAgICAgLy8gZGVwZW5kZW5jaWVzIGFzIGxvY2FscywgdGhlbiB1bndyYXBzIHRoZSByZXN1bHRpbmcgcHJvbWlzZSdzIGRhdGEuXG5cdCAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmFsbChkZXBQcm9taXNlcykudGhlbihmdW5jdGlvbiAobG9jYWxzKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShyZXNvbHZlRm4sIG51bGwsIGxvY2Fscyk7XG5cdCAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9taXNlO1xuXHQgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG5cdCAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZhYmxlUmVzb2x2ZWQoX3RoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocmVzb2x2ZUNvbnRleHQsIG9wdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlIHx8IHRoaXMucmVzb2x2ZVJlc29sdmFibGUocmVzb2x2ZUNvbnRleHQsIG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIFJlc29sdmFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBcIlJlc29sdmFibGUobmFtZTogXCIgKyB0aGlzLm5hbWUgKyBcIiwgcmVxdWlyZXM6IFtcIiArIHRoaXMuZGVwcyArIFwiXSlcIjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFZhbGlkYXRlcyB0aGUgcmVzdWx0IG1hcCBhcyBhIFwicmVzb2x2ZTpcIiBzdHlsZSBvYmplY3QsIHRoZW4gdHJhbnNmb3JtcyB0aGUgcmVzb2x2ZXMgaW50byBSZXNvbHZhYmxlc1xuXHQgICAgICovXG5cdCAgICBSZXNvbHZhYmxlLm1ha2VSZXNvbHZhYmxlcyA9IGZ1bmN0aW9uIChyZXNvbHZlcykge1xuXHQgICAgICAgIC8vIElmIGEgaG9vayByZXN1bHQgaXMgYW4gb2JqZWN0LCBpdCBzaG91bGQgYmUgYSBtYXAgb2Ygc3RyaW5ncyB0byBmdW5jdGlvbnMuXG5cdCAgICAgICAgdmFyIGludmFsaWQgPSBjb21tb25fMS5maWx0ZXIocmVzb2x2ZXMsIGhvZl8xLm5vdChwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKSksIGtleXMgPSBPYmplY3Qua2V5cyhpbnZhbGlkKTtcblx0ICAgICAgICBpZiAoa2V5cy5sZW5ndGgpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzb2x2ZSBrZXkvdmFsdWU6IFwiICsga2V5c1swXSArIFwiL1wiICsgaW52YWxpZFtrZXlzWzBdXSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcChyZXNvbHZlcywgZnVuY3Rpb24gKGZuLCBuYW1lKSB7IHJldHVybiBuZXcgUmVzb2x2YWJsZShuYW1lLCBmbik7IH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZXNvbHZhYmxlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlJlc29sdmFibGUgPSBSZXNvbHZhYmxlO1xuXG5cbi8qKiovIH0sXG4vKiAzMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHQvKipcblx0ICogQG5nZG9jIG9iamVjdFxuXHQgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUudHlwZTpTdGF0ZVxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogRGVmaW5pdGlvbiBvYmplY3QgZm9yIHN0YXRlcy4gSW5jbHVkZXMgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHRoZSBzdGF0ZSBoZWlyYXJjaHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgIEEgY29uZmlndXJhdGlvbiBvYmplY3QgaGFzaCB0aGF0IGluY2x1ZGVzIHRoZSByZXN1bHRzIG9mIHVzZXItc3VwcGxpZWRcblx0ICogICAgICAgIHZhbHVlcywgYXMgd2VsbCBhcyB2YWx1ZXMgZnJvbSBgU3RhdGVCdWlsZGVyYC5cblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gIFJldHVybnMgYSBuZXcgYFN0YXRlYCBvYmplY3QuXG5cdCAqL1xuXHR2YXIgU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGUoY29uZmlnKSB7XG5cdCAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cdCAgICAgICAgLy8gT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUudHlwZTpTdGF0ZSNpc1xuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS50eXBlOlN0YXRlXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBDb21wYXJlcyB0aGUgaWRlbnRpdHkgb2YgdGhlIHN0YXRlIGFnYWluc3QgdGhlIHBhc3NlZCB2YWx1ZSwgd2hpY2ggaXMgZWl0aGVyIGFuIG9iamVjdFxuXHQgICAgICogcmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgYFN0YXRlYCBpbnN0YW5jZSwgdGhlIG9yaWdpbmFsIGRlZmluaXRpb24gb2JqZWN0IHBhc3NlZCB0b1xuXHQgICAgICogYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCBvciB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHJlZiBDYW4gYmUgb25lIG9mIChhKSBhIGBTdGF0ZWAgaW5zdGFuY2UsIChiKSBhbiBvYmplY3QgdGhhdCB3YXMgcGFzc2VkXG5cdCAgICAgKiAgICAgICAgaW50byBgJHN0YXRlUHJvdmlkZXIuc3RhdGUoKWAsIChjKSB0aGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgb2YgYSBzdGF0ZSBhcyBhIHN0cmluZy5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcmVmYCBtYXRjaGVzIHRoZSBjdXJyZW50IGBTdGF0ZWAgaW5zdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChyZWYpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcyA9PT0gcmVmIHx8IHRoaXMuc2VsZiA9PT0gcmVmIHx8IHRoaXMuZnFuKCkgPT09IHJlZjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLnR5cGU6U3RhdGUjZnFuXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLnR5cGU6U3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAqIFJldHVybnMgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lIG9mIHRoZSBzdGF0ZSwgYmFzZWQgb24gaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHRyZWUuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyBhIGRvdC1zZXBhcmF0ZWQgbmFtZSBvZiB0aGUgc3RhdGUuXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlLnByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnBhcmVudCB8fCAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5mcW4oKTtcblx0ICAgICAgICByZXR1cm4gbmFtZSA/IG5hbWUgKyBcIi5cIiArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLnR5cGU6U3RhdGUjcm9vdFxuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS50eXBlOlN0YXRlXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBzdGF0ZSdzIHRyZWUuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMge1N0YXRlfSBUaGUgcm9vdCBvZiB0aGlzIHN0YXRlJ3MgdHJlZS5cblx0ICAgICAqL1xuXHQgICAgU3RhdGUucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnJvb3QoKSB8fCB0aGlzO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0ICAgICAgICBvcHRzID0gY29tbW9uXzEuZGVmYXVsdHMob3B0cywgeyBpbmhlcml0OiB0cnVlIH0pO1xuXHQgICAgICAgIHZhciBpbmhlcml0ZWQgPSBvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVycygpIHx8IFtdO1xuXHQgICAgICAgIHJldHVybiBpbmhlcml0ZWQuY29uY2F0KGNvbW1vbl8xLnZhbHVlcyh0aGlzLnBhcmFtcykpO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAoaWQsIG9wdHMpIHtcblx0ICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuXHQgICAgICAgIHJldHVybiAodGhpcy51cmwgJiYgdGhpcy51cmwucGFyYW1ldGVyKGlkLCBvcHRzKSB8fFxuXHQgICAgICAgICAgICBjb21tb25fMS5maW5kKGNvbW1vbl8xLnZhbHVlcyh0aGlzLnBhcmFtcyksIGhvZl8xLnByb3BFcSgnaWQnLCBpZCkpIHx8XG5cdCAgICAgICAgICAgIG9wdHMuaW5oZXJpdCAmJiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wYXJhbWV0ZXIoaWQpKTtcblx0ICAgIH07XG5cdCAgICBTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZnFuKCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFN0YXRlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRlID0gU3RhdGU7XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgU3RhdGVNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFN0YXRlTWF0Y2hlcihfc3RhdGVzKSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGVzID0gX3N0YXRlcztcblx0ICAgIH1cblx0ICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcblx0ICAgICAgICBzdGF0ZU5hbWUgPSBzdGF0ZU5hbWUgfHwgXCJcIjtcblx0ICAgICAgICByZXR1cm4gc3RhdGVOYW1lLmluZGV4T2YoXCIuXCIpID09PSAwIHx8IHN0YXRlTmFtZS5pbmRleE9mKFwiXlwiKSA9PT0gMDtcblx0ICAgIH07XG5cdCAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcblx0ICAgICAgICBpZiAoIXN0YXRlT3JOYW1lICYmIHN0YXRlT3JOYW1lICE9PSBcIlwiKVxuXHQgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICAgIHZhciBpc1N0ciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSk7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBpc1N0ciA/IHN0YXRlT3JOYW1lIDogc3RhdGVPck5hbWUubmFtZTtcblx0ICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKG5hbWUpKVxuXHQgICAgICAgICAgICBuYW1lID0gdGhpcy5yZXNvbHZlUGF0aChuYW1lLCBiYXNlKTtcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG5cdCAgICAgICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAobmFtZSwgYmFzZSkge1xuXHQgICAgICAgIGlmICghYmFzZSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XG5cdCAgICAgICAgdmFyIGJhc2VTdGF0ZSA9IHRoaXMuZmluZChiYXNlKTtcblx0ICAgICAgICB2YXIgc3BsaXROYW1lID0gbmFtZS5zcGxpdChcIi5cIiksIGkgPSAwLCBwYXRoTGVuZ3RoID0gc3BsaXROYW1lLmxlbmd0aCwgY3VycmVudCA9IGJhc2VTdGF0ZTtcblx0ICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSBcIlwiICYmIGkgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSBcIl5cIikge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoICdcIiArIG5hbWUgKyBcIicgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBiYXNlU3RhdGUubmFtZSArIFwiJ1wiKTtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVsTmFtZSA9IHNwbGl0TmFtZS5zbGljZShpKS5qb2luKFwiLlwiKTtcblx0ICAgICAgICByZXR1cm4gY3VycmVudC5uYW1lICsgKGN1cnJlbnQubmFtZSAmJiByZWxOYW1lID8gXCIuXCIgOiBcIlwiKSArIHJlbE5hbWU7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFN0YXRlTWF0Y2hlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5TdGF0ZU1hdGNoZXIgPSBTdGF0ZU1hdGNoZXI7XG5cblxuLyoqKi8gfSxcbi8qIDM1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgbW9kdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIFN0YXRlUXVldWVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFN0YXRlUXVldWVNYW5hZ2VyKHN0YXRlcywgYnVpbGRlciwgJHVybFJvdXRlclByb3ZpZGVyKSB7XG5cdCAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG5cdCAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcblx0ICAgICAgICB0aGlzLiR1cmxSb3V0ZXJQcm92aWRlciA9ICR1cmxSb3V0ZXJQcm92aWRlcjtcblx0ICAgICAgICB0aGlzLnF1ZXVlID0gW107XG5cdCAgICB9XG5cdCAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGVzID0gX2Euc3RhdGVzLCBxdWV1ZSA9IF9hLnF1ZXVlLCAkc3RhdGUgPSBfYS4kc3RhdGU7XG5cdCAgICAgICAgLy8gV3JhcCBhIG5ldyBvYmplY3QgYXJvdW5kIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gc3RvcmUgb3VyIHByaXZhdGUgZGV0YWlscyBlYXNpbHkuXG5cdCAgICAgICAgLy8gQFRPRE86IHN0YXRlID0gbmV3IFN0YXRlKGV4dGVuZCh7fSwgY29uZmlnLCB7IC4uLiB9KSlcblx0ICAgICAgICB2YXIgc3RhdGUgPSBjb21tb25fMS5pbmhlcml0KG5ldyBtb2R1bGVfMS5TdGF0ZSgpLCBjb21tb25fMS5leHRlbmQoe30sIGNvbmZpZywge1xuXHQgICAgICAgICAgICBzZWxmOiBjb25maWcsXG5cdCAgICAgICAgICAgIHJlc29sdmU6IGNvbmZpZy5yZXNvbHZlIHx8IHt9LFxuXHQgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnLm5hbWU7IH1cblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUubmFtZSkpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG11c3QgaGF2ZSBhIHZhbGlkIG5hbWVcIik7XG5cdCAgICAgICAgaWYgKHN0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZS5uYW1lKSB8fCBjb21tb25fMS5wbHVjayhxdWV1ZSwgJ25hbWUnKS5pbmRleE9mKHN0YXRlLm5hbWUpICE9PSAtMSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XG5cdCAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuJHN0YXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZmx1c2goJHN0YXRlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0YXRlO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgkc3RhdGUpIHtcblx0ICAgICAgICB2YXIgX2EgPSB0aGlzLCBxdWV1ZSA9IF9hLnF1ZXVlLCBzdGF0ZXMgPSBfYS5zdGF0ZXMsIGJ1aWxkZXIgPSBfYS5idWlsZGVyO1xuXHQgICAgICAgIHZhciByZXN1bHQsIHN0YXRlLCBvcnBoYW5zID0gW10sIG9ycGhhbklkeCwgcHJldmlvdXNRdWV1ZUxlbmd0aCA9IHt9O1xuXHQgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIHN0YXRlID0gcXVldWUuc2hpZnQoKTtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gYnVpbGRlci5idWlsZChzdGF0ZSk7XG5cdCAgICAgICAgICAgIG9ycGhhbklkeCA9IG9ycGhhbnMuaW5kZXhPZihzdGF0ZSk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZXMuaGFzT3duUHJvcGVydHkoc3RhdGUubmFtZSkpXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlZmluZWRcIik7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZXNbc3RhdGUubmFtZV0gPSBzdGF0ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoUm91dGUoJHN0YXRlLCBzdGF0ZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAob3JwaGFuSWR4ID49IDApXG5cdCAgICAgICAgICAgICAgICAgICAgb3JwaGFucy5zcGxpY2Uob3JwaGFuSWR4LCAxKTtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwcmV2ID0gcHJldmlvdXNRdWV1ZUxlbmd0aFtzdGF0ZS5uYW1lXTtcblx0ICAgICAgICAgICAgcHJldmlvdXNRdWV1ZUxlbmd0aFtzdGF0ZS5uYW1lXSA9IHF1ZXVlLmxlbmd0aDtcblx0ICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwICYmIHByZXYgPT09IHF1ZXVlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB0d28gY29uc2VjdXRpdmUgaXRlcmF0aW9ucyB3aGVyZSBubyBhZGRpdGlvbmFsIHN0YXRlcyB3ZXJlIGRlcXVldWVkIHN1Y2Nlc3NmdWxseS5cblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWdpc3RlciBvcnBoYW5lZCBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG9ycGhhbklkeCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIG9ycGhhbnMucHVzaChzdGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcXVldWUucHVzaChzdGF0ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdGF0ZXM7XG5cdCAgICB9O1xuXHQgICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmF1dG9GbHVzaCA9IGZ1bmN0aW9uICgkc3RhdGUpIHtcblx0ICAgICAgICB0aGlzLiRzdGF0ZSA9ICRzdGF0ZTtcblx0ICAgICAgICB0aGlzLmZsdXNoKCRzdGF0ZSk7XG5cdCAgICB9O1xuXHQgICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmF0dGFjaFJvdXRlID0gZnVuY3Rpb24gKCRzdGF0ZSwgc3RhdGUpIHtcblx0ICAgICAgICB2YXIgJHVybFJvdXRlclByb3ZpZGVyID0gdGhpcy4kdXJsUm91dGVyUHJvdmlkZXI7XG5cdCAgICAgICAgaWYgKHN0YXRlW2NvbW1vbl8xLmFic3RyYWN0S2V5XSB8fCAhc3RhdGUudXJsKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oc3RhdGUudXJsLCBbJyRtYXRjaCcsICckc3RhdGVQYXJhbXMnLCBmdW5jdGlvbiAoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlICE9PSBzdGF0ZSB8fCAhY29tbW9uXzEuZXF1YWxGb3JLZXlzKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgeyBpbmhlcml0OiB0cnVlIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFN0YXRlUXVldWVNYW5hZ2VyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRlUXVldWVNYW5hZ2VyID0gU3RhdGVRdWV1ZU1hbmFnZXI7XG5cblxuLyoqKi8gfSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBzdGF0ZU1hdGNoZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXHR2YXIgc3RhdGVCdWlsZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0dmFyIHN0YXRlUXVldWVNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblx0dmFyIFN0YXRlUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGVSZWdpc3RyeSh1cmxNYXRjaGVyRmFjdG9yeSwgdXJsUm91dGVyUHJvdmlkZXIpIHtcblx0ICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuXHQgICAgICAgIHRoaXMubWF0Y2hlciA9IG5ldyBzdGF0ZU1hdGNoZXJfMS5TdGF0ZU1hdGNoZXIodGhpcy5zdGF0ZXMpO1xuXHQgICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBzdGF0ZUJ1aWxkZXJfMS5TdGF0ZUJ1aWxkZXIodGhpcy5tYXRjaGVyLCB1cmxNYXRjaGVyRmFjdG9yeSk7XG5cdCAgICAgICAgdGhpcy5zdGF0ZVF1ZXVlID0gbmV3IHN0YXRlUXVldWVNYW5hZ2VyXzEuU3RhdGVRdWV1ZU1hbmFnZXIodGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdXJsUm91dGVyUHJvdmlkZXIpO1xuXHQgICAgICAgIHZhciByb290U3RhdGVEZWYgPSB7XG5cdCAgICAgICAgICAgIG5hbWU6ICcnLFxuXHQgICAgICAgICAgICB1cmw6ICdeJyxcblx0ICAgICAgICAgICAgdmlld3M6IG51bGwsXG5cdCAgICAgICAgICAgIHBhcmFtczoge1xuXHQgICAgICAgICAgICAgICAgJyMnOiB7IHZhbHVlOiBudWxsLCB0eXBlOiAnaGFzaCcgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBhYnN0cmFjdDogdHJ1ZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIF9yb290ID0gdGhpcy5fcm9vdCA9IHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3Rlcihyb290U3RhdGVEZWYpO1xuXHQgICAgICAgIF9yb290Lm5hdmlnYWJsZSA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9yb290O1xuXHQgICAgfTtcblx0ICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVmaW5pdGlvbikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnN0YXRlUXVldWUucmVnaXN0ZXIoc3RhdGVEZWZpbml0aW9uKTtcblx0ICAgIH07XG5cdCAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuXHQgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuc3RhdGVzW25hbWVdLnNlbGY7IH0pO1xuXHQgICAgICAgIHZhciBmb3VuZCA9IHRoaXMubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBiYXNlKTtcblx0ICAgICAgICByZXR1cm4gZm91bmQgJiYgZm91bmQuc2VsZiB8fCBudWxsO1xuXHQgICAgfTtcblx0ICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlY29yYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRlci5idWlsZGVyKG5hbWUsIGZ1bmMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTdGF0ZVJlZ2lzdHJ5O1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRlUmVnaXN0cnkgPSBTdGF0ZVJlZ2lzdHJ5O1xuXG5cbi8qKiovIH0sXG4vKiAzNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHN0YXRlICovIC8qKiAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgcGF0aEZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHR2YXIgbm9kZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cdHZhciB0cmFuc2l0aW9uU2VydmljZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cdHZhciByZWplY3RGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIHRhcmdldFN0YXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblx0dmFyIHRyYW5zaXRpb25NYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0dmFyIHBhcmFtXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0dmFyIGdsb2JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciBjb21tb25fMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBjb21tb25fMyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBTdGF0ZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGVTZXJ2aWNlKCR2aWV3LCAkdXJsUm91dGVyLCAkdHJhbnNpdGlvbnMsIHN0YXRlUmVnaXN0cnksIHN0YXRlUHJvdmlkZXIsIGdsb2JhbHMpIHtcblx0ICAgICAgICB0aGlzLiR2aWV3ID0gJHZpZXc7XG5cdCAgICAgICAgdGhpcy4kdXJsUm91dGVyID0gJHVybFJvdXRlcjtcblx0ICAgICAgICB0aGlzLiR0cmFuc2l0aW9ucyA9ICR0cmFuc2l0aW9ucztcblx0ICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBzdGF0ZVJlZ2lzdHJ5O1xuXHQgICAgICAgIHRoaXMuc3RhdGVQcm92aWRlciA9IHN0YXRlUHJvdmlkZXI7XG5cdCAgICAgICAgdGhpcy5nbG9iYWxzID0gZ2xvYmFscztcblx0ICAgICAgICB0aGlzLnJlamVjdEZhY3RvcnkgPSBuZXcgcmVqZWN0RmFjdG9yeV8xLlJlamVjdEZhY3RvcnkoKTtcblx0ICAgICAgICB2YXIgZ2V0dGVycyA9IFsnY3VycmVudCcsICckY3VycmVudCcsICdwYXJhbXMnLCAndHJhbnNpdGlvbiddO1xuXHQgICAgICAgIHZhciBib3VuZEZucyA9IE9iamVjdC5rZXlzKFN0YXRlU2VydmljZS5wcm90b3R5cGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZXR0ZXJzLmluZGV4T2Yoa2V5KSA9PT0gLTE7IH0pO1xuXHQgICAgICAgIGNvbW1vbl8zLmJpbmRGdW5jdGlvbnMoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgdGhpcywgdGhpcywgYm91bmRGbnMpO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwidHJhbnNpdGlvblwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdsb2JhbHMudHJhbnNpdGlvbjsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJwYXJhbXNcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5nbG9iYWxzLnBhcmFtczsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJjdXJyZW50XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ2xvYmFscy5jdXJyZW50OyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcIiRjdXJyZW50XCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ2xvYmFscy4kY3VycmVudDsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZXMgdGhlIG9uSW52YWxpZCBjYWxsYmFja3MsIGluIG5hdHVyYWwgb3JkZXIuICBFYWNoIGNhbGxiYWNrJ3MgcmV0dXJuIHZhbHVlIGlzIGNoZWNrZWQgaW4gc2VxdWVuY2Vcblx0ICAgICAqIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFyZ2V0U3RhdGUuICAgVGhlIHJlc3VsdHMgb2YgdGhlIGNhbGxiYWNrcyBhcmUgd3JhcHBlZFxuXHQgICAgICogaW4gJHEud2hlbigpLCBzbyB0aGUgY2FsbGJhY2tzIG1heSByZXR1cm4gcHJvbWlzZXMuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBjYWxsYmFjayByZXR1cm5zIGFuIFRhcmdldFN0YXRlLCB0aGVuIGl0IGlzIHVzZWQgYXMgYXJndW1lbnRzIHRvICRzdGF0ZS50cmFuc2l0aW9uVG8oKSBhbmRcblx0ICAgICAqIHRoZSByZXN1bHQgcmV0dXJuZWQuXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgJHRvJCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGxhdGVzdFRoaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5wZWVrVGFpbCgpOyB9O1xuXHQgICAgICAgIHZhciBsYXRlc3QgPSBsYXRlc3RUaGluZygpO1xuXHQgICAgICAgIHZhciAkZnJvbSQgPSBwYXRoRmFjdG9yeV8xLlBhdGhGYWN0b3J5Lm1ha2VUYXJnZXRTdGF0ZShmcm9tUGF0aCk7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrUXVldWUgPSBuZXcgcXVldWVfMS5RdWV1ZShbXS5jb25jYXQodGhpcy5zdGF0ZVByb3ZpZGVyLmludmFsaWRDYWxsYmFja3MpKTtcblx0ICAgICAgICB2YXIgcmVqZWN0RmFjdG9yeSA9IHRoaXMucmVqZWN0RmFjdG9yeTtcblx0ICAgICAgICB2YXIgJHEgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcSwgJGluamVjdG9yID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yO1xuXHQgICAgICAgIHZhciBpbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gJHEud2hlbigkaW5qZWN0b3IuaW52b2tlKGNhbGxiYWNrLCBudWxsLCB7ICR0byQ6ICR0byQsICRmcm9tJDogJGZyb20kIH0pKTsgfTtcblx0ICAgICAgICB2YXIgY2hlY2tGb3JSZWRpcmVjdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAvLyBSZWNyZWF0ZSB0aGUgVGFyZ2V0U3RhdGUsIGluIGNhc2UgdGhlIHN0YXRlIGlzIG5vdyBkZWZpbmVkLlxuXHQgICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy50YXJnZXQodGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcblx0ICAgICAgICAgICAgaWYgKCF0YXJnZXQudmFsaWQoKSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5LmludmFsaWQodGFyZ2V0LmVycm9yKCkpO1xuXHQgICAgICAgICAgICBpZiAobGF0ZXN0VGhpbmcoKSAhPT0gbGF0ZXN0KVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3Rvcnkuc3VwZXJzZWRlZCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNpdGlvblRvKHRhcmdldC5pZGVudGlmaWVyKCksIHRhcmdldC5wYXJhbXMoKSwgdGFyZ2V0Lm9wdGlvbnMoKSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBpbnZva2VOZXh0Q2FsbGJhY2soKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXh0Q2FsbGJhY2sgPSBjYWxsYmFja1F1ZXVlLmRlcXVldWUoKTtcblx0ICAgICAgICAgICAgaWYgKG5leHRDYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdEZhY3RvcnkuaW52YWxpZCgkdG8kLmVycm9yKCkpO1xuXHQgICAgICAgICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2sobmV4dENhbGxiYWNrKS50aGVuKGNoZWNrRm9yUmVkaXJlY3QpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IHx8IGludm9rZU5leHRDYWxsYmFjaygpOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGludm9rZU5leHRDYWxsYmFjaygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI3JlbG9hZFxuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAqIEEgbWV0aG9kIHRoYXQgZm9yY2UgcmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZSwgb3IgYSBwYXJ0aWFsIHN0YXRlIGhpZXJhcmNoeS4gQWxsIHJlc29sdmVzIGFyZSByZS1yZXNvbHZlZCxcblx0ICAgICAqIGNvbnRyb2xsZXJzIHJlaW5zdGFudGlhdGVkLCBhbmQgZXZlbnRzIHJlLWZpcmVkLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG5cdCAgICAgKlxuXHQgICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcblx0ICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG5cdCAgICAgKiAgICAgJHN0YXRlLnJlbG9hZCgpO1xuXHQgICAgICogICB9XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIGByZWxvYWQoKWAgaXMganVzdCBhbiBhbGlhcyBmb3I6XG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogJHN0YXRlLnRyYW5zaXRpb25Ubygkc3RhdGUuY3VycmVudCwgJHN0YXRlUGFyYW1zLCB7XG5cdCAgICAgKiAgIHJlbG9hZDogdHJ1ZSwgaW5oZXJpdDogZmFsc2UsIG5vdGlmeTogdHJ1ZVxuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZz18b2JqZWN0PX0gcmVsb2FkU3RhdGUgLSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QsIHdoaWNoIGlzIHRoZSByb290IG9mIHRoZSByZXNvbHZlcyB0byBiZSByZS1yZXNvbHZlZC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogLy9hc3N1bWluZyBhcHAgYXBwbGljYXRpb24gY29uc2lzdHMgb2YgMyBzdGF0ZXM6ICdjb250YWN0cycsICdjb250YWN0cy5kZXRhaWwnLCAnY29udGFjdHMuZGV0YWlsLml0ZW0nXG5cdCAgICAgKiAvL2FuZCBjdXJyZW50IHN0YXRlIGlzICdjb250YWN0cy5kZXRhaWwuaXRlbSdcblx0ICAgICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuXHQgICAgICpcblx0ICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG5cdCAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuXHQgICAgICogICAgIC8vd2lsbCByZWxvYWQgJ2NvbnRhY3QuZGV0YWlsJyBhbmQgbmVzdGVkICdjb250YWN0LmRldGFpbC5pdGVtJyBzdGF0ZXNcblx0ICAgICAqICAgICAkc3RhdGUucmVsb2FkKCdjb250YWN0LmRldGFpbCcpO1xuXHQgICAgICogICB9XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZVxuXHQgICAgICoge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19nbyAkc3RhdGUuZ299LlxuXHQgICAgICovXG5cdCAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uIChyZWxvYWRTdGF0ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLmN1cnJlbnQsIHRoaXMucGFyYW1zLCB7XG5cdCAgICAgICAgICAgIHJlbG9hZDogcHJlZGljYXRlc18xLmlzRGVmaW5lZChyZWxvYWRTdGF0ZSkgPyByZWxvYWRTdGF0ZSA6IHRydWUsXG5cdCAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuXHQgICAgICAgICAgICBub3RpZnk6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjZ29cblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuIGAkc3RhdGUuZ29gIGNhbGxzXG5cdCAgICAgKiBgJHN0YXRlLnRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSBidXQgYXV0b21hdGljYWxseSBzZXRzIG9wdGlvbnMgdG9cblx0ICAgICAqIGB7IGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50LCBub3RpZnk6IHRydWUgfWAuXG5cdCAgICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gZWFzaWx5IHVzZSBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byBwYXRoIGFuZCBzcGVjaWZ5XG5cdCAgICAgKiBvbmx5IHRoZSBwYXJhbWV0ZXJzIHlvdSdkIGxpa2UgdG8gdXBkYXRlICh3aGlsZSBsZXR0aW5nIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcblx0ICAgICAqIGluaGVyaXQgZnJvbSB0aGUgY3VycmVudGx5IGFjdGl2ZSBhbmNlc3RvciBzdGF0ZXMpLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcblx0ICAgICAqXG5cdCAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuXHQgICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgKiAgICAgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpO1xuXHQgICAgICogICB9O1xuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqIDxpbWcgc3JjPScuLi9uZ2RvY19hc3NldHMvU3RhdGVHb0V4YW1wbGVzLnBuZycvPlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0byBBYnNvbHV0ZSBzdGF0ZSBuYW1lIG9yIHJlbGF0aXZlIHN0YXRlIHBhdGguIFNvbWUgZXhhbXBsZXM6XG5cdCAgICAgKlxuXHQgICAgICogLSBgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpYCAtIHdpbGwgZ28gdG8gdGhlIGBjb250YWN0LmRldGFpbGAgc3RhdGVcblx0ICAgICAqIC0gYCRzdGF0ZS5nbygnXicpYCAtIHdpbGwgZ28gdG8gYSBwYXJlbnQgc3RhdGVcblx0ICAgICAqIC0gYCRzdGF0ZS5nbygnXi5zaWJsaW5nJylgIC0gd2lsbCBnbyB0byBhIHNpYmxpbmcgc3RhdGVcblx0ICAgICAqIC0gYCRzdGF0ZS5nbygnLmNoaWxkLmdyYW5kY2hpbGQnKWAgLSB3aWxsIGdvIHRvIGdyYW5kY2hpbGQgc3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdD19IHBhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXG5cdCAgICAgKiB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy4gQW55IHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNwZWNpZmllZCB3aWxsIGJlIGluaGVyaXRlZCBmcm9tIGN1cnJlbnRseVxuXHQgICAgICogZGVmaW5lZCBwYXJhbWV0ZXJzLiBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGdvaW5nIHRvIGEgc2libGluZyBzdGF0ZSB0aGF0IHNoYXJlcyBwYXJhbWV0ZXJzXG5cdCAgICAgKiBzcGVjaWZpZWQgaW4gYSBwYXJlbnQgc3RhdGUuIFBhcmFtZXRlciBpbmhlcml0YW5jZSBvbmx5IHdvcmtzIGJldHdlZW4gY29tbW9uIGFuY2VzdG9yIHN0YXRlcywgSS5lLlxuXHQgICAgICogdHJhbnNpdGlvbmluZyB0byBhIHNpYmxpbmcgd2lsbCBnZXQgeW91IHRoZSBwYXJhbWV0ZXJzIGZvciBhbGwgcGFyZW50cywgdHJhbnNpdGlvbmluZyB0byBhIGNoaWxkXG5cdCAgICAgKiB3aWxsIGdldCB5b3UgYWxsIGN1cnJlbnQgcGFyYW1ldGVycywgZXRjLlxuXHQgICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG5cdCAgICAgKlxuXHQgICAgICogLSAqKmBsb2NhdGlvbmAqKiAtIHtib29sZWFuPXRydWV8c3RyaW5nPX0gLSBJZiBgdHJ1ZWAgd2lsbCB1cGRhdGUgdGhlIHVybCBpbiB0aGUgbG9jYXRpb24gYmFyLCBpZiBgZmFsc2VgXG5cdCAgICAgKiAgICB3aWxsIG5vdC4gSWYgc3RyaW5nLCBtdXN0IGJlIGBcInJlcGxhY2VcImAsIHdoaWNoIHdpbGwgdXBkYXRlIHVybCBhbmQgYWxzbyByZXBsYWNlIGxhc3QgaGlzdG9yeSByZWNvcmQuXG5cdCAgICAgKiAtICoqYGluaGVyaXRgKiogLSB7Ym9vbGVhbj10cnVlfSwgSWYgYHRydWVgIHdpbGwgaW5oZXJpdCB1cmwgcGFyYW1ldGVycyBmcm9tIGN1cnJlbnQgdXJsLlxuXHQgICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtvYmplY3Q9JHN0YXRlLiRjdXJyZW50fSwgV2hlbiB0cmFuc2l0aW9uaW5nIHdpdGggcmVsYXRpdmUgcGF0aCAoZS5nICdeJyksXG5cdCAgICAgKiAgICBkZWZpbmVzIHdoaWNoIHN0YXRlIHRvIGJlIHJlbGF0aXZlIGZyb20uXG5cdCAgICAgKiAtICoqYG5vdGlmeWAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBicm9hZGNhc3QgJHN0YXRlQ2hhbmdlU3RhcnQgYW5kICRzdGF0ZUNoYW5nZVN1Y2Nlc3MgZXZlbnRzLlxuXHQgICAgICogLSAqKmByZWxvYWRgKiogKHYwLjIuNSkgLSB7Ym9vbGVhbj1mYWxzZX0sIElmIGB0cnVlYCB3aWxsIGZvcmNlIHRyYW5zaXRpb24gZXZlbiBpZiB0aGUgc3RhdGUgb3IgcGFyYW1zXG5cdCAgICAgKiAgICBoYXZlIG5vdCBjaGFuZ2VkLCBha2EgYSByZWxvYWQgb2YgdGhlIHNhbWUgc3RhdGUuIEl0IGRpZmZlcnMgZnJvbSByZWxvYWRPblNlYXJjaCBiZWNhdXNlIHlvdSdkXG5cdCAgICAgKiAgICB1c2UgdGhpcyB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIGEgcmVsb2FkIHdoZW4gKmV2ZXJ5dGhpbmcqIGlzIHRoZSBzYW1lLCBpbmNsdWRpbmcgc2VhcmNoIHBhcmFtcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIFBvc3NpYmxlIHN1Y2Nlc3MgdmFsdWVzOlxuXHQgICAgICpcblx0ICAgICAqIC0gJHN0YXRlLmN1cnJlbnRcblx0ICAgICAqXG5cdCAgICAgKiA8YnIvPlBvc3NpYmxlIHJlamVjdGlvbiB2YWx1ZXM6XG5cdCAgICAgKlxuXHQgICAgICogLSAndHJhbnNpdGlvbiBzdXBlcnNlZGVkJyAtIHdoZW4gYSBuZXdlciB0cmFuc2l0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQgYWZ0ZXIgdGhpcyBvbmVcblx0ICAgICAqIC0gJ3RyYW5zaXRpb24gcHJldmVudGVkJyAtIHdoZW4gYGV2ZW50LnByZXZlbnREZWZhdWx0KClgIGhhcyBiZWVuIGNhbGxlZCBpbiBhIGAkc3RhdGVDaGFuZ2VTdGFydGAgbGlzdGVuZXJcblx0ICAgICAqIC0gJ3RyYW5zaXRpb24gYWJvcnRlZCcgLSB3aGVuIGBldmVudC5wcmV2ZW50RGVmYXVsdCgpYCBoYXMgYmVlbiBjYWxsZWQgaW4gYSBgJHN0YXRlTm90Rm91bmRgIGxpc3RlbmVyIG9yXG5cdCAgICAgKiAgIHdoZW4gYSBgJHN0YXRlTm90Rm91bmRgIGBldmVudC5yZXRyeWAgcHJvbWlzZSBlcnJvcnMuXG5cdCAgICAgKiAtICd0cmFuc2l0aW9uIGZhaWxlZCcgLSB3aGVuIGEgc3RhdGUgaGFzIGJlZW4gdW5zdWNjZXNzZnVsbHkgZm91bmQgYWZ0ZXIgMiB0cmllcy5cblx0ICAgICAqIC0gKnJlc29sdmUgZXJyb3IqIC0gd2hlbiBhbiBlcnJvciBoYXMgb2NjdXJyZWQgd2l0aCBhIGByZXNvbHZlYFxuXHQgICAgICpcblx0ICAgICAqL1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIGRlZmF1dEdvT3B0cyA9IHsgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQsIGluaGVyaXQ6IHRydWUgfTtcblx0ICAgICAgICB2YXIgdHJhbnNPcHRzID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXV0R29PcHRzLCB0cmFuc2l0aW9uU2VydmljZV8xLmRlZmF1bHRUcmFuc09wdHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCB0cmFuc09wdHMpO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIC8qKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBUYXJnZXRTdGF0ZSAqL1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS50YXJnZXQgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICAvLyBJZiB3ZSdyZSByZWxvYWRpbmcsIGZpbmQgdGhlIHN0YXRlIG9iamVjdCB0byByZWxvYWQgZnJvbVxuXHQgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3Qob3B0aW9ucy5yZWxvYWQpICYmICFvcHRpb25zLnJlbG9hZC5uYW1lKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVsb2FkIHN0YXRlIG9iamVjdCcpO1xuXHQgICAgICAgIG9wdGlvbnMucmVsb2FkU3RhdGUgPSBvcHRpb25zLnJlbG9hZCA9PT0gdHJ1ZSA/IHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCkgOiB0aGlzLnN0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKG9wdGlvbnMucmVsb2FkLCBvcHRpb25zLnJlbGF0aXZlKTtcblx0ICAgICAgICBpZiAob3B0aW9ucy5yZWxvYWQgJiYgIW9wdGlvbnMucmVsb2FkU3RhdGUpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob3B0aW9ucy5yZWxvYWQpID8gb3B0aW9ucy5yZWxvYWQgOiBvcHRpb25zLnJlbG9hZC5uYW1lKSArIFwiJ1wiKTtcblx0ICAgICAgICB2YXIgc3RhdGVEZWZpbml0aW9uID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChpZGVudGlmaWVyLCBvcHRpb25zLnJlbGF0aXZlKTtcblx0ICAgICAgICByZXR1cm4gbmV3IHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUoaWRlbnRpZmllciwgc3RhdGVEZWZpbml0aW9uLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI3RyYW5zaXRpb25Ub1xuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAqIExvdy1sZXZlbCBtZXRob2QgZm9yIHRyYW5zaXRpb25pbmcgdG8gYSBuZXcgc3RhdGUuIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfZ28gJHN0YXRlLmdvfVxuXHQgICAgICogdXNlcyBgdHJhbnNpdGlvblRvYCBpbnRlcm5hbGx5LiBgJHN0YXRlLmdvYCBpcyByZWNvbW1lbmRlZCBpbiBtb3N0IHNpdHVhdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiBsZXQgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuXHQgICAgICpcblx0ICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG5cdCAgICAgKiAgICRzY29wZS5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAqICAgICAkc3RhdGUudHJhbnNpdGlvblRvKCdjb250YWN0LmRldGFpbCcpO1xuXHQgICAgICogICB9O1xuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG8gU3RhdGUgbmFtZS5cblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gdG9QYXJhbXMgQSBtYXAgb2YgdGhlIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIHN0YXRlLFxuXHQgICAgICogd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcblx0ICAgICAqXG5cdCAgICAgKiAtICoqYGxvY2F0aW9uYCoqIC0ge2Jvb2xlYW49dHJ1ZXxzdHJpbmc9fSAtIElmIGB0cnVlYCB3aWxsIHVwZGF0ZSB0aGUgdXJsIGluIHRoZSBsb2NhdGlvbiBiYXIsIGlmIGBmYWxzZWBcblx0ICAgICAqICAgIHdpbGwgbm90LiBJZiBzdHJpbmcsIG11c3QgYmUgYFwicmVwbGFjZVwiYCwgd2hpY2ggd2lsbCB1cGRhdGUgdXJsIGFuZCBhbHNvIHJlcGxhY2UgbGFzdCBoaXN0b3J5IHJlY29yZC5cblx0ICAgICAqIC0gKipgaW5oZXJpdGAqKiAtIHtib29sZWFuPWZhbHNlfSwgSWYgYHRydWVgIHdpbGwgaW5oZXJpdCB1cmwgcGFyYW1ldGVycyBmcm9tIGN1cnJlbnQgdXJsLlxuXHQgICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtvYmplY3Q9fSwgV2hlbiB0cmFuc2l0aW9uaW5nIHdpdGggcmVsYXRpdmUgcGF0aCAoZS5nICdeJyksXG5cdCAgICAgKiAgICBkZWZpbmVzIHdoaWNoIHN0YXRlIHRvIGJlIHJlbGF0aXZlIGZyb20uXG5cdCAgICAgKiAtICoqYG5vdGlmeWAqKiAtIHtib29sZWFuPXRydWV9LCBJZiBgdHJ1ZWAgd2lsbCBicm9hZGNhc3QgJHN0YXRlQ2hhbmdlU3RhcnQgYW5kICRzdGF0ZUNoYW5nZVN1Y2Nlc3MgZXZlbnRzLlxuXHQgICAgICogLSAqKmByZWxvYWRgKiogKHYwLjIuNSkgLSB7Ym9vbGVhbj1mYWxzZX0sIElmIGB0cnVlYCB3aWxsIGZvcmNlIHRyYW5zaXRpb24gZXZlbiBpZiB0aGUgc3RhdGUgb3IgcGFyYW1zXG5cdCAgICAgKiAgICBoYXZlIG5vdCBjaGFuZ2VkLCBha2EgYSByZWxvYWQgb2YgdGhlIHNhbWUgc3RhdGUuIEl0IGRpZmZlcnMgZnJvbSByZWxvYWRPblNlYXJjaCBiZWNhdXNlIHlvdSdkXG5cdCAgICAgKiAgICB1c2UgdGhpcyB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIGEgcmVsb2FkIHdoZW4gKmV2ZXJ5dGhpbmcqIGlzIHRoZSBzYW1lLCBpbmNsdWRpbmcgc2VhcmNoIHBhcmFtcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLiBTZWVcblx0ICAgICAqIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfZ28gJHN0YXRlLmdvfS5cblx0ICAgICAqL1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiAodG8sIHRvUGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAodG9QYXJhbXMgPT09IHZvaWQgMCkgeyB0b1BhcmFtcyA9IHt9OyB9XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB2YXIgdHJhbnNIaXN0b3J5ID0gdGhpcy5nbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5O1xuXHQgICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB0cmFuc2l0aW9uU2VydmljZV8xLmRlZmF1bHRUcmFuc09wdHMpO1xuXHQgICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5leHRlbmQob3B0aW9ucywgeyBjdXJyZW50OiB0cmFuc0hpc3RvcnkucGVla1RhaWwuYmluZCh0cmFuc0hpc3RvcnkpIH0pO1xuXHQgICAgICAgIHZhciByZWYgPSB0aGlzLnRhcmdldCh0bywgdG9QYXJhbXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIHZhciBsYXRlc3RTdWNjZXNzID0gdGhpcy5nbG9iYWxzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5wZWVrVGFpbCgpO1xuXHQgICAgICAgIHZhciByb290UGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhdGhGYWN0b3J5XzEuUGF0aEZhY3RvcnkuYmluZFRyYW5zTm9kZXNUb1BhdGgoW25ldyBub2RlXzEuTm9kZShfdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSldKTsgfTtcblx0ICAgICAgICB2YXIgY3VycmVudFBhdGggPSBsYXRlc3RTdWNjZXNzID8gbGF0ZXN0U3VjY2Vzcy50cmVlQ2hhbmdlcygpLnRvIDogcm9vdFBhdGgoKTtcblx0ICAgICAgICBpZiAoIXJlZi5leGlzdHMoKSlcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZShjdXJyZW50UGF0aCwgcmVmKTtcblx0ICAgICAgICBpZiAoIXJlZi52YWxpZCgpKVxuXHQgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KHJlZi5lcnJvcigpKTtcblx0ICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuJHRyYW5zaXRpb25zLmNyZWF0ZShjdXJyZW50UGF0aCwgcmVmKTtcblx0ICAgICAgICB2YXIgdE1nciA9IG5ldyB0cmFuc2l0aW9uTWFuYWdlcl8xLlRyYW5zaXRpb25NYW5hZ2VyKHRyYW5zaXRpb24sIHRoaXMuJHRyYW5zaXRpb25zLCB0aGlzLiR1cmxSb3V0ZXIsIHRoaXMuJHZpZXcsIHRoaXMsIHRoaXMuZ2xvYmFscyk7XG5cdCAgICAgICAgdmFyIHRyYW5zaXRpb25Qcm9taXNlID0gdE1nci5ydW5UcmFuc2l0aW9uKCk7XG5cdCAgICAgICAgLy8gUmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHRyYW5zaXRpb24sIHdoaWNoIGFsc28gaGFzIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBvbiBpdC5cblx0ICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRyYW5zaXRpb25Qcm9taXNlLCB7IHRyYW5zaXRpb246IHRyYW5zaXRpb24gfSk7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjaXNcblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBTaW1pbGFyIHRvIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI21ldGhvZHNfaW5jbHVkZXMgJHN0YXRlLmluY2x1ZGVzfSxcblx0ICAgICAqIGJ1dCBvbmx5IGNoZWNrcyBmb3IgdGhlIGZ1bGwgc3RhdGUgbmFtZS4gSWYgcGFyYW1zIGlzIHN1cHBsaWVkIHRoZW4gaXQgd2lsbCBiZVxuXHQgICAgICogdGVzdGVkIGZvciBzdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgcGFyYW1zIG9iamVjdCwgc28gYWxsIHBhcmFtc1xuXHQgICAgICogbXVzdCBtYXRjaCB3aXRoIG5vbmUgbWlzc2luZyBhbmQgbm8gZXh0cmFzLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtJztcblx0ICAgICAqXG5cdCAgICAgKiAvLyBhYnNvbHV0ZSBuYW1lXG5cdCAgICAgKiAkc3RhdGUuaXMoJ2NvbnRhY3QuZGV0YWlscy5pdGVtJyk7IC8vIHJldHVybnMgdHJ1ZVxuXHQgICAgICogJHN0YXRlLmlzKGNvbnRhY3REZXRhaWxJdGVtU3RhdGVPYmplY3QpOyAvLyByZXR1cm5zIHRydWVcblx0ICAgICAqXG5cdCAgICAgKiAvLyByZWxhdGl2ZSBuYW1lICguIGFuZCBeKSwgdHlwaWNhbGx5IGZyb20gYSB0ZW1wbGF0ZVxuXHQgICAgICogLy8gRS5nLiBmcm9tIHRoZSAnY29udGFjdHMuZGV0YWlscycgdGVtcGxhdGVcblx0ICAgICAqIDxkaXYgbmctY2xhc3M9XCJ7aGlnaGxpZ2h0ZWQ6ICRzdGF0ZS5pcygnLml0ZW0nKX1cIj5JdGVtPC9kaXY+XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gY2hlY2suXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdD19IHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLCB0aGF0IHlvdSdkIGxpa2Vcblx0ICAgICAqIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBhcmU6XG5cdCAgICAgKlxuXHQgICAgICogLSAqKmByZWxhdGl2ZWAqKiAtIHtzdHJpbmd8b2JqZWN0fSAtICBJZiBgc3RhdGVPck5hbWVgIGlzIGEgcmVsYXRpdmUgc3RhdGUgbmFtZSBhbmQgYG9wdGlvbnMucmVsYXRpdmVgIGlzIHNldCwgLmlzIHdpbGxcblx0ICAgICAqIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGl0IGlzIHRoZSBzdGF0ZS5cblx0ICAgICAqL1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHsgcmVsYXRpdmU6IHRoaXMuJGN1cnJlbnQgfSk7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcblx0ICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICBpZiAodGhpcy4kY3VycmVudCAhPT0gc3RhdGUpXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChwYXJhbXMpICYmIHBhcmFtcyAhPT0gbnVsbCA/IHBhcmFtXzEuUGFyYW0uZXF1YWxzKHN0YXRlLnBhcmFtZXRlcnMoKSwgdGhpcy5wYXJhbXMsIHBhcmFtcykgOiB0cnVlO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlI2luY2x1ZGVzXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG5cdCAgICAgKiBzdGF0ZSBzdGF0ZU5hbWUuIElmIGFueSBwYXJhbXMgYXJlIHBhc3NlZCB0aGVuIHRoZXkgd2lsbCBiZSB0ZXN0ZWQgZm9yIGEgbWF0Y2ggYXMgd2VsbC5cblx0ICAgICAqIE5vdCBhbGwgdGhlIHBhcmFtZXRlcnMgbmVlZCB0byBiZSBwYXNzZWQsIGp1c3QgdGhlIG9uZXMgeW91J2QgbGlrZSB0byB0ZXN0IGZvciBlcXVhbGl0eS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogUGFydGlhbCBhbmQgcmVsYXRpdmUgbmFtZXNcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiAkc3RhdGUuJGN1cnJlbnQubmFtZSA9ICdjb250YWN0cy5kZXRhaWxzLml0ZW0nO1xuXHQgICAgICpcblx0ICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcblx0ICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzXCIpOyAvLyByZXR1cm5zIHRydWVcblx0ICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmRldGFpbHNcIik7IC8vIHJldHVybnMgdHJ1ZVxuXHQgICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcblx0ICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImNvbnRhY3RzLmxpc3RcIik7IC8vIHJldHVybnMgZmFsc2Vcblx0ICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcImFib3V0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogLy8gVXNpbmcgcmVsYXRpdmUgbmFtZXMgKC4gYW5kIF4pLCB0eXBpY2FsbHkgZnJvbSBhIHRlbXBsYXRlXG5cdCAgICAgKiAvLyBFLmcuIGZyb20gdGhlICdjb250YWN0cy5kZXRhaWxzJyB0ZW1wbGF0ZVxuXHQgICAgICogPGRpdiBuZy1jbGFzcz1cIntoaWdobGlnaHRlZDogJHN0YXRlLmluY2x1ZGVzKCcuaXRlbScpfVwiPkl0ZW08L2Rpdj5cblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEJhc2ljIGdsb2JiaW5nIHBhdHRlcm5zXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogJHN0YXRlLiRjdXJyZW50Lm5hbWUgPSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCc7XG5cdCAgICAgKlxuXHQgICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLiouKlwiKTsgLy8gcmV0dXJucyB0cnVlXG5cdCAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuKipcIik7IC8vIHJldHVybnMgdHJ1ZVxuXHQgICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKiouaXRlbS4qKlwiKTsgLy8gcmV0dXJucyB0cnVlXG5cdCAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuaXRlbS51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxuXHQgICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioudXJsXCIpOyAvLyByZXR1cm5zIHRydWVcblx0ICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qXCIpOyAvLyByZXR1cm5zIGZhbHNlXG5cdCAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJpdGVtLioqXCIpOyAvLyByZXR1cm5zIGZhbHNlXG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVPck5hbWUgQSBwYXJ0aWFsIG5hbWUsIHJlbGF0aXZlIG5hbWUsIG9yIGdsb2IgcGF0dGVyblxuXHQgICAgICogdG8gYmUgc2VhcmNoZWQgZm9yIHdpdGhpbiB0aGUgY3VycmVudCBzdGF0ZSBuYW1lLlxuXHQgICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQSBwYXJhbSBvYmplY3QsIGUuZy4gYHtzZWN0aW9uSWQ6IHNlY3Rpb24uaWR9YCxcblx0ICAgICAqIHRoYXQgeW91J2QgbGlrZSB0byB0ZXN0IGFnYWluc3QgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlLlxuXHQgICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiAgVGhlIG9wdGlvbnMgYXJlOlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgcmVsYXRpdmVgKiogLSB7c3RyaW5nfG9iamVjdD19IC0gIElmIGBzdGF0ZU9yTmFtZWAgaXMgYSByZWxhdGl2ZSBzdGF0ZSByZWZlcmVuY2UgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsXG5cdCAgICAgKiAuaW5jbHVkZXMgd2lsbCB0ZXN0IHJlbGF0aXZlIHRvIGBvcHRpb25zLnJlbGF0aXZlYCBzdGF0ZSAob3IgbmFtZSkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBpdCBkb2VzIGluY2x1ZGUgdGhlIHN0YXRlXG5cdCAgICAgKi9cblx0ICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCB7IHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50IH0pO1xuXHQgICAgICAgIHZhciBnbG9iID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlT3JOYW1lKSAmJiBnbG9iXzEuR2xvYi5mcm9tU3RyaW5nKHN0YXRlT3JOYW1lKTtcblx0ICAgICAgICBpZiAoZ2xvYikge1xuXHQgICAgICAgICAgICBpZiAoIWdsb2IubWF0Y2hlcyh0aGlzLiRjdXJyZW50Lm5hbWUpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBzdGF0ZU9yTmFtZSA9IHRoaXMuJGN1cnJlbnQubmFtZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSksIGluY2x1ZGUgPSB0aGlzLiRjdXJyZW50LmluY2x1ZGVzO1xuXHQgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG5cdCAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGluY2x1ZGVbc3RhdGUubmFtZV0pKVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgLy8gQFRPRE8gUmVwbGFjZSB3aXRoIFBhcmFtLmVxdWFscygpID9cblx0ICAgICAgICByZXR1cm4gcGFyYW1zID8gY29tbW9uXzIuZXF1YWxGb3JLZXlzKHBhcmFtXzEuUGFyYW0udmFsdWVzKHN0YXRlLnBhcmFtZXRlcnMoKSwgcGFyYW1zKSwgdGhpcy5wYXJhbXMsIE9iamVjdC5rZXlzKHBhcmFtcykpIDogdHJ1ZTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNocmVmXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogQSB1cmwgZ2VuZXJhdGlvbiBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjb21waWxlZCB1cmwgZm9yIHRoZSBnaXZlbiBzdGF0ZSBwb3B1bGF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogZXhwZWN0KCRzdGF0ZS5ocmVmKFwiYWJvdXQucGVyc29uXCIsIHsgcGVyc29uOiBcImJvYlwiIH0pKS50b0VxdWFsKFwiL2Fib3V0L2JvYlwiKTtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIHN0YXRlJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuXHQgICAgICpcblx0ICAgICAqIC0gKipgbG9zc3lgKiogLSB7Ym9vbGVhbj10cnVlfSAtICBJZiB0cnVlLCBhbmQgaWYgdGhlcmUgaXMgbm8gdXJsIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3RhdGUgcHJvdmlkZWQgaW4gdGhlXG5cdCAgICAgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIHRoZW4gdGhlIGNvbnN0cnVjdGVkIGhyZWYgdXJsIHdpbGwgYmUgYnVpbHQgZnJvbSB0aGUgZmlyc3QgbmF2aWdhYmxlIGFuY2VzdG9yIChha2Fcblx0ICAgICAqICAgIGFuY2VzdG9yIHdpdGggYSB2YWxpZCB1cmwpLlxuXHQgICAgICogLSAqKmBpbmhlcml0YCoqIC0ge2Jvb2xlYW49dHJ1ZX0sIElmIGB0cnVlYCB3aWxsIGluaGVyaXQgdXJsIHBhcmFtZXRlcnMgZnJvbSBjdXJyZW50IHVybC5cblx0ICAgICAqIC0gKipgcmVsYXRpdmVgKiogLSB7b2JqZWN0PSRzdGF0ZS4kY3VycmVudH0sIFdoZW4gdHJhbnNpdGlvbmluZyB3aXRoIHJlbGF0aXZlIHBhdGggKGUuZyAnXicpLFxuXHQgICAgICogICAgZGVmaW5lcyB3aGljaCBzdGF0ZSB0byBiZSByZWxhdGl2ZSBmcm9tLlxuXHQgICAgICogLSAqKmBhYnNvbHV0ZWAqKiAtIHtib29sZWFuPWZhbHNlfSwgIElmIHRydWUgd2lsbCBnZW5lcmF0ZSBhbiBhYnNvbHV0ZSB1cmwsIGUuZy4gXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL2Z1bGx1cmxcIi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjb21waWxlZCBzdGF0ZSB1cmxcblx0ICAgICAqL1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgZGVmYXVsdEhyZWZPcHRzID0ge1xuXHQgICAgICAgICAgICBsb3NzeTogdHJ1ZSxcblx0ICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcblx0ICAgICAgICAgICAgYWJzb2x1dGU6IGZhbHNlLFxuXHQgICAgICAgICAgICByZWxhdGl2ZTogdGhpcy4kY3VycmVudFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRIcmVmT3B0cyk7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHN0YXRlKSlcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdClcblx0ICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXMuJGluaGVyaXQocGFyYW1zIHx8IHt9LCB0aGlzLiRjdXJyZW50LCBzdGF0ZSk7XG5cdCAgICAgICAgdmFyIG5hdiA9IChzdGF0ZSAmJiBvcHRpb25zLmxvc3N5KSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xuXHQgICAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy4kdXJsUm91dGVyLmhyZWYobmF2LnVybCwgcGFyYW1fMS5QYXJhbS52YWx1ZXMoc3RhdGUucGFyYW1ldGVycygpLCBwYXJhbXMpLCB7XG5cdCAgICAgICAgICAgIGFic29sdXRlOiBvcHRpb25zLmFic29sdXRlXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVSZWdpc3RyeS5nZXQoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVJlZ2lzdHJ5LmdldChzdGF0ZU9yTmFtZSwgYmFzZSB8fCB0aGlzLiRjdXJyZW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU3RhdGVTZXJ2aWNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRlU2VydmljZSA9IFN0YXRlU2VydmljZTtcblxuXG4vKioqLyB9LFxuLyogMzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgbW9kdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIG5vZGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHR2YXIgbW9kdWxlXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0LyoqXG5cdCAqIFRoaXMgY2xhc3MgY29udGFpbnMgZnVuY3Rpb25zIHdoaWNoIGNvbnZlcnQgVGFyZ2V0U3RhdGVzLCBOb2RlcyBhbmQgcGF0aHMgZnJvbSBvbmUgdHlwZSB0byBhbm90aGVyLlxuXHQgKi9cblx0dmFyIFBhdGhGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFBhdGhGYWN0b3J5KCkge1xuXHQgICAgfVxuXHQgICAgLyoqIEdpdmVuIGEgTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cblx0ICAgIFBhdGhGYWN0b3J5Lm1ha2VUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gY29tbW9uXzEudGFpbChwYXRoKS5zdGF0ZTtcblx0ICAgICAgICByZXR1cm4gbmV3IG1vZHVsZV8xLlRhcmdldFN0YXRlKHN0YXRlLCBzdGF0ZSwgcGF0aC5tYXAoaG9mXzEucHJvcChcInBhcmFtVmFsdWVzXCIpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpO1xuXHQgICAgfTtcblx0ICAgIFBhdGhGYWN0b3J5LmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuXHQgICAgICAgIHZhciB0b1BhcmFtcyA9IHRhcmdldFN0YXRlLnBhcmFtcygpO1xuXHQgICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZS4kc3RhdGUoKS5wYXRoLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIG5ldyBub2RlXzEuTm9kZShzdGF0ZSkuYXBwbHlSYXdQYXJhbXModG9QYXJhbXMpOyB9KTtcblx0ICAgIH07XG5cdCAgICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogTm9kZVtdIGFuZCBhIFRhcmdldFN0YXRlLCBidWlsZHMgYSB0b1BhdGg6IE5vZGVbXSAqL1xuXHQgICAgUGF0aEZhY3RvcnkuYnVpbGRUb1BhdGggPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRhcmdldFN0YXRlKSB7XG5cdCAgICAgICAgdmFyIHRvUGF0aCA9IFBhdGhGYWN0b3J5LmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG5cdCAgICAgICAgaWYgKHRhcmdldFN0YXRlLm9wdGlvbnMoKS5pbmhlcml0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQYXRoRmFjdG9yeS5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b1BhdGg7XG5cdCAgICB9O1xuXHQgICAgUGF0aEZhY3RvcnkuYXBwbHlWaWV3Q29uZmlncyA9IGZ1bmN0aW9uICgkdmlldywgcGF0aCkge1xuXHQgICAgICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG5vZGUsIHsgdmlld3M6IGNvbW1vbl8xLnZhbHVlcyhub2RlLnN0YXRlLnZpZXdzIHx8IHt9KS5tYXAoZnVuY3Rpb24gKHZpZXcpIHsgcmV0dXJuICR2aWV3LmNyZWF0ZVZpZXdDb25maWcobm9kZSwgdmlldyk7IH0pIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogR2l2ZW4gYSBmcm9tUGF0aCBhbmQgYSB0b1BhdGgsIHJldHVybnMgYSBuZXcgdG8gcGF0aCB3aGljaCBpbmhlcml0cyBwYXJhbWV0ZXJzIGZyb20gdGhlIGZyb21QYXRoXG5cdCAgICAgKlxuXHQgICAgICogRm9yIGEgcGFyYW1ldGVyIGluIGEgbm9kZSB0byBiZSBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbSBwYXRoOlxuXHQgICAgICogLSBUaGUgdG9QYXRoJ3Mgbm9kZSBtdXN0IGhhdmUgYSBtYXRjaGluZyBub2RlIGluIHRoZSBmcm9tUGF0aCAoYnkgc3RhdGUpLlxuXHQgICAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG5cdCAgICAgKlxuXHQgICAgICogTm90ZTogdGhlIGtleXMgcHJvdmlkZWQgaW4gdG9LZXlzIGFyZSBpbnRlbmRlZCB0byBiZSB0aG9zZSBwYXJhbSBrZXlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHNvbWVcblx0ICAgICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuXHQgICAgICogaXQgaXMgbm90IGluaGVyaXRlZCBmcm9tIHRoZSBmcm9tUGF0aC5cblx0ICAgICAqL1xuXHQgICAgUGF0aEZhY3RvcnkuaW5oZXJpdFBhcmFtcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCB0b0tleXMpIHtcblx0ICAgICAgICBpZiAodG9LZXlzID09PSB2b2lkIDApIHsgdG9LZXlzID0gW107IH1cblx0ICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZChwYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgbm9kZSAmJiBub2RlLnBhcmFtVmFsdWVzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogR2l2ZW4gYW4gTm9kZSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgTm9kZSB3aXRoIHBhcmFtIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSB0aGVcblx0ICAgICAgICAgKiBtYXRjaGluZyBub2RlIGluIGZyb21QYXRoLiAgT25seSBpbmhlcml0IGtleXMgdGhhdCBhcmVuJ3QgZm91bmQgaW4gXCJ0b0tleXNcIiBmcm9tIHRoZSBub2RlIGluIFwiZnJvbVBhdGhcIlwiXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlID0gaG9mXzEuY3VycnkoZnVuY3Rpb24gKF9mcm9tUGF0aCwgX3RvS2V5cywgdG9Ob2RlKSB7XG5cdCAgICAgICAgICAgIC8vIEFsbCBwYXJhbSB2YWx1ZXMgZm9yIHRoZSBub2RlIChtYXkgaW5jbHVkZSBkZWZhdWx0IGtleS92YWxzLCB3aGVuIGtleSB3YXMgbm90IGZvdW5kIGluIHRvUGFyYW1zKVxuXHQgICAgICAgICAgICB2YXIgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5leHRlbmQoe30sIHRvTm9kZSAmJiB0b05vZGUucGFyYW1WYWx1ZXMpO1xuXHQgICAgICAgICAgICAvLyBsaW1pdGVkIHRvIG9ubHkgdGhvc2Uga2V5cyBmb3VuZCBpbiB0b1BhcmFtc1xuXHQgICAgICAgICAgICB2YXIgaW5jb21pbmdQYXJhbVZhbHMgPSBjb21tb25fMS5waWNrKHRvUGFyYW1WYWxzLCBfdG9LZXlzKTtcblx0ICAgICAgICAgICAgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KHRvUGFyYW1WYWxzLCBfdG9LZXlzKTtcblx0ICAgICAgICAgICAgdmFyIGZyb21QYXJhbVZhbHMgPSBub2RlUGFyYW1WYWxzKF9mcm9tUGF0aCwgdG9Ob2RlLnN0YXRlKSB8fCB7fTtcblx0ICAgICAgICAgICAgLy8gZXh0ZW5kIHRvUGFyYW1WYWxzIHdpdGggYW55IGZyb21QYXJhbVZhbHMsIHRoZW4gb3ZlcnJpZGUgYW55IG9mIHRob3NlIHRob3NlIHdpdGggaW5jb21pbmdQYXJhbVZhbHNcblx0ICAgICAgICAgICAgdmFyIG93blBhcmFtVmFscyA9IGNvbW1vbl8xLmV4dGVuZCh0b1BhcmFtVmFscywgZnJvbVBhcmFtVmFscywgaW5jb21pbmdQYXJhbVZhbHMpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IG5vZGVfMS5Ob2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBUaGUgcGFyYW0ga2V5cyBzcGVjaWZpZWQgYnkgdGhlIGluY29taW5nIHRvUGFyYW1zXG5cdCAgICAgICAgcmV0dXJuIHRvUGF0aC5tYXAobWFrZUluaGVyaXRlZFBhcmFtc05vZGUoZnJvbVBhdGgsIHRvS2V5cykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogR2l2ZW4gYSBwYXRoLCB1cGdyYWRlcyB0aGUgcGF0aCB0byBhIE5vZGVbXS4gIEVhY2ggbm9kZSBpcyBhc3NpZ25lZCBhIFJlc29sdmVDb250ZXh0XG5cdCAgICAgKiBhbmQgUGFyYW1WYWx1ZXMgb2JqZWN0IHdoaWNoIGlzIGJvdW5kIHRvIHRoZSB3aG9sZSBwYXRoLCBidXQgY2xvc2VzIG92ZXIgdGhlIHN1YnBhdGggZnJvbSByb290IHRvIHRoZSBub2RlLlxuXHQgICAgICogVGhlIHZpZXdzIGFyZSBhbHNvIGFkZGVkIHRvIHRoZSBub2RlLlxuXHQgICAgICovXG5cdCAgICBQYXRoRmFjdG9yeS5iaW5kVHJhbnNOb2Rlc1RvUGF0aCA9IGZ1bmN0aW9uIChyZXNvbHZlUGF0aCkge1xuXHQgICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyBtb2R1bGVfMi5SZXNvbHZlQ29udGV4dChyZXNvbHZlUGF0aCk7XG5cdCAgICAgICAgLy8gbGV0IHBhcmFtVmFsdWVzID0gbmV3IFBhcmFtVmFsdWVzKHJlc29sdmVQYXRoKTtcblx0ICAgICAgICAvLyBBdHRhY2ggYm91bmQgcmVzb2x2ZUNvbnRleHQgYW5kIHBhcmFtVmFsdWVzIHRvIGVhY2ggbm9kZVxuXHQgICAgICAgIC8vIEF0dGFjaCB2aWV3cyB0byBlYWNoIG5vZGVcblx0ICAgICAgICByZXNvbHZlUGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgIG5vZGUucmVzb2x2ZUNvbnRleHQgPSByZXNvbHZlQ29udGV4dC5pc29sYXRlUm9vdFRvKG5vZGUuc3RhdGUpO1xuXHQgICAgICAgICAgICBub2RlLnJlc29sdmVJbmplY3RvciA9IG5ldyBtb2R1bGVfMi5SZXNvbHZlSW5qZWN0b3Iobm9kZS5yZXNvbHZlQ29udGV4dCwgbm9kZS5zdGF0ZSk7XG5cdCAgICAgICAgICAgIG5vZGUucmVzb2x2ZXNbJyRzdGF0ZVBhcmFtcyddID0gbmV3IG1vZHVsZV8yLlJlc29sdmFibGUoXCIkc3RhdGVQYXJhbXNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZS5wYXJhbVZhbHVlczsgfSwgbm9kZS5wYXJhbVZhbHVlcyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHJlc29sdmVQYXRoO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQ29tcHV0ZXMgdGhlIHRyZWUgY2hhbmdlcyAoZW50ZXJpbmcsIGV4aXRpbmcpIGJldHdlZW4gYSBmcm9tUGF0aCBhbmQgdG9QYXRoLlxuXHQgICAgICovXG5cdCAgICBQYXRoRmFjdG9yeS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdG9QYXRoLCByZWxvYWRTdGF0ZSkge1xuXHQgICAgICAgIHZhciBrZWVwID0gMCwgbWF4ID0gTWF0aC5taW4oZnJvbVBhdGgubGVuZ3RoLCB0b1BhdGgubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgc3RhdGljUGFyYW1zID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSkuZmlsdGVyKGhvZl8xLm5vdChob2ZfMS5wcm9wKCdkeW5hbWljJykpKS5tYXAoaG9mXzEucHJvcCgnaWQnKSk7IH07XG5cdCAgICAgICAgdmFyIG5vZGVzTWF0Y2ggPSBmdW5jdGlvbiAobm9kZTEsIG5vZGUyKSB7IHJldHVybiBub2RlMS5lcXVhbHMobm9kZTIsIHN0YXRpY1BhcmFtcyhub2RlMS5zdGF0ZSkpOyB9O1xuXHQgICAgICAgIHdoaWxlIChrZWVwIDwgbWF4ICYmIGZyb21QYXRoW2tlZXBdLnN0YXRlICE9PSByZWxvYWRTdGF0ZSAmJiBub2Rlc01hdGNoKGZyb21QYXRoW2tlZXBdLCB0b1BhdGhba2VlcF0pKSB7XG5cdCAgICAgICAgICAgIGtlZXArKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqIEdpdmVuIGEgcmV0YWluZWQgbm9kZSwgcmV0dXJuIGEgbmV3IG5vZGUgd2hpY2ggdXNlcyB0aGUgdG8gbm9kZSdzIHBhcmFtIHZhbHVlcyAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIGFwcGx5VG9QYXJhbXMocmV0YWluZWROb2RlLCBpZHgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lZCA9IG5vZGVfMS5Ob2RlLmNsb25lKHJldGFpbmVkTm9kZSk7XG5cdCAgICAgICAgICAgIGNsb25lZC5wYXJhbVZhbHVlcyA9IHRvUGF0aFtpZHhdLnBhcmFtVmFsdWVzO1xuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZnJvbSwgcmV0YWluZWQsIGV4aXRpbmcsIGVudGVyaW5nLCB0bztcblx0ICAgICAgICAvLyBpbnRlcm1lZGlhdGUgdmFyc1xuXHQgICAgICAgIHZhciByZXRhaW5lZFdpdGhUb1BhcmFtcywgZW50ZXJpbmdSZXNvbHZlUGF0aCwgdG9SZXNvbHZlUGF0aDtcblx0ICAgICAgICBmcm9tID0gZnJvbVBhdGg7XG5cdCAgICAgICAgcmV0YWluZWQgPSBmcm9tLnNsaWNlKDAsIGtlZXApO1xuXHQgICAgICAgIGV4aXRpbmcgPSBmcm9tLnNsaWNlKGtlZXApO1xuXHQgICAgICAgIC8vIENyZWF0ZSBhIG5ldyByZXRhaW5lZCBwYXRoICh3aXRoIHNoYWxsb3cgY29waWVzIG9mIG5vZGVzKSB3aGljaCBoYXZlIHRoZSBwYXJhbXMgb2YgdGhlIHRvUGF0aCBtYXBwZWRcblx0ICAgICAgICByZXRhaW5lZFdpdGhUb1BhcmFtcyA9IHJldGFpbmVkLm1hcChhcHBseVRvUGFyYW1zKTtcblx0ICAgICAgICBlbnRlcmluZ1Jlc29sdmVQYXRoID0gdG9QYXRoLnNsaWNlKGtlZXApO1xuXHQgICAgICAgIC8vIFwidG9SZXNvbHZlUGF0aFwiIGlzIFwicmV0YWluZWRXaXRoVG9QYXJhbXNcIiBjb25jYXQgXCJlbnRlcmluZ1Jlc29sdmVQYXRoXCIuXG5cdCAgICAgICAgdG9SZXNvbHZlUGF0aCA9IChyZXRhaW5lZFdpdGhUb1BhcmFtcykuY29uY2F0KGVudGVyaW5nUmVzb2x2ZVBhdGgpO1xuXHQgICAgICAgIC8vIFwidG86IGlzIFwidG9SZXNvbHZlUGF0aFwiIHdpdGggUGFyYW1WYWx1ZXMvUmVzb2x2ZUNvbnRleHQgYWRkZWQgdG8gZWFjaCBub2RlIGFuZCBib3VuZCB0byB0aGUgcGF0aCBjb250ZXh0XG5cdCAgICAgICAgdG8gPSBQYXRoRmFjdG9yeS5iaW5kVHJhbnNOb2Rlc1RvUGF0aCh0b1Jlc29sdmVQYXRoKTtcblx0ICAgICAgICAvLyBcImVudGVyaW5nXCIgaXMgdGhlIHRhaWwgb2YgXCJ0b1wiXG5cdCAgICAgICAgZW50ZXJpbmcgPSB0by5zbGljZShrZWVwKTtcblx0ICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tLCB0bzogdG8sIHJldGFpbmVkOiByZXRhaW5lZCwgZXhpdGluZzogZXhpdGluZywgZW50ZXJpbmc6IGVudGVyaW5nIH07XG5cdCAgICB9O1xuXHQgICAgUGF0aEZhY3RvcnkuYmluZFRyYW5zaXRpb25SZXNvbHZlID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzLCB0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgdmFyIHJvb3ROb2RlID0gdHJlZUNoYW5nZXMudG9bMF07XG5cdCAgICAgICAgcm9vdE5vZGUucmVzb2x2ZXNbJyR0cmFuc2l0aW9uJCddID0gbmV3IG1vZHVsZV8yLlJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zaXRpb247IH0sIHRyYW5zaXRpb24pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogRmluZCBhIHN1YnBhdGggb2YgYSBwYXRoIHRoYXQgc3RvcHMgYXQgdGhlIG5vZGUgZm9yIGEgZ2l2ZW4gc3RhdGVcblx0ICAgICAqXG5cdCAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgbm9kZSwgdXAgdG8gdGhlXG5cdCAgICAgKiBub2RlIHdob3NlIHN0YXRlIG1hdGNoZXMgYHN0YXRlTmFtZWBcblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggb2YgW1tOb2RlXV1zXG5cdCAgICAgKiBAcGFyYW0gc3RhdGUgdGhlIFtbU3RhdGVdXSB0byBzdG9wIGF0XG5cdCAgICAgKi9cblx0ICAgIFBhdGhGYWN0b3J5LnN1YlBhdGggPSBmdW5jdGlvbiAocGF0aCwgc3RhdGUpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgZnVuY3Rpb24gKF9ub2RlKSB7IHJldHVybiBfbm9kZS5zdGF0ZSA9PT0gc3RhdGU7IH0pO1xuXHQgICAgICAgIHZhciBlbGVtZW50SWR4ID0gcGF0aC5pbmRleE9mKG5vZGUpO1xuXHQgICAgICAgIGlmIChlbGVtZW50SWR4ID09PSAtMSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhdGggZG9lcyBub3QgY29udGFpbiB0aGUgc3RhdGU6IFwiICsgc3RhdGUpO1xuXHQgICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVsZW1lbnRJZHggKyAxKTtcblx0ICAgIH07XG5cdCAgICAvKiogR2V0cyB0aGUgcmF3IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSBhIHBhdGggKi9cblx0ICAgIFBhdGhGYWN0b3J5LnBhcmFtVmFsdWVzID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChhY2MsIG5vZGUucGFyYW1WYWx1ZXMpOyB9LCB7fSk7IH07XG5cdCAgICByZXR1cm4gUGF0aEZhY3Rvcnk7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUGF0aEZhY3RvcnkgPSBQYXRoRmFjdG9yeTtcblxuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgbW9kdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0dmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gTm9kZShzdGF0ZSkge1xuXHQgICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIE5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vZGUuc3RhdGU7XG5cdCAgICAgICAgICAgIHRoaXMucGFyYW1TY2hlbWEgPSBub2RlLnBhcmFtU2NoZW1hLnNsaWNlKCk7XG5cdCAgICAgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSBjb21tb25fMS5leHRlbmQoe30sIG5vZGUucGFyYW1WYWx1ZXMpO1xuXHQgICAgICAgICAgICB0aGlzLnJlc29sdmVzID0gY29tbW9uXzEuZXh0ZW5kKHt9LCBub2RlLnJlc29sdmVzKTtcblx0ICAgICAgICAgICAgdGhpcy52aWV3cyA9IG5vZGUudmlld3MgJiYgbm9kZS52aWV3cy5zbGljZSgpO1xuXHQgICAgICAgICAgICB0aGlzLnJlc29sdmVDb250ZXh0ID0gbm9kZS5yZXNvbHZlQ29udGV4dDtcblx0ICAgICAgICAgICAgdGhpcy5yZXNvbHZlSW5qZWN0b3IgPSBub2RlLnJlc29sdmVJbmplY3Rvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblx0ICAgICAgICAgICAgdGhpcy5wYXJhbVNjaGVtYSA9IHN0YXRlLnBhcmFtZXRlcnMoeyBpbmhlcml0OiBmYWxzZSB9KTtcblx0ICAgICAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHt9O1xuXHQgICAgICAgICAgICB0aGlzLnJlc29sdmVzID0gY29tbW9uXzEubWFwT2JqKHN0YXRlLnJlc29sdmUsIGZ1bmN0aW9uIChmbiwgbmFtZSkgeyByZXR1cm4gbmV3IG1vZHVsZV8xLlJlc29sdmFibGUobmFtZSwgZm4pOyB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBOb2RlLnByb3RvdHlwZS5hcHBseVJhd1BhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0ICAgICAgICB2YXIgZ2V0UGFyYW1WYWwgPSBmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIFtwYXJhbURlZi5pZCwgcGFyYW1EZWYudmFsdWUocGFyYW1zW3BhcmFtRGVmLmlkXSldOyB9O1xuXHQgICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB0aGlzLnBhcmFtU2NoZW1hLnJlZHVjZShmdW5jdGlvbiAobWVtbywgcERlZikgeyByZXR1cm4gY29tbW9uXzEuYXBwbHlQYWlycyhtZW1vLCBnZXRQYXJhbVZhbChwRGVmKSk7IH0sIHt9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBOb2RlLnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMS5maW5kKHRoaXMucGFyYW1TY2hlbWEsIGhvZl8xLnByb3BFcShcImlkXCIsIG5hbWUpKTtcblx0ICAgIH07XG5cdCAgICBOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobm9kZSwga2V5cykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkgeyBrZXlzID0gdGhpcy5wYXJhbVNjaGVtYS5tYXAoaG9mXzEucHJvcCgnaWQnKSk7IH1cblx0ICAgICAgICB2YXIgcGFyYW1WYWxzRXEgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfdGhpcy5wYXJhbWV0ZXIoa2V5KS50eXBlLmVxdWFscyhfdGhpcy5wYXJhbVZhbHVlc1trZXldLCBub2RlLnBhcmFtVmFsdWVzW2tleV0pOyB9O1xuXHQgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBub2RlLnN0YXRlICYmIGtleXMubWFwKHBhcmFtVmFsc0VxKS5yZWR1Y2UoY29tbW9uXzEuYWxsVHJ1ZVIsIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIE5vZGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgTm9kZShub2RlKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYSBuZXcgcGF0aCB3aGljaCBpcyBhIHN1YnBhdGggb2YgdGhlIGZpcnN0IHBhdGguIFRoZSBuZXcgcGF0aCBzdGFydHMgZnJvbSByb290IGFuZCBjb250YWlucyBhbnkgbm9kZXNcblx0ICAgICAqIHRoYXQgbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aC4gTm9kZXMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZWlyIHN0YXRlIHByb3BlcnR5LlxuXHQgICAgICogQHBhcmFtIGZpcnN0IHtOb2RlW119XG5cdCAgICAgKiBAcGFyYW0gc2Vjb25kIHtOb2RlW119XG5cdCAgICAgKiBAcmV0dXJucyB7Tm9kZVtdfVxuXHQgICAgICovXG5cdCAgICBOb2RlLm1hdGNoaW5nID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcblx0ICAgICAgICB2YXIgbWF0Y2hlZENvdW50ID0gZmlyc3QucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBub2RlLCBpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcmV2ID09PSBpICYmIGkgPCBzZWNvbmQubGVuZ3RoICYmIG5vZGUuc3RhdGUgPT09IHNlY29uZFtpXS5zdGF0ZSA/IGkgKyAxIDogcHJldjtcblx0ICAgICAgICB9LCAwKTtcblx0ICAgICAgICByZXR1cm4gZmlyc3Quc2xpY2UoMCwgbWF0Y2hlZENvdW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTm9kZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5Ob2RlID0gTm9kZTtcblxuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRmdW5jdGlvbiBfX2V4cG9ydChtKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG5cdH1cblx0LyoqIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygzMSkpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oNDEpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MikpO1xuXG5cbi8qKiovIH0sXG4vKiA0MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHJlc29sdmUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBob2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgdHJhY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgaW50ZXJmYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblx0dmFyIGNvbW1vbl8yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHBhdGhGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblx0Ly8gVE9ETzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuXHR2YXIgZGVmYXVsdFJlc29sdmVQb2xpY3kgPSBpbnRlcmZhY2VfMS5SZXNvbHZlUG9saWN5W2ludGVyZmFjZV8xLlJlc29sdmVQb2xpY3kuTEFaWV07XG5cdHZhciBSZXNvbHZlQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXNvbHZlQ29udGV4dChfcGF0aCkge1xuXHQgICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcblx0ICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywge1xuXHQgICAgICAgICAgICBfbm9kZUZvcjogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZmluZCh0aGlzLl9wYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgX3BhdGhUbzogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGF0aEZhY3RvcnlfMS5QYXRoRmFjdG9yeS5zdWJQYXRoKHRoaXMuX3BhdGgsIHN0YXRlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBhdmFpbGFibGUgUmVzb2x2YWJsZXMgZm9yIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhpcyBwYXRoLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgU3RhdGUgKHdpdGhpbiB0aGUgUmVzb2x2ZUNvbnRleHQncyBQYXRoKSBmb3Igd2hpY2ggdG8gZ2V0IHJlc29sdmFibGVzXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9uc1xuXHQgICAgICpcblx0ICAgICAqIG9wdGlvbnMub21pdE93bkxvY2FsczogYXJyYXkgb2YgcHJvcGVydHkgbmFtZXNcblx0ICAgICAqICAgT21pdHMgdGhvc2UgUmVzb2x2YWJsZXMgd2hpY2ggYXJlIGZvdW5kIG9uIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHBhdGguXG5cdCAgICAgKlxuXHQgICAgICogICBUaGlzIHdpbGwgaGlkZSBhIGRlZXBlc3QtbGV2ZWwgcmVzb2x2YWJsZSAoYnkgbmFtZSksIHBvdGVudGlhbGx5IGV4cG9zaW5nIGEgcGFyZW50IHJlc29sdmFibGUgb2Zcblx0ICAgICAqICAgdGhlIHNhbWUgbmFtZSBmdXJ0aGVyIHVwIHRoZSBzdGF0ZSB0cmVlLlxuXHQgICAgICpcblx0ICAgICAqICAgVGhpcyBpcyB1c2VkIGJ5IFJlc29sdmFibGUucmVzb2x2ZSgpIGluIG9yZGVyIHRvIHByb3ZpZGUgdGhlIFJlc29sdmFibGUgYWNjZXNzIHRvIGFsbCB0aGUgb3RoZXJcblx0ICAgICAqICAgUmVzb2x2YWJsZXMgYXQgaXRzIG93biBQYXRoRWxlbWVudCBsZXZlbCwgeWV0IGRpc2FsbG93IHRoYXQgUmVzb2x2YWJsZSBhY2Nlc3MgdG8gaXRzIG93biBpbmplY3RhYmxlIFJlc29sdmFibGUuXG5cdCAgICAgKlxuXHQgICAgICogICBUaGlzIGlzIGFsc28gdXNlZCB0byBhbGxvdyBhIHN0YXRlIHRvIG92ZXJyaWRlIGEgcGFyZW50IHN0YXRlJ3MgcmVzb2x2ZSB3aGlsZSBhbHNvIGluamVjdGluZ1xuXHQgICAgICogICB0aGF0IHBhcmVudCBzdGF0ZSdzIHJlc29sdmU6XG5cdCAgICAgKlxuXHQgICAgICogICBzdGF0ZSh7IG5hbWU6ICdHJywgcmVzb2x2ZTogeyBfRzogZnVuY3Rpb24oKSB7IHJldHVybiBcIkdcIjsgfSB9IH0pO1xuXHQgICAgICogICBzdGF0ZSh7IG5hbWU6ICdHLkcyJywgcmVzb2x2ZTogeyBfRzogZnVuY3Rpb24oX0cpIHsgcmV0dXJuIF9HICsgXCJHMlwiOyB9IH0gfSk7XG5cdCAgICAgKiAgIHdoZXJlIGluamVjdGluZyBfRyBpbnRvIGEgY29udHJvbGxlciB3aWxsIHlpZWxkIFwiR0cyXCJcblx0ICAgICAqL1xuXHQgICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFJlc29sdmFibGVzID0gZnVuY3Rpb24gKHN0YXRlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHsgb21pdE93bkxvY2FsczogW10gfSk7XG5cdCAgICAgICAgdmFyIHBhdGggPSAoc3RhdGUgPyB0aGlzLl9wYXRoVG8oc3RhdGUpIDogdGhpcy5fcGF0aCk7XG5cdCAgICAgICAgdmFyIGxhc3QgPSBjb21tb25fMS50YWlsKHBhdGgpO1xuXHQgICAgICAgIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobWVtbywgbm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgb21pdFByb3BzID0gKG5vZGUgPT09IGxhc3QpID8gb3B0aW9ucy5vbWl0T3duTG9jYWxzIDogW107XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXJlZFJlc29sdmFibGVzID0gY29tbW9uXzEub21pdChub2RlLnJlc29sdmVzLCBvbWl0UHJvcHMpO1xuXHQgICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKG1lbW8sIGZpbHRlcmVkUmVzb2x2YWJsZXMpO1xuXHQgICAgICAgIH0sIHt9KTtcblx0ICAgIH07XG5cdCAgICAvKiogSW5zcGVjdHMgYSBmdW5jdGlvbiBgZm5gIGZvciBpdHMgZGVwZW5kZW5jaWVzLiAgUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbnkgbWF0Y2hpbmcgUmVzb2x2YWJsZXMgKi9cblx0ICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRSZXNvbHZhYmxlc0ZvckZuID0gZnVuY3Rpb24gKGZuKSB7XG5cdCAgICAgICAgdmFyIGRlcHMgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4sIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5zdHJpY3REaSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnBpY2sodGhpcy5nZXRSZXNvbHZhYmxlcygpLCBkZXBzKTtcblx0ICAgIH07XG5cdCAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuaXNvbGF0ZVJvb3RUbyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZUNvbnRleHQodGhpcy5fcGF0aFRvKHN0YXRlKSk7XG5cdCAgICB9O1xuXHQgICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmFkZFJlc29sdmFibGVzID0gZnVuY3Rpb24gKHJlc29sdmFibGVzLCBzdGF0ZSkge1xuXHQgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLl9ub2RlRm9yKHN0YXRlKS5yZXNvbHZlcywgcmVzb2x2YWJsZXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBHZXRzIHRoZSByZXNvbHZhYmxlcyBkZWNsYXJlZCBvbiBhIHBhcnRpY3VsYXIgc3RhdGUgKi9cblx0ICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRPd25SZXNvbHZhYmxlcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQoe30sIHRoaXMuX25vZGVGb3Ioc3RhdGUpLnJlc29sdmVzKTtcblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcGF0aCBFbGVtZW50IHByb21pc2VzXG5cdCAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUmVzb2x2ZVBhdGgodGhpcy5fcGF0aCwgb3B0aW9ucyk7XG5cdCAgICAgICAgdmFyIHByb21pc2VGb3JOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnJlc29sdmVQYXRoRWxlbWVudChub2RlLnN0YXRlLCBvcHRpb25zKTsgfTtcblx0ICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKGNvbW1vbl8xLm1hcCh0aGlzLl9wYXRoLCBwcm9taXNlRm9yTm9kZSkpLnRoZW4oZnVuY3Rpb24gKGFsbCkgeyByZXR1cm4gYWxsLnJlZHVjZShjb21tb25fMi5tZXJnZVIsIHt9KTsgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gcmV0dXJucyBhIHByb21pc2UgZm9yIGFsbCB0aGUgcmVzb2x2YWJsZXMgb24gdGhpcyBQYXRoRWxlbWVudFxuXHQgICAgLy8gb3B0aW9ucy5yZXNvbHZlUG9saWN5OiBvbmx5IHJldHVybiBwcm9taXNlcyBmb3IgdGhvc2UgUmVzb2x2YWJsZXMgd2hpY2ggYXJlIGF0IFxuXHQgICAgLy8gdGhlIHNwZWNpZmllZCBwb2xpY3ksIG9yIGFib3ZlLiAgaS5lLiwgb3B0aW9ucy5yZXNvbHZlUG9saWN5ID09PSAnbGF6eScgd2lsbFxuXHQgICAgLy8gcmVzb2x2ZSBib3RoICdsYXp5JyBhbmQgJ2VhZ2VyJyByZXNvbHZlcy5cblx0ICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUGF0aEVsZW1lbnQgPSBmdW5jdGlvbiAoc3RhdGUsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG5cdCAgICAgICAgLy8gVGhlIGNhbGxlciBjYW4gcmVxdWVzdCB0aGUgcGF0aCBiZSByZXNvbHZlZCBmb3IgYSBnaXZlbiBwb2xpY3kgYW5kIFwiYmVsb3dcIiBcblx0ICAgICAgICB2YXIgcG9saWN5ID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc29sdmVQb2xpY3k7XG5cdCAgICAgICAgdmFyIHBvbGljeU9yZGluYWwgPSBpbnRlcmZhY2VfMS5SZXNvbHZlUG9saWN5W3BvbGljeSB8fCBkZWZhdWx0UmVzb2x2ZVBvbGljeV07XG5cdCAgICAgICAgLy8gR2V0IHBhdGggUmVzb2x2YWJsZXMgYXZhaWxhYmxlIHRvIHRoaXMgZWxlbWVudFxuXHQgICAgICAgIHZhciByZXNvbHZhYmxlcyA9IHRoaXMuZ2V0T3duUmVzb2x2YWJsZXMoc3RhdGUpO1xuXHQgICAgICAgIHZhciBtYXRjaGVzUmVxdWVzdGVkUG9saWN5ID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHsgcmV0dXJuIGdldFBvbGljeShzdGF0ZS5yZXNvbHZlUG9saWN5LCByZXNvbHZhYmxlKSA+PSBwb2xpY3lPcmRpbmFsOyB9O1xuXHQgICAgICAgIHZhciBtYXRjaGluZ1Jlc29sdmVzID0gY29tbW9uXzEuZmlsdGVyKHJlc29sdmFibGVzLCBtYXRjaGVzUmVxdWVzdGVkUG9saWN5KTtcblx0ICAgICAgICB2YXIgZ2V0UmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSkgeyByZXR1cm4gcmVzb2x2YWJsZS5nZXQoX3RoaXMuaXNvbGF0ZVJvb3RUbyhzdGF0ZSksIG9wdGlvbnMpOyB9O1xuXHQgICAgICAgIHZhciByZXNvbHZhYmxlUHJvbWlzZXMgPSBjb21tb25fMS5tYXAobWF0Y2hpbmdSZXNvbHZlcywgZ2V0UmVzb2x2ZVByb21pc2UpO1xuXHQgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VSZXNvbHZlUGF0aEVsZW1lbnQodGhpcywgbWF0Y2hpbmdSZXNvbHZlcywgb3B0aW9ucyk7XG5cdCAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmFsbChyZXNvbHZhYmxlUHJvbWlzZXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogSW5qZWN0cyBhIGZ1bmN0aW9uIGdpdmVuIHRoZSBSZXNvbHZhYmxlcyBhdmFpbGFibGUgaW4gdGhlIHBhdGgsIGZyb20gdGhlIGZpcnN0IG5vZGVcblx0ICAgICAqIHVwIHRvIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gc3RhdGUuXG5cdCAgICAgKlxuXHQgICAgICogRmlyc3QgaXQgcmVzb2x2ZXMgYWxsIHRoZSByZXNvbHZhYmxlIGRlcGVuY2llcy4gIFdoZW4gdGhleSBhcmUgZG9uZSByZXNvbHZpbmcsIGl0IGludm9rZXNcblx0ICAgICAqIHRoZSBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGZuOiB0aGUgZnVuY3Rpb24gdG8gaW5qZWN0IChpLmUuLCBvbkVudGVyLCBvbkV4aXQsIGNvbnRyb2xsZXIpXG5cdCAgICAgKiBAcGFyYW0gbG9jYWxzOiBhcmUgdGhlIGFuZ3VsYXIgJGluamVjdG9yLXN0eWxlIGxvY2FscyB0byBpbmplY3Rcblx0ICAgICAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zIChUT0RPOiBkb2N1bWVudClcblx0ICAgICAqL1xuXHQgICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZuLCBsb2NhbHMsIG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChsb2NhbHMgPT09IHZvaWQgMCkgeyBsb2NhbHMgPSB7fTsgfVxuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG5cdCAgICAgICAgdmFyIHJlc29sdmFibGVzID0gdGhpcy5nZXRSZXNvbHZhYmxlc0ZvckZuKGZuKTtcblx0ICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUGF0aEVsZW1lbnRJbnZva2UoY29tbW9uXzEudGFpbCh0aGlzLl9wYXRoKSwgZm4sIE9iamVjdC5rZXlzKHJlc29sdmFibGVzKSwgY29tbW9uXzEuZXh0ZW5kKHsgd2hlbjogXCJMYXRlclwiIH0sIG9wdGlvbnMpKTtcblx0ICAgICAgICB2YXIgZ2V0UHJvbWlzZSA9IGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7IHJldHVybiByZXNvbHZhYmxlLmdldChfdGhpcywgb3B0aW9ucyk7IH07XG5cdCAgICAgICAgdmFyIHByb21pc2VzID0gY29tbW9uXzEubWFwKHJlc29sdmFibGVzLCBnZXRQcm9taXNlKTtcblx0ICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pbnZva2VOb3coZm4sIGxvY2Fscywgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogSW1tZWRpYXRlbHkgaW5qZWN0cyBhIGZ1bmN0aW9uIHdpdGggdGhlIGRlcGVuZGVudCBSZXNvbHZhYmxlcyBhdmFpbGFibGUgaW4gdGhlIHBhdGgsIGZyb21cblx0ICAgICAqIHRoZSBmaXJzdCBub2RlIHVwIHRvIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gc3RhdGUuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBSZXNvbHZhYmxlIGlzIG5vdCB5ZXQgcmVzb2x2ZWQsIHRoZW4gbnVsbCBpcyBpbmplY3RlZCBpbiBwbGFjZSBvZiB0aGUgcmVzb2x2YWJsZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBmbjogdGhlIGZ1bmN0aW9uIHRvIGluamVjdCAoaS5lLiwgb25FbnRlciwgb25FeGl0LCBjb250cm9sbGVyKVxuXHQgICAgICogQHBhcmFtIGxvY2FsczogYXJlIHRoZSBhbmd1bGFyICRpbmplY3Rvci1zdHlsZSBsb2NhbHMgdG8gaW5qZWN0XG5cdCAgICAgKiBAcGFyYW0gb3B0aW9uczogb3B0aW9ucyAoVE9ETzogZG9jdW1lbnQpXG5cdCAgICAgKi9cblx0ICAgIC8vIEluamVjdHMgYSBmdW5jdGlvbiBhdCB0aGlzIFBhdGhFbGVtZW50IGxldmVsIHdpdGggYXZhaWxhYmxlIFJlc29sdmFibGVzXG5cdCAgICAvLyBEb2VzIG5vdCB3YWl0IHVudGlsIGFsbCBSZXNvbHZhYmxlcyBoYXZlIGJlZW4gcmVzb2x2ZWQ7IHlvdSBtdXN0IGNhbGwgUGF0aEVsZW1lbnQucmVzb2x2ZSgpIChvciBtYW51YWxseSByZXNvbHZlIGVhY2ggZGVwKSBmaXJzdFxuXHQgICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmludm9rZU5vdyA9IGZ1bmN0aW9uIChmbiwgbG9jYWxzLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB2YXIgcmVzb2x2YWJsZXMgPSB0aGlzLmdldFJlc29sdmFibGVzRm9yRm4oZm4pO1xuXHQgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VQYXRoRWxlbWVudEludm9rZShjb21tb25fMS50YWlsKHRoaXMuX3BhdGgpLCBmbiwgT2JqZWN0LmtleXMocmVzb2x2YWJsZXMpLCBjb21tb25fMS5leHRlbmQoeyB3aGVuOiBcIk5vdyAgXCIgfSwgb3B0aW9ucykpO1xuXHQgICAgICAgIHZhciByZXNvbHZlZExvY2FscyA9IGNvbW1vbl8xLm1hcChyZXNvbHZhYmxlcywgaG9mXzEucHJvcChcImRhdGFcIikpO1xuXHQgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKGZuLCBvcHRpb25zLmJpbmQgfHwgbnVsbCwgY29tbW9uXzEuZXh0ZW5kKHt9LCBsb2NhbHMsIHJlc29sdmVkTG9jYWxzKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFJlc29sdmVDb250ZXh0O1xuXHR9KCkpO1xuXHRleHBvcnRzLlJlc29sdmVDb250ZXh0ID0gUmVzb2x2ZUNvbnRleHQ7XG5cdC8qKlxuXHQgKiBHaXZlbiBhIHN0YXRlJ3MgcmVzb2x2ZVBvbGljeSBhdHRyaWJ1dGUgYW5kIGEgcmVzb2x2YWJsZSBmcm9tIHRoYXQgc3RhdGUsIHJldHVybnMgdGhlIHBvbGljeSBvcmRpbmFsIGZvciB0aGUgUmVzb2x2YWJsZVxuXHQgKiBVc2UgdGhlIHBvbGljeSBkZWNsYXJlZCBmb3IgdGhlIFJlc29sdmUuIElmIHVuZGVmaW5lZCwgdXNlIHRoZSBwb2xpY3kgZGVjbGFyZWQgZm9yIHRoZSBTdGF0ZS4gIElmXG5cdCAqIHVuZGVmaW5lZCwgdXNlIHRoZSBzeXN0ZW0gZGVmYXVsdFJlc29sdmVQb2xpY3kuXG5cdCAqXG5cdCAqIEBwYXJhbSBzdGF0ZVJlc29sdmVQb2xpY3lDb25mIFRoZSByYXcgcmVzb2x2ZVBvbGljeSBkZWNsYXJhdGlvbiBvbiB0aGUgc3RhdGUgb2JqZWN0OyBtYXkgYmUgYSBTdHJpbmcgb3IgT2JqZWN0XG5cdCAqIEBwYXJhbSByZXNvbHZhYmxlIFRoZSByZXNvbHZhYmxlIHRvIGNvbXB1dGUgdGhlIHBvbGljeSBmb3Jcblx0ICovXG5cdGZ1bmN0aW9uIGdldFBvbGljeShzdGF0ZVJlc29sdmVQb2xpY3lDb25mLCByZXNvbHZhYmxlKSB7XG5cdCAgICAvLyBOb3JtYWxpemUgdGhlIGNvbmZpZ3VyYXRpb24gb24gdGhlIHN0YXRlIHRvIGVpdGhlciBzdGF0ZS1sZXZlbCAoYSBzdHJpbmcpIG9yIHJlc29sdmUtbGV2ZWwgKGEgTWFwIG9mIHN0cmluZzpzdHJpbmcpXG5cdCAgICB2YXIgc3RhdGVMZXZlbFBvbGljeSA9IChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVSZXNvbHZlUG9saWN5Q29uZikgPyBzdGF0ZVJlc29sdmVQb2xpY3lDb25mIDogbnVsbCk7XG5cdCAgICB2YXIgcmVzb2x2ZUxldmVsUG9saWNpZXMgPSAocHJlZGljYXRlc18xLmlzT2JqZWN0KHN0YXRlUmVzb2x2ZVBvbGljeUNvbmYpID8gc3RhdGVSZXNvbHZlUG9saWN5Q29uZiA6IHt9KTtcblx0ICAgIHZhciBwb2xpY3lOYW1lID0gcmVzb2x2ZUxldmVsUG9saWNpZXNbcmVzb2x2YWJsZS5uYW1lXSB8fCBzdGF0ZUxldmVsUG9saWN5IHx8IGRlZmF1bHRSZXNvbHZlUG9saWN5O1xuXHQgICAgcmV0dXJuIGludGVyZmFjZV8xLlJlc29sdmVQb2xpY3lbcG9saWN5TmFtZV07XG5cdH1cblxuXG4vKioqLyB9LFxuLyogNDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSByZXNvbHZlICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgUmVzb2x2ZUluamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJlc29sdmVJbmplY3RvcihfcmVzb2x2ZUNvbnRleHQsIF9zdGF0ZSkge1xuXHQgICAgICAgIHRoaXMuX3Jlc29sdmVDb250ZXh0ID0gX3Jlc29sdmVDb250ZXh0O1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gX3N0YXRlO1xuXHQgICAgfVxuXHQgICAgLyoqIFJldHVybnMgYSBwcm9taXNlIHRvIGludm9rZSBhbiBhbm5vdGF0ZWQgZnVuY3Rpb24gaW4gdGhlIHJlc29sdmUgY29udGV4dCAqL1xuXHQgICAgUmVzb2x2ZUluamVjdG9yLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChpbmplY3RlZEZuLCBsb2NhbHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUNvbnRleHQuaW52b2tlTGF0ZXIoaW5qZWN0ZWRGbiwgbG9jYWxzKTtcblx0ICAgIH07XG5cdCAgICAvKiogSW52b2tlcyBhbiBhbm5vdGF0ZWQgZnVuY3Rpb24gaW4gdGhlIHJlc29sdmUgY29udGV4dCAqL1xuXHQgICAgUmVzb2x2ZUluamVjdG9yLnByb3RvdHlwZS5pbnZva2VOb3cgPSBmdW5jdGlvbiAoaW5qZWN0ZWRGbiwgbG9jYWxzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVDb250ZXh0Lmludm9rZU5vdyhudWxsLCBpbmplY3RlZEZuLCBsb2NhbHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKiBSZXR1cm5zIHRoZSBhIHByb21pc2UgZm9yIGxvY2FscyAocmVhbGl6ZWQgUmVzb2x2YWJsZXMpIHRoYXQgYSBmdW5jdGlvbiB3YW50cyAqL1xuXHQgICAgUmVzb2x2ZUluamVjdG9yLnByb3RvdHlwZS5nZXRMb2NhbHMgPSBmdW5jdGlvbiAoaW5qZWN0ZWRGbikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gci5nZXQoX3RoaXMuX3Jlc29sdmVDb250ZXh0KTsgfTtcblx0ICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKHRoaXMuX3Jlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGVzRm9yRm4oaW5qZWN0ZWRGbiksIHJlc29sdmUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZXNvbHZlSW5qZWN0b3I7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVzb2x2ZUluamVjdG9yID0gUmVzb2x2ZUluamVjdG9yO1xuXG5cbi8qKiovIH0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciB0cmFuc2l0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIGhvb2tSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCB0cmFuc2l0aW9uIG9wdGlvbnMuXG5cdCAqIEluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBhcHBseWluZyBjdXN0b20gZGVmYXVsdHM6XG5cdCAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG5cdCAqIGxldCBvcHRpb25zID0gZGVmYXVsdHModGhlaXJPcHRzLCBjdXN0b21EZWZhdWx0cywgZGVmYXVsdE9wdGlvbnMpO1xuXHQgKi9cblx0ZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xuXHQgICAgbG9jYXRpb246IHRydWUsXG5cdCAgICByZWxhdGl2ZTogbnVsbCxcblx0ICAgIGluaGVyaXQ6IGZhbHNlLFxuXHQgICAgbm90aWZ5OiB0cnVlLFxuXHQgICAgcmVsb2FkOiBmYWxzZSxcblx0ICAgIGN1c3RvbToge30sXG5cdCAgICBjdXJyZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9XG5cdH07XG5cdC8qKlxuXHQgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gVHJhbnNpdGlvbnMuXG5cdCAqXG5cdCAqIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsbG93cyBnbG9iYWwgVHJhbnNpdGlvbiBIb29rcyB0byBiZSByZWdpc3RlcmVkLCBhbmQgaGFzIGEgZmFjdG9yeSBmdW5jdGlvblxuXHQgKiBmb3IgY3JlYXRpbmcgbmV3IFRyYW5zaXRpb25zLlxuXHQgKi9cblx0dmFyIFRyYW5zaXRpb25TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25TZXJ2aWNlKCR2aWV3KSB7XG5cdCAgICAgICAgdGhpcy4kdmlldyA9ICR2aWV3O1xuXHQgICAgICAgIHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAkZGVmYXVsdEVycm9ySGFuZGxlcigkZXJyb3IkKSB7XG5cdCAgICAgICAgICAgIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIGhvb2tSZWdpc3RyeV8xLkhvb2tSZWdpc3RyeS5taXhpbihuZXcgaG9va1JlZ2lzdHJ5XzEuSG9va1JlZ2lzdHJ5KCksIHRoaXMpO1xuXHQgICAgfVxuXHQgICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyID0gaGFuZGxlciB8fCB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIG5ldyBbW1RyYW5zaXRpb25dXSBvYmplY3Rcblx0ICAgICAqXG5cdCAgICAgKiBUaGlzIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFRyYW5zaXRpb24gb2JqZWN0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gZnJvbVBhdGhcblx0ICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZVxuXHQgICAgICogQHJldHVybnMge1RyYW5zaXRpb259XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRhcmdldFN0YXRlKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUcmFuc2l0aW9uU2VydmljZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5UcmFuc2l0aW9uU2VydmljZSA9IFRyYW5zaXRpb25TZXJ2aWNlO1xuXG5cbi8qKiovIH0sXG4vKiA0NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcblx0ICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcblx0fVxuXHQvKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMzgpKTtcblxuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRmdW5jdGlvbiBfX2V4cG9ydChtKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG5cdH1cblx0LyoqIEBtb2R1bGUgdXJsICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSk7XG5cdF9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oMjIpKTtcblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg0NykpO1xuXHRfX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSk7XG5cblxuLyoqKi8gfSxcbi8qIDQ2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgdXJsICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIG1vZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBwcmVkaWNhdGVzXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgcGFyYW1fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHR2YXIgY29tbW9uXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgY29tbW9uXzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRmdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHJpbmcsIHBhcmFtKSB7XG5cdCAgICB2YXIgc3Vycm91bmRQYXR0ZXJuID0gWycnLCAnJ10sIHJlc3VsdCA9IHN0cmluZy5yZXBsYWNlKC9bXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dL2csIFwiXFxcXCQmXCIpO1xuXHQgICAgaWYgKCFwYXJhbSlcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgc3dpdGNoIChwYXJhbS5zcXVhc2gpIHtcblx0ICAgICAgICBjYXNlIGZhbHNlOlxuXHQgICAgICAgICAgICBzdXJyb3VuZFBhdHRlcm4gPSBbJygnLCAnKScgKyAocGFyYW0uaXNPcHRpb25hbCA/ICc/JyA6ICcnKV07XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgdHJ1ZTpcblx0ICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdCAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsnKD86XFwvKCcsICcpfFxcLyk/J107XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHN1cnJvdW5kUGF0dGVybiA9IFsoXCIoXCIgKyBwYXJhbS5zcXVhc2ggKyBcInxcIiksICcpPyddO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xuXHR9XG5cdHZhciBtZW1vaXplVG8gPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBmbikgeyByZXR1cm4gb2JqW3Byb3BdID0gb2JqW3Byb3BdIHx8IGZuKCk7IH07XG5cdC8qKlxuXHQgKiBAbmdkb2Mgb2JqZWN0XG5cdCAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMgYW5kIGV4dHJhY3RzIG5hbWVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgcGF0aCBvciB0aGUgc2VhcmNoXG5cdCAqIHBhcnQgb2YgdGhlIFVSTC4gQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdFxuXHQgKiBvZiBzZWFyY2ggcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcblx0ICogZG8gbm90IGluZmx1ZW5jZSB3aGV0aGVyIG9yIG5vdCBhIFVSTCBpcyBtYXRjaGVkLCBidXQgdGhlaXIgdmFsdWVzIGFyZSBwYXNzZWQgdGhyb3VnaCBpbnRvXG5cdCAqIHRoZSBtYXRjaGVkIHBhcmFtZXRlcnMgcmV0dXJuZWQgYnkge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNtZXRob2RzX2V4ZWMgZXhlY30uXG5cdCAqXG5cdCAqIFBhdGggcGFyYW1ldGVyIHBsYWNlaG9sZGVycyBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIHNpbXBsZSBjb2xvbi9jYXRjaC1hbGwgc3ludGF4IG9yIGN1cmx5IGJyYWNlXG5cdCAqIHN5bnRheCwgd2hpY2ggb3B0aW9uYWxseSBhbGxvd3MgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHRoZSBwYXJhbWV0ZXIgdG8gYmUgc3BlY2lmaWVkOlxuXHQgKlxuXHQgKiAqIGAnOidgIG5hbWUgLSBjb2xvbiBwbGFjZWhvbGRlclxuXHQgKiAqIGAnKidgIG5hbWUgLSBjYXRjaC1hbGwgcGxhY2Vob2xkZXJcblx0ICogKiBgJ3snIG5hbWUgJ30nYCAtIGN1cmx5IHBsYWNlaG9sZGVyXG5cdCAqICogYCd7JyBuYW1lICc6JyByZWdleHB8dHlwZSAnfSdgIC0gY3VybHkgcGxhY2Vob2xkZXIgd2l0aCByZWdleHAgb3IgdHlwZSBuYW1lLiBTaG91bGQgdGhlXG5cdCAqICAgcmVnZXhwIGl0c2VsZiBjb250YWluIGN1cmx5IGJyYWNlcywgdGhleSBtdXN0IGJlIGluIG1hdGNoZWQgcGFpcnMgb3IgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoLlxuXHQgKlxuXHQgKiBQYXJhbWV0ZXIgbmFtZXMgbWF5IGNvbnRhaW4gb25seSB3b3JkIGNoYXJhY3RlcnMgKGxhdGluIGxldHRlcnMsIGRpZ2l0cywgYW5kIHVuZGVyc2NvcmUpIGFuZFxuXHQgKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS4gRm9yIGNvbG9uXG5cdCAqIHBsYWNlaG9sZGVycyBvciBjdXJseSBwbGFjZWhvbGRlcnMgd2l0aG91dCBhbiBleHBsaWNpdCByZWdleHAsIGEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnlcblx0ICogbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGwgcGxhY2Vob2xkZXJzIHRoZSBwYXRoIHBhcmFtZXRlciBtYXRjaGVzXG5cdCAqIGFueSBudW1iZXIgb2YgY2hhcmFjdGVycy5cblx0ICpcblx0ICogRXhhbXBsZXM6XG5cdCAqXG5cdCAqICogYCcvaGVsbG8vJ2AgLSBNYXRjaGVzIG9ubHkgaWYgdGhlIHBhdGggaXMgZXhhY3RseSAnL2hlbGxvLycuIFRoZXJlIGlzIG5vIHNwZWNpYWwgdHJlYXRtZW50IGZvclxuXHQgKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXG5cdCAqICogYCcvdXNlci86aWQnYCAtIE1hdGNoZXMgJy91c2VyL2JvYicgb3IgJy91c2VyLzEyMzQhISEnIG9yIGV2ZW4gJy91c2VyLycgYnV0IG5vdCAnL3VzZXInIG9yXG5cdCAqICAgJy91c2VyL2JvYi9kZXRhaWxzJy4gVGhlIHNlY29uZCBwYXRoIHNlZ21lbnQgd2lsbCBiZSBjYXB0dXJlZCBhcyB0aGUgcGFyYW1ldGVyICdpZCcuXG5cdCAqICogYCcvdXNlci97aWR9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxuXHQgKiAqIGAnL3VzZXIve2lkOlteL10qfSdgIC0gU2FtZSBhcyB0aGUgcHJldmlvdXMgZXhhbXBsZS5cblx0ICogKiBgJy91c2VyL3tpZDpbMC05YS1mQS1GXXsxLDh9fSdgIC0gU2ltaWxhciB0byB0aGUgcHJldmlvdXMgZXhhbXBsZSwgYnV0IG9ubHkgbWF0Y2hlcyBpZiB0aGUgaWRcblx0ICogICBwYXJhbWV0ZXIgY29uc2lzdHMgb2YgMSB0byA4IGhleCBkaWdpdHMuXG5cdCAqICogYCcvZmlsZXMve3BhdGg6Lip9J2AgLSBNYXRjaGVzIGFueSBVUkwgc3RhcnRpbmcgd2l0aCAnL2ZpbGVzLycgYW5kIGNhcHR1cmVzIHRoZSByZXN0IG9mIHRoZVxuXHQgKiAgIHBhdGggaW50byB0aGUgcGFyYW1ldGVyICdwYXRoJy5cblx0ICogKiBgJy9maWxlcy8qcGF0aCdgIC0gZGl0dG8uXG5cdCAqICogYCcvY2FsZW5kYXIve3N0YXJ0OmRhdGV9J2AgLSBNYXRjaGVzIFwiL2NhbGVuZGFyLzIwMTQtMTEtMTJcIiAoYmVjYXVzZSB0aGUgcGF0dGVybiBkZWZpbmVkXG5cdCAqICAgaW4gdGhlIGJ1aWx0LWluICBgZGF0ZWAgVHlwZSBtYXRjaGVzIGAyMDE0LTExLTEyYCkgYW5kIHByb3ZpZGVzIGEgRGF0ZSBvYmplY3QgaW4gJHN0YXRlUGFyYW1zLnN0YXJ0XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgcGF0dGVybiB0byBjb21waWxlIGludG8gYSBtYXRjaGVyLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGhhc2hcblx0ICogKiBgY2FzZUluc2Vuc2l0aXZlYCAtIGB0cnVlYCBpZiBVUkwgbWF0Y2hpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUsIG90aGVyd2lzZSBgZmFsc2VgLCB0aGUgZGVmYXVsdCB2YWx1ZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpIGlzIGBmYWxzZWAuXG5cdCAqICogYHN0cmljdGAgLSBgZmFsc2VgIGlmIG1hdGNoaW5nIGFnYWluc3QgYSBVUkwgd2l0aCBhIHRyYWlsaW5nIHNsYXNoIHNob3VsZCBiZSB0cmVhdGVkIGFzIGVxdWl2YWxlbnQgdG8gYSBVUkwgd2l0aG91dCBhIHRyYWlsaW5nIHNsYXNoLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmVmaXggIEEgc3RhdGljIHByZWZpeCBvZiB0aGlzIHBhdHRlcm4uIFRoZSBtYXRjaGVyIGd1YXJhbnRlZXMgdGhhdCBhbnlcblx0ICogICBVUkwgbWF0Y2hpbmcgdGhpcyBtYXRjaGVyIChpLmUuIGFueSBzdHJpbmcgZm9yIHdoaWNoIHtAbGluayB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjbWV0aG9kc19leGVjIGV4ZWMoKX0gcmV0dXJuc1xuXHQgKiAgIG5vbi1udWxsKSB3aWxsIHN0YXJ0IHdpdGggdGhpcyBwcmVmaXguXG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXR0ZXJuICBUaGUgcGF0dGVybiB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHJldHVybnMge09iamVjdH0gIE5ldyBgVXJsTWF0Y2hlcmAgb2JqZWN0XG5cdCAqL1xuXHR2YXIgVXJsTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBVcmxNYXRjaGVyKHBhdHRlcm4sIGNvbmZpZykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcblx0ICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblx0ICAgICAgICB0aGlzLl9jYWNoZSA9IHsgcGF0aDogW10sIHBhdHRlcm46IG51bGwgfTtcblx0ICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtcyA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3NlZ21lbnRzID0gW107XG5cdCAgICAgICAgdGhpcy5fY29tcGlsZWQgPSBbXTtcblx0ICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbW1vbl8xLmRlZmF1bHRzKHRoaXMuY29uZmlnLCB7XG5cdCAgICAgICAgICAgIHBhcmFtczoge30sXG5cdCAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcblx0ICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcblx0ICAgICAgICAgICAgcGFyYW1NYXA6IGNvbW1vbl8xLmlkZW50aXR5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gRmluZCBhbGwgcGxhY2Vob2xkZXJzIGFuZCBjcmVhdGUgYSBjb21waWxlZCBwYXR0ZXJuLCB1c2luZyBlaXRoZXIgY2xhc3NpYyBvciBjdXJseSBzeW50YXg6XG5cdCAgICAgICAgLy8gICAnKicgbmFtZVxuXHQgICAgICAgIC8vICAgJzonIG5hbWVcblx0ICAgICAgICAvLyAgICd7JyBuYW1lICd9J1xuXHQgICAgICAgIC8vICAgJ3snIG5hbWUgJzonIHJlZ2V4cCAnfSdcblx0ICAgICAgICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGlzIHNvbWV3aGF0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgbmVlZCB0byBhbGxvdyBjdXJseSBicmFjZXNcblx0ICAgICAgICAvLyBpbnNpZGUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVGhlIHBsYWNlaG9sZGVyIHJlZ2V4cCBicmVha3MgZG93biBhcyBmb2xsb3dzOlxuXHQgICAgICAgIC8vICAgIChbOipdKShbXFx3XFxbXFxdXSspICAgICAgICAgICAgICAtIGNsYXNzaWMgcGxhY2Vob2xkZXIgKCQxIC8gJDIpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZSlcblx0ICAgICAgICAvLyAgICBcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooIC4uLiApKT9cXH0gIC0gY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIgKCQzKSB3aXRoIG9wdGlvbmFsIHJlZ2V4cC90eXBlIC4uLiAoJDQpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZVxuXHQgICAgICAgIC8vICAgICg/OiAuLi4gfCAuLi4gfCAuLi4gKSsgICAgICAgICAtIHRoZSByZWdleHAgY29uc2lzdHMgb2YgYW55IG51bWJlciBvZiBhdG9tcywgYW4gYXRvbSBiZWluZyBlaXRoZXJcblx0ICAgICAgICAvLyAgICBbXnt9XFxcXF0rICAgICAgICAgICAgICAgICAgICAgICAtIGFueXRoaW5nIG90aGVyIHRoYW4gY3VybHkgYnJhY2VzIG9yIGJhY2tzbGFzaFxuXHQgICAgICAgIC8vICAgIFxcXFwuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXG5cdCAgICAgICAgLy8gICAgXFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9ICAgICAgICAgIC0gYSBtYXRjaGVkIHNldCBvZiBjdXJseSBicmFjZXMgY29udGFpbmluZyBvdGhlciBhdG9tc1xuXHQgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IC8oWzoqXSkoW1xcd1xcW1xcXV0rKXxcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooKD86W157fVxcXFxdK3xcXFxcLnxcXHsoPzpbXnt9XFxcXF0rfFxcXFwuKSpcXH0pKykpP1xcfS9nLCBzZWFyY2hQbGFjZWhvbGRlciA9IC8oWzpdPykoW1xcd1xcW1xcXS4tXSspfFxceyhbXFx3XFxbXFxdLi1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZywgbGFzdCA9IDAsIG0sIHBhdHRlcm5zID0gW107XG5cdCAgICAgICAgdmFyIGNoZWNrUGFyYW1FcnJvcnMgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICAgICAgaWYgKCFVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IudGVzdChpZCkpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciBuYW1lICdcIiArIGlkICsgXCInIGluIHBhdHRlcm4gJ1wiICsgcGF0dGVybiArIFwiJ1wiKTtcblx0ICAgICAgICAgICAgaWYgKGNvbW1vbl8xLmZpbmQoX3RoaXMuX3BhcmFtcywgaG9mXzEucHJvcEVxKCdpZCcsIGlkKSkpXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gU3BsaXQgaW50byBzdGF0aWMgc2VnbWVudHMgc2VwYXJhdGVkIGJ5IHBhdGggcGFyYW1ldGVyIHBsYWNlaG9sZGVycy5cblx0ICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGlzIGFsd2F5cyAxIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgdmFyIG1hdGNoRGV0YWlscyA9IGZ1bmN0aW9uIChtLCBpc1NlYXJjaCkge1xuXHQgICAgICAgICAgICAvLyBJRVs3OF0gcmV0dXJucyAnJyBmb3IgdW5tYXRjaGVkIGdyb3VwcyBpbnN0ZWFkIG9mIG51bGxcblx0ICAgICAgICAgICAgdmFyIGlkID0gbVsyXSB8fCBtWzNdLCByZWdleHAgPSBpc1NlYXJjaCA/IG1bNF0gOiBtWzRdIHx8IChtWzFdID09PSAnKicgPyAnLionIDogbnVsbCk7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICByZWdleHA6IHJlZ2V4cCxcblx0ICAgICAgICAgICAgICAgIGNmZzogX3RoaXMuY29uZmlnLnBhcmFtc1tpZF0sXG5cdCAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0LCBtLmluZGV4KSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6ICFyZWdleHAgPyBudWxsIDogbW9kdWxlXzEucGFyYW1UeXBlcy50eXBlKHJlZ2V4cCB8fCBcInN0cmluZ1wiKSB8fCBjb21tb25fMS5pbmhlcml0KG1vZHVsZV8xLnBhcmFtVHlwZXMudHlwZShcInN0cmluZ1wiKSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IG5ldyBSZWdFeHAocmVnZXhwLCBfdGhpcy5jb25maWcuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogdW5kZWZpbmVkKVxuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciBwLCBzZWdtZW50O1xuXHQgICAgICAgIHdoaWxlICgobSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XG5cdCAgICAgICAgICAgIHAgPSBtYXRjaERldGFpbHMobSwgZmFsc2UpO1xuXHQgICAgICAgICAgICBpZiAocC5zZWdtZW50LmluZGV4T2YoJz8nKSA+PSAwKVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3JlIGludG8gdGhlIHNlYXJjaCBwYXJ0XG5cdCAgICAgICAgICAgIGNoZWNrUGFyYW1FcnJvcnMocC5pZCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKG1vZHVsZV8xLlBhcmFtLmZyb21QYXRoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIGZhbHNlKSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9zZWdtZW50cy5wdXNoKHAuc2VnbWVudCk7XG5cdCAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goW3Auc2VnbWVudCwgY29tbW9uXzEudGFpbCh0aGlzLl9wYXJhbXMpXSk7XG5cdCAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNlZ21lbnQgPSBwYXR0ZXJuLnN1YnN0cmluZyhsYXN0KTtcblx0ICAgICAgICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcblx0ICAgICAgICB2YXIgaSA9IHNlZ21lbnQuaW5kZXhPZignPycpO1xuXHQgICAgICAgIGlmIChpID49IDApIHtcblx0ICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuXHQgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5zdWJzdHJpbmcoMCwgaSk7XG5cdCAgICAgICAgICAgIGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgbGFzdCA9IDA7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hQbGFjZWhvbGRlci5leGVjKHNlYXJjaCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcCA9IG1hdGNoRGV0YWlscyhtLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKG1vZHVsZV8xLlBhcmFtLmZyb21TZWFyY2gocC5pZCwgcC50eXBlLCB0aGlzLmNvbmZpZy5wYXJhbU1hcChwLmNmZywgdHJ1ZSkpKTtcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGxhY2Vob2xkZXIubGFzdEluZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3NlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdCAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2NvbXBpbGVkOiBwYXR0ZXJucy5tYXAoZnVuY3Rpb24gKHBhdHRlcm4pIHsgcmV0dXJuIHF1b3RlUmVnRXhwLmFwcGx5KG51bGwsIHBhdHRlcm4pOyB9KS5jb25jYXQocXVvdGVSZWdFeHAoc2VnbWVudCkpLFxuXHQgICAgICAgICAgICBwcmVmaXg6IHRoaXMuX3NlZ21lbnRzWzBdXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjYXBwZW5kXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBAVE9ET1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBAVE9ET1xuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7VXJsTWF0Y2hlcn0gdXJsIEEgYFVybE1hdGNoZXJgIGluc3RhbmNlIHRvIGFwcGVuZCBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGBVcmxNYXRjaGVyYC5cblx0ICAgICAqL1xuXHQgICAgVXJsTWF0Y2hlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKHVybCkge1xuXHQgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godXJsKTtcblx0ICAgICAgICBjb21tb25fMS5mb3JFYWNoKHVybC5fY2FjaGUsIGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdXJsLl9jYWNoZVtrZXldID0gcHJlZGljYXRlc18xLmlzQXJyYXkodmFsKSA/IFtdIDogbnVsbDsgfSk7XG5cdCAgICAgICAgdXJsLl9jYWNoZS5wYXRoID0gdGhpcy5fY2FjaGUucGF0aC5jb25jYXQodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHVybDtcblx0ICAgIH07XG5cdCAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnBhdGgubGVuZ3RoID09PSAwO1xuXHQgICAgfTtcblx0ICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAqIEBuYW1lIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciNleGVjXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBUZXN0cyB0aGUgc3BlY2lmaWVkIHBhdGggYWdhaW5zdCB0aGlzIG1hdGNoZXIsIGFuZCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYXB0dXJlZFxuXHQgICAgICogcGFyYW1ldGVyIHZhbHVlcywgb3IgbnVsbCBpZiB0aGUgcGF0aCBkb2VzIG5vdCBtYXRjaC4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgdmFsdWVzXG5cdCAgICAgKiBvZiBhbnkgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgbWVudGlvbmVkIGluIHRoZSBwYXR0ZXJuLCBidXQgdGhlaXIgdmFsdWUgbWF5IGJlIG51bGwgaWZcblx0ICAgICAqIHRoZXkgYXJlIG5vdCBwcmVzZW50IGluIGBzZWFyY2hgLiBUaGlzIG1lYW5zIHRoYXQgc2VhcmNoIHBhcmFtZXRlcnMgYXJlIGFsd2F5cyB0cmVhdGVkXG5cdCAgICAgKiBhcyBvcHRpb25hbC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogPHByZT5cblx0ICAgICAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EmcicpLmV4ZWMoJy91c2VyL2JvYicsIHtcblx0ICAgICAqICAgeDogJzEnLCBxOiAnaGVsbG8nXG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vIHJldHVybnMgeyBpZDogJ2JvYicsIHE6ICdoZWxsbycsIHI6IG51bGwgfVxuXHQgICAgICogPC9wcmU+XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIFRoZSBVUkwgcGF0aCB0byBtYXRjaCwgZS5nLiBgJGxvY2F0aW9uLnBhdGgoKWAuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VhcmNoICBVUkwgc2VhcmNoIHBhcmFtZXRlcnMsIGUuZy4gYCRsb2NhdGlvbi5zZWFyY2goKWAuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAgVVJMIGhhc2ggZS5nLiBgJGxvY2F0aW9uLmhhc2goKWAuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgICAgICogQHJldHVybnMge09iamVjdH0gIFRoZSBjYXB0dXJlZCBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgICAgICovXG5cdCAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHBhdGgsIHNlYXJjaCwgaGFzaCwgb3B0aW9ucykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHNlYXJjaCA9PT0gdm9pZCAwKSB7IHNlYXJjaCA9IHt9OyB9XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cblx0ICAgICAgICB2YXIgbWF0Y2ggPSBtZW1vaXplVG8odGhpcy5fY2FjaGUsICdwYXR0ZXJuJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChbXG5cdCAgICAgICAgICAgICAgICAnXicsXG5cdCAgICAgICAgICAgICAgICBjb21tb25fMS51bm5lc3QoX3RoaXMuX2NhY2hlLnBhdGguY29uY2F0KF90aGlzKS5tYXAoaG9mXzEucHJvcCgnX2NvbXBpbGVkJykpKS5qb2luKCcnKSxcblx0ICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpZy5zdHJpY3QgPT09IGZhbHNlID8gJ1xcLz8nIDogJycsXG5cdCAgICAgICAgICAgICAgICAnJCdcblx0ICAgICAgICAgICAgXS5qb2luKCcnKSwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG5cdCAgICAgICAgfSkuZXhlYyhwYXRoKTtcblx0ICAgICAgICBpZiAoIW1hdGNoKVxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAvL29wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7IGlzb2xhdGU6IGZhbHNlIH0pO1xuXHQgICAgICAgIHZhciBhbGxQYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnMoKSwgcGF0aFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0uaXNTZWFyY2goKTsgfSksIHNlYXJjaFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1NlYXJjaCgpOyB9KSwgblBhdGhTZWdtZW50cyA9IHRoaXMuX2NhY2hlLnBhdGguY29uY2F0KHRoaXMpLm1hcChmdW5jdGlvbiAodXJsbSkgeyByZXR1cm4gdXJsbS5fc2VnbWVudHMubGVuZ3RoIC0gMTsgfSkucmVkdWNlKGZ1bmN0aW9uIChhLCB4KSB7IHJldHVybiBhICsgeDsgfSksIHZhbHVlcyA9IHt9O1xuXHQgICAgICAgIGlmIChuUGF0aFNlZ21lbnRzICE9PSBtYXRjaC5sZW5ndGggLSAxKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmJhbGFuY2VkIGNhcHR1cmUgZ3JvdXAgaW4gcm91dGUgJ1wiICsgdGhpcy5wYXR0ZXJuICsgXCInXCIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGRlY29kZVBhdGhBcnJheShzdHJpbmcpIHtcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7IH07XG5cdCAgICAgICAgICAgIHZhciB1bnF1b3RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwtL2csIFwiLVwiKTsgfTtcblx0ICAgICAgICAgICAgdmFyIHNwbGl0ID0gcmV2ZXJzZVN0cmluZyhzdHJpbmcpLnNwbGl0KC8tKD8hXFxcXCkvKTtcblx0ICAgICAgICAgICAgdmFyIGFsbFJldmVyc2VkID0gY29tbW9uXzEubWFwKHNwbGl0LCByZXZlcnNlU3RyaW5nKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcChhbGxSZXZlcnNlZCwgdW5xdW90ZURhc2hlcykucmV2ZXJzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYXRoU2VnbWVudHM7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXRoUGFyYW1zW2ldO1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdCAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJhbSB2YWx1ZSBtYXRjaGVzIGEgcHJlLXJlcGxhY2UgcGFpciwgcmVwbGFjZSB0aGUgdmFsdWUgYmVmb3JlIGRlY29kaW5nLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKVxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0ucmVwbGFjZVtqXS50bztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUgJiYgcGFyYW0uYXJyYXkgPT09IHRydWUpXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVBhdGhBcnJheSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzIuaXNEZWZpbmVkKHZhbHVlKSlcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0udHlwZS5kZWNvZGUodmFsdWUpO1xuXHQgICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb21tb25fMS5mb3JFYWNoKHNlYXJjaFBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlYXJjaFtwYXJhbS5pZF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJlcGxhY2Vbal0uZnJvbSA9PT0gdmFsdWUpXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzIuaXNEZWZpbmVkKHZhbHVlKSlcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0udHlwZS5kZWNvZGUodmFsdWUpO1xuXHQgICAgICAgICAgICB2YWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChoYXNoKVxuXHQgICAgICAgICAgICB2YWx1ZXNbXCIjXCJdID0gaGFzaDtcblx0ICAgICAgICByZXR1cm4gdmFsdWVzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjcGFyYW1ldGVyc1xuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlclxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYWxsIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoaXMgcGF0dGVybiBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHtBcnJheS48UGFyYW0+fSAgQW4gYXJyYXkgb2YgW1tQYXJhbV1dIG9iamVjdHMuIE11c3QgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkuIElmIHRoZVxuXHQgICAgICogICAgcGF0dGVybiBoYXMgbm8gcGFyYW1ldGVycywgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG5cdCAgICAgKi9cblx0ICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAob3B0cykge1xuXHQgICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG5cdCAgICAgICAgaWYgKG9wdHMuaW5oZXJpdCA9PT0gZmFsc2UpXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnVubmVzdCh0aGlzLl9jYWNoZS5wYXRoLmNvbmNhdCh0aGlzKS5tYXAoaG9mXzEucHJvcCgnX3BhcmFtcycpKSk7XG5cdCAgICB9O1xuXHQgICAgVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVyID0gZnVuY3Rpb24gKGlkLCBvcHRzKSB7XG5cdCAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cblx0ICAgICAgICB2YXIgcGFyZW50ID0gY29tbW9uXzEudGFpbCh0aGlzLl9jYWNoZS5wYXRoKTtcblx0ICAgICAgICByZXR1cm4gKGNvbW1vbl8xLmZpbmQodGhpcy5fcGFyYW1zLCBob2ZfMS5wcm9wRXEoJ2lkJywgaWQpKSB8fFxuXHQgICAgICAgICAgICAob3B0cy5pbmhlcml0ICE9PSBmYWxzZSAmJiBwYXJlbnQgJiYgcGFyZW50LnBhcmFtZXRlcihpZCkpIHx8XG5cdCAgICAgICAgICAgIG51bGwpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjdmFsaWRhdGVzXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuXHQgICAgICogdHlwZXMgb2YgdGhpcyBgVXJsTWF0Y2hlcmAuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuXHQgICAgICovXG5cdCAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS52YWxpZGF0ZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgdmFsaWRQYXJhbVZhbCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsKSB7IHJldHVybiAhcGFyYW0gfHwgcGFyYW0udmFsaWRhdGVzKHZhbCk7IH07XG5cdCAgICAgICAgcmV0dXJuIGNvbW1vbl8xLnBhaXJzKHBhcmFtcyB8fCB7fSkubWFwKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbCA9IF9hWzFdO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsaWRQYXJhbVZhbChfdGhpcy5wYXJhbWV0ZXIoa2V5KSwgdmFsKTtcblx0ICAgICAgICB9KS5yZWR1Y2UoY29tbW9uXzEuYWxsVHJ1ZVIsIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIudXRpbC50eXBlOlVybE1hdGNoZXIjZm9ybWF0XG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnV0aWwudHlwZTpVcmxNYXRjaGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBDcmVhdGVzIGEgVVJMIHRoYXQgbWF0Y2hlcyB0aGlzIHBhdHRlcm4gYnkgc3Vic3RpdHV0aW5nIHRoZSBzcGVjaWZpZWQgdmFsdWVzXG5cdCAgICAgKiBmb3IgdGhlIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzLiBOdWxsIHZhbHVlcyBmb3IgcGF0aCBwYXJhbWV0ZXJzIGFyZVxuXHQgICAgICogdHJlYXRlZCBhcyBlbXB0eSBzdHJpbmdzLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiA8cHJlPlxuXHQgICAgICogbmV3IFVybE1hdGNoZXIoJy91c2VyL3tpZH0/cScpLmZvcm1hdCh7IGlkOidib2InLCBxOid5ZXMnIH0pO1xuXHQgICAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xuXHQgICAgICogPC9wcmU+XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxuXHQgICAgICovXG5cdCAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG5cdCAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlcyh2YWx1ZXMpKVxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAvLyBCdWlsZCB0aGUgZnVsbCBwYXRoIG9mIFVybE1hdGNoZXJzIChpbmNsdWRpbmcgYWxsIHBhcmVudCBVcmxNYXRjaGVycylcblx0ICAgICAgICB2YXIgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoLnNsaWNlKCkuY29uY2F0KHRoaXMpO1xuXHQgICAgICAgIC8vIEV4dHJhY3QgYWxsIHRoZSBzdGF0aWMgc2VnbWVudHMgYW5kIFBhcmFtcyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcblx0ICAgICAgICB2YXIgcGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKS5yZWR1Y2UoY29tbW9uXzIudW5uZXN0UiwgW10pO1xuXHQgICAgICAgIC8vIEV4dHJhY3QgdGhlIHF1ZXJ5IHBhcmFtcyBpbnRvIGEgc2VwYXJhdGUgYXJyYXlcblx0ICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSB1cmxNYXRjaGVycy5tYXAoVXJsTWF0Y2hlci5xdWVyeVBhcmFtcykucmVkdWNlKGNvbW1vbl8yLnVubmVzdFIsIFtdKTtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBHaXZlbiBhIFBhcmFtLFxuXHQgICAgICAgICAqIEFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbHMgYWJvdXQgaXRcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHBhcmFtKSB7XG5cdCAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byB0eXBlZCB2YWx1ZVxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbS52YWx1ZSh2YWx1ZXNbcGFyYW0uaWRdKTtcblx0ICAgICAgICAgICAgdmFyIGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuXHQgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBzcXVhc2ggbW9kZSBmb3IgdGhlIHBhcmFtZXRlclxuXHQgICAgICAgICAgICB2YXIgc3F1YXNoID0gaXNEZWZhdWx0VmFsdWUgPyBwYXJhbS5zcXVhc2ggOiBmYWxzZTtcblx0ICAgICAgICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuXHQgICAgICAgICAgICB2YXIgZW5jb2RlZCA9IHBhcmFtLnR5cGUuZW5jb2RlKHZhbHVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgcGFyYW06IHBhcmFtLCB2YWx1ZTogdmFsdWUsIGlzRGVmYXVsdFZhbHVlOiBpc0RlZmF1bHRWYWx1ZSwgc3F1YXNoOiBzcXVhc2gsIGVuY29kZWQ6IGVuY29kZWQgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQnVpbGQgdXAgdGhlIHBhdGgtcG9ydGlvbiBmcm9tIHRoZSBsaXN0IG9mIHN0YXRpYyBzZWdtZW50cyBhbmQgcGFyYW1ldGVyc1xuXHQgICAgICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aFNlZ21lbnRzQW5kUGFyYW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB4KSB7XG5cdCAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XG5cdCAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgeDtcblx0ICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW0uICBGZXRjaCBkZXRhaWxzIGFib3V0IHRoZSBwYXJhbWV0ZXIgdmFsdWVcblx0ICAgICAgICAgICAgdmFyIF9hID0gZ2V0RGV0YWlscyh4KSwgc3F1YXNoID0gX2Euc3F1YXNoLCBlbmNvZGVkID0gX2EuZW5jb2RlZCwgcGFyYW0gPSBfYS5wYXJhbTtcblx0ICAgICAgICAgICAgLy8gSWYgc3F1YXNoIGlzID09PSB0cnVlLCB0cnkgdG8gcmVtb3ZlIGEgc2xhc2ggZnJvbSB0aGUgcGF0aFxuXHQgICAgICAgICAgICBpZiAoc3F1YXNoID09PSB0cnVlKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChhY2MubWF0Y2goL1xcLyQvKSkgPyBhY2Muc2xpY2UoMCwgLTEpIDogYWNjO1xuXHQgICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgYSBzdHJpbmcsIHVzZSB0aGUgc3RyaW5nIGZvciB0aGUgcGFyYW0gdmFsdWVcblx0ICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIHNxdWFzaDtcblx0ICAgICAgICAgICAgaWYgKHNxdWFzaCAhPT0gZmFsc2UpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWNjOyAvLyA/XG5cdCAgICAgICAgICAgIGlmIChlbmNvZGVkID09IG51bGwpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuXHQgICAgICAgICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcblx0ICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGVuY29kZWQpKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGNvbW1vbl8xLm1hcChlbmNvZGVkLCBVcmxNYXRjaGVyLmVuY29kZURhc2hlcykuam9pbihcIi1cIik7XG5cdCAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdHlwZSBpcyBcInJhd1wiLCB0aGVuIGRvIG5vdCBlbmNvZGVVUklDb21wb25lbnRcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUucmF3KVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZWQ7XG5cdCAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgdmFsdWVcblx0ICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKTtcblx0ICAgICAgICB9LCBcIlwiKTtcblx0ICAgICAgICAvLyBCdWlsZCB0aGUgcXVlcnkgc3RyaW5nIGJ5IGFwcGx5aW5nIHBhcmFtZXRlciB2YWx1ZXMgKGFycmF5IG9yIHJlZ3VsYXIpXG5cdCAgICAgICAgLy8gdGhlbiBtYXBwaW5nIHRvIGtleT12YWx1ZSwgdGhlbiBmbGF0dGVuaW5nIGFuZCBqb2luaW5nIHVzaW5nIFwiJlwiXG5cdCAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnlQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuXHQgICAgICAgICAgICB2YXIgX2EgPSBnZXREZXRhaWxzKHBhcmFtKSwgc3F1YXNoID0gX2Euc3F1YXNoLCBlbmNvZGVkID0gX2EuZW5jb2RlZCwgaXNEZWZhdWx0VmFsdWUgPSBfYS5pc0RlZmF1bHRWYWx1ZTtcblx0ICAgICAgICAgICAgaWYgKGVuY29kZWQgPT0gbnVsbCB8fCAoaXNEZWZhdWx0VmFsdWUgJiYgc3F1YXNoICE9PSBmYWxzZSkpXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzQXJyYXkoZW5jb2RlZCkpXG5cdCAgICAgICAgICAgICAgICBlbmNvZGVkID0gW2VuY29kZWRdO1xuXHQgICAgICAgICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPT09IDApXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIGlmICghcGFyYW0udHlwZS5yYXcpXG5cdCAgICAgICAgICAgICAgICBlbmNvZGVkID0gY29tbW9uXzEubWFwKGVuY29kZWQsIGVuY29kZVVSSUNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgIHJldHVybiBlbmNvZGVkLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiAocGFyYW0uaWQgKyBcIj1cIiArIHZhbCk7IH0pO1xuXHQgICAgICAgIH0pLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSkucmVkdWNlKGNvbW1vbl8yLnVubmVzdFIsIFtdKS5qb2luKFwiJlwiKTtcblx0ICAgICAgICAvLyBDb25jYXQgdGhlIHBhdGhzdHJpbmcgd2l0aCB0aGUgcXVlcnlTdHJpbmcgKGlmIGV4aXN0cykgYW5kIHRoZSBoYXNoU3RyaW5nIChpZiBleGlzdHMpXG5cdCAgICAgICAgcmV0dXJuIHBhdGhTdHJpbmcgKyAocXVlcnlTdHJpbmcgPyBcIj9cIiArIHF1ZXJ5U3RyaW5nIDogXCJcIikgKyAodmFsdWVzW1wiI1wiXSA/IFwiI1wiICsgdmFsdWVzW1wiI1wiXSA6IFwiXCIpO1xuXHQgICAgfTtcblx0ICAgIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8tL2csIGZ1bmN0aW9uIChjKSB7IHJldHVybiAoXCIlNUMlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpOyB9KTtcblx0ICAgIH07XG5cdCAgICAvKiogR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHBhdGggc2VnbWVudHMgYW5kIHBhdGggcGFyYW1zLCBpbiBvcmRlciAqL1xuXHQgICAgVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuXHQgICAgICAgIHZhciBzdGF0aWNTZWdtZW50cyA9IG1hdGNoZXIuX3NlZ21lbnRzO1xuXHQgICAgICAgIHZhciBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlBBVEg7IH0pO1xuXHQgICAgICAgIHJldHVybiBjb21tb25fMy5hcnJheVR1cGxlcyhzdGF0aWNTZWdtZW50cywgcGF0aFBhcmFtcy5jb25jYXQodW5kZWZpbmVkKSkucmVkdWNlKGNvbW1vbl8yLnVubmVzdFIsIFtdKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IFwiXCIgJiYgcHJlZGljYXRlc18yLmlzRGVmaW5lZCh4KTsgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqIEdpdmVuIGEgbWF0Y2hlciwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIG1hdGNoZXIncyBxdWVyeSBwYXJhbXMgKi9cblx0ICAgIFVybE1hdGNoZXIucXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuXHQgICAgICAgIHJldHVybiBtYXRjaGVyLl9wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmxvY2F0aW9uID09PSBwYXJhbV8xLkRlZlR5cGUuU0VBUkNIOyB9KTtcblx0ICAgIH07XG5cdCAgICBVcmxNYXRjaGVyLm5hbWVWYWxpZGF0b3IgPSAvXlxcdysoWy0uXStcXHcrKSooPzpcXFtcXF0pPyQvO1xuXHQgICAgcmV0dXJuIFVybE1hdGNoZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVXJsTWF0Y2hlciA9IFVybE1hdGNoZXI7XG5cblxuLyoqKi8gfSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgdXJsICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIG1vZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cdHZhciBtb2R1bGVfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRmdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdHJpY3Q6IG1vZHVsZV8xLm1hdGNoZXJDb25maWcuc3RyaWN0TW9kZSgpLFxuXHQgICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogbW9kdWxlXzEubWF0Y2hlckNvbmZpZy5jYXNlSW5zZW5zaXRpdmUoKVxuXHQgICAgfTtcblx0fVxuXHQvKipcblx0ICogRmFjdG9yeSBmb3IgW1tVcmxNYXRjaGVyXV0gaW5zdGFuY2VzLlxuXHQgKlxuXHQgKiBUaGUgZmFjdG9yeSBpcyBhdmFpbGFibGUgdG8gbmcxIHNlcnZpY2VzIGFzXG5cdCAqIGAkdXJsTWF0Y2hlckZhY3RvcmAgb3IgbmcxIHByb3ZpZGVycyBhcyBgJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXJgLlxuXHQgKi9cblx0dmFyIFVybE1hdGNoZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFVybE1hdGNoZXJGYWN0b3J5KCkge1xuXHQgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7IFVybE1hdGNoZXI6IG1vZHVsZV8xLlVybE1hdGNoZXIsIFBhcmFtOiBtb2R1bGVfMi5QYXJhbSB9KTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5lcyB3aGV0aGVyIFVSTCBtYXRjaGluZyBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKSwgb3Igbm90LlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSBgZmFsc2VgIHRvIG1hdGNoIFVSTCBpbiBhIGNhc2Ugc2Vuc2l0aXZlIG1hbm5lcjsgb3RoZXJ3aXNlIGB0cnVlYDtcblx0ICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGNhc2VJbnNlbnNpdGl2ZVxuXHQgICAgICovXG5cdCAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vZHVsZV8xLm1hdGNoZXJDb25maWcuY2FzZUluc2Vuc2l0aXZlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqIERlZmluZXMgd2hldGhlciBVUkxzIHNob3VsZCBtYXRjaCB0cmFpbGluZyBzbGFzaGVzLCBvciBub3QgKHRoZSBkZWZhdWx0IGJlaGF2aW9yKS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gdmFsdWUgYGZhbHNlYCB0byBtYXRjaCB0cmFpbGluZyBzbGFzaGVzIGluIFVSTHMsIG90aGVyd2lzZSBgdHJ1ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBzdHJpY3RNb2RlXG5cdCAgICAgKi9cblx0ICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5zdHJpY3RNb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vZHVsZV8xLm1hdGNoZXJDb25maWcuc3RyaWN0TW9kZSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gZ2VuZXJhdGluZyBvciBtYXRjaGluZyBVUkxzIHdpdGggZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIGRlZmF1bHQgcGFyYW1ldGVyIFVSTCBzcXVhc2hpbmcgYmVoYXZpb3IuXG5cdCAgICAgKiAgICAtIGBub3NxdWFzaGA6IFdoZW4gZ2VuZXJhdGluZyBhbiBocmVmIHdpdGggYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSwgZG8gbm90IHNxdWFzaCB0aGUgcGFyYW1ldGVyIHZhbHVlIGZyb20gdGhlIFVSTFxuXHQgICAgICogICAgLSBgc2xhc2hgOiBXaGVuIGdlbmVyYXRpbmcgYW4gaHJlZiB3aXRoIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUsIHNxdWFzaCAocmVtb3ZlKSB0aGUgcGFyYW1ldGVyIHZhbHVlLCBhbmQsIGlmIHRoZVxuXHQgICAgICogICAgICAgICAgICAgcGFyYW1ldGVyIGlzIHN1cnJvdW5kZWQgYnkgc2xhc2hlcywgc3F1YXNoIChyZW1vdmUpIG9uZSBzbGFzaCBmcm9tIHRoZSBVUkxcblx0ICAgICAqICAgIC0gYW55IG90aGVyIHN0cmluZywgZS5nLiBcIn5cIjogV2hlbiBnZW5lcmF0aW5nIGFuIGhyZWYgd2l0aCBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlLCBzcXVhc2ggKHJlbW92ZSlcblx0ICAgICAqICAgICAgICAgICAgIHRoZSBwYXJhbWV0ZXIgdmFsdWUgZnJvbSB0aGUgVVJMIGFuZCByZXBsYWNlIGl0IHdpdGggdGhpcyBzdHJpbmcuXG5cdCAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBkZWZhdWx0U3F1YXNoUG9saWN5XG5cdCAgICAgKi9cblx0ICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5kZWZhdWx0U3F1YXNoUG9saWN5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIG1vZHVsZV8xLm1hdGNoZXJDb25maWcuZGVmYXVsdFNxdWFzaFBvbGljeSh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgW1tVcmxNYXRjaGVyXV0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gcGF0dGVybiAgVGhlIFVSTCBwYXR0ZXJuLlxuXHQgICAgICogQHBhcmFtIGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QgaGFzaC5cblx0ICAgICAqIEByZXR1cm5zIFRoZSBVcmxNYXRjaGVyLlxuXHQgICAgICovXG5cdCAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25maWcpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IG1vZHVsZV8xLlVybE1hdGNoZXIocGF0dGVybiwgY29tbW9uXzEuZXh0ZW5kKGdldERlZmF1bHRDb25maWcoKSwgY29uZmlnKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBbW1VybE1hdGNoZXJdXSwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBvYmplY3QgIFRoZSBvYmplY3QgdG8gcGVyZm9ybSB0aGUgdHlwZSBjaGVjayBhZ2FpbnN0LlxuXHQgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWF0Y2hlcyB0aGUgYFVybE1hdGNoZXJgIGludGVyZmFjZSwgYnlcblx0ICAgICAqICAgICAgICAgIGltcGxlbWVudGluZyBhbGwgdGhlIHNhbWUgbWV0aG9kcy5cblx0ICAgICAqL1xuXHQgICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmlzTWF0Y2hlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0ICAgICAgICAvLyBUT0RPOiB0eXBlb2Y/XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNPYmplY3Qob2JqZWN0KSlcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuXHQgICAgICAgIGNvbW1vbl8xLmZvckVhY2gobW9kdWxlXzEuVXJsTWF0Y2hlci5wcm90b3R5cGUsIGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcblx0ICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHZhbCkpXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob2JqZWN0W25hbWVdKSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmplY3RbbmFtZV0pKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIC8qKlxuXHQgICAgICogUmVnaXN0ZXJzIGEgY3VzdG9tIFtbVHlwZV1dIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBuYW1lICBUaGUgdHlwZSBuYW1lLlxuXHQgICAgICogQHBhcmFtIGRlZmluaXRpb24gVGhlIHR5cGUgZGVmaW5pdGlvbi4gU2VlIFtbVHlwZV1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuXHQgICAgICogQHBhcmFtIGRlZmluaXRpb25GbiBBIGZ1bmN0aW9uIHRoYXQgaXMgaW5qZWN0ZWQgYmVmb3JlIHRoZSBhcHBcblx0ICAgICAqICAgICAgICBydW50aW1lIHN0YXJ0cy4gIFRoZSByZXN1bHQgb2YgdGhpcyBmdW5jdGlvbiBpcyBtZXJnZWQgaW50byB0aGUgZXhpc3RpbmcgYGRlZmluaXRpb25gLlxuXHQgICAgICogICAgICAgIFNlZSBbW1R5cGVdXSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIHZhbHVlcyBhY2NlcHRlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJucyAtIGlmIGEgdHlwZSB3YXMgcmVnaXN0ZXJlZDogdGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXVxuXHQgICAgICogICAtIGlmIG9ubHkgdGhlIGBuYW1lYCBwYXJhbWV0ZXIgd2FzIHNwZWNpZmllZDogdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIFtbVHlwZV1dIG9iamVjdCwgb3IgdW5kZWZpbmVkXG5cdCAgICAgKlxuXHQgICAgICogLS0tXG5cdCAgICAgKlxuXHQgICAgICogVGhpcyBpcyBhIHNpbXBsZSBleGFtcGxlIG9mIGEgY3VzdG9tIHR5cGUgdGhhdCBlbmNvZGVzIGFuZCBkZWNvZGVzIGl0ZW1zIGZyb20gYW5cblx0ICAgICAqIGFycmF5LCB1c2luZyB0aGUgYXJyYXkgaW5kZXggYXMgdGhlIFVSTC1lbmNvZGVkIHZhbHVlOlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBgYGBcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgbGlzdCA9IFsnSm9obicsICdQYXVsJywgJ0dlb3JnZScsICdSaW5nbyddO1xuXHQgICAgICpcblx0ICAgICAqICR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLnR5cGUoJ2xpc3RJdGVtJywge1xuXHQgICAgICogICBlbmNvZGU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAqICAgICAvLyBSZXByZXNlbnQgdGhlIGxpc3QgaXRlbSBpbiB0aGUgVVJMIHVzaW5nIGl0cyBjb3JyZXNwb25kaW5nIGluZGV4XG5cdCAgICAgKiAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihpdGVtKTtcblx0ICAgICAqICAgfSxcblx0ICAgICAqICAgZGVjb2RlOiBmdW5jdGlvbihpdGVtKSB7XG5cdCAgICAgKiAgICAgLy8gTG9vayB1cCB0aGUgbGlzdCBpdGVtIGJ5IGluZGV4XG5cdCAgICAgKiAgICAgcmV0dXJuIGxpc3RbcGFyc2VJbnQoaXRlbSwgMTApXTtcblx0ICAgICAqICAgfSxcblx0ICAgICAqICAgaXM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAqICAgICAvLyBFbnN1cmUgdGhlIGl0ZW0gaXMgdmFsaWQgYnkgY2hlY2tpbmcgdG8gc2VlIHRoYXQgaXQgYXBwZWFyc1xuXHQgICAgICogICAgIC8vIGluIHRoZSBsaXN0XG5cdCAgICAgKiAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihpdGVtKSA+IC0xO1xuXHQgICAgICogICB9XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAkc3RhdGVQcm92aWRlci5zdGF0ZSgnbGlzdCcsIHtcblx0ICAgICAqICAgdXJsOiBcIi9saXN0L3tpdGVtOmxpc3RJdGVtfVwiLFxuXHQgICAgICogICBjb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcykge1xuXHQgICAgICogICAgIGNvbnNvbGUubG9nKCRzdGF0ZVBhcmFtcy5pdGVtKTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gLi4uXG5cdCAgICAgKlxuXHQgICAgICogLy8gQ2hhbmdlcyBVUkwgdG8gJy9saXN0LzMnLCBsb2dzIFwiUmluZ29cIiB0byB0aGUgY29uc29sZVxuXHQgICAgICogJHN0YXRlLmdvKCdsaXN0JywgeyBpdGVtOiBcIlJpbmdvXCIgfSk7XG5cdCAgICAgKiBgYGBcblx0ICAgICAqL1xuXHQgICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG5cdCAgICAgICAgdmFyIHR5cGUgPSBtb2R1bGVfMi5wYXJhbVR5cGVzLnR5cGUobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKTtcblx0ICAgICAgICByZXR1cm4gIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikgPyB0eXBlIDogdGhpcztcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKiogQGhpZGRlbiAqL1xuXHQgICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgbW9kdWxlXzIucGFyYW1UeXBlcy5lbnF1ZXVlID0gZmFsc2U7XG5cdCAgICAgICAgbW9kdWxlXzIucGFyYW1UeXBlcy5fZmx1c2hUeXBlUXVldWUoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICByZXR1cm4gVXJsTWF0Y2hlckZhY3Rvcnk7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVXJsTWF0Y2hlckZhY3RvcnkgPSBVcmxNYXRjaGVyRmFjdG9yeTtcblxuXG4vKioqLyB9LFxuLyogNDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSB1cmwgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgJGxvY2F0aW9uID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMubG9jYXRpb247XG5cdC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBhIHByZWZpeCBvZiBhbGwgc3RyaW5ncyBtYXRjaGluZyB0aGUgUmVnRXhwXG5cdGZ1bmN0aW9uIHJlZ0V4cFByZWZpeChyZSkge1xuXHQgICAgdmFyIHByZWZpeCA9IC9eXFxeKCg/OlxcXFxbXmEtekEtWjAtOV18W15cXFxcXFxbXFxdXFxeJCorPy4oKXx7fV0rKSopLy5leGVjKHJlLnNvdXJjZSk7XG5cdCAgICByZXR1cm4gKHByZWZpeCAhPSBudWxsKSA/IHByZWZpeFsxXS5yZXBsYWNlKC9cXFxcKC4pL2csIFwiJDFcIikgOiAnJztcblx0fVxuXHQvLyBJbnRlcnBvbGF0ZXMgbWF0Y2hlZCB2YWx1ZXMgaW50byBhIFN0cmluZy5yZXBsYWNlKCktc3R5bGUgcGF0dGVyblxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZShwYXR0ZXJuLCBtYXRjaCkge1xuXHQgICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xuXHQgICAgICAgIHJldHVybiBtYXRjaFt3aGF0ID09PSAnJCcgPyAwIDogTnVtYmVyKHdoYXQpXTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCAkc3RhdGVQYXJhbXMsIGhhbmRsZXIsIG1hdGNoKSB7XG5cdCAgICBpZiAoIW1hdGNoKVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciByZXN1bHQgPSAkaW5qZWN0b3IuaW52b2tlKGhhbmRsZXIsIGhhbmRsZXIsIHsgJG1hdGNoOiBtYXRjaCwgJHN0YXRlUGFyYW1zOiAkc3RhdGVQYXJhbXMgfSk7XG5cdCAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogdHJ1ZTtcblx0fVxuXHRmdW5jdGlvbiBhcHBlbmRCYXNlUGF0aCh1cmwsIGlzSHRtbDUsIGFic29sdXRlKSB7XG5cdCAgICB2YXIgYmFzZUhyZWYgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy5sb2NhdGlvbkNvbmZpZy5iYXNlSHJlZigpO1xuXHQgICAgaWYgKGJhc2VIcmVmID09PSAnLycpXG5cdCAgICAgICAgcmV0dXJuIHVybDtcblx0ICAgIGlmIChpc0h0bWw1KVxuXHQgICAgICAgIHJldHVybiBiYXNlSHJlZi5zbGljZSgwLCAtMSkgKyB1cmw7XG5cdCAgICBpZiAoYWJzb2x1dGUpXG5cdCAgICAgICAgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDEpICsgdXJsO1xuXHQgICAgcmV0dXJuIHVybDtcblx0fVxuXHQvLyBUT0RPOiBPcHRpbWl6ZSBncm91cHMgb2YgcnVsZXMgd2l0aCBub24tZW1wdHkgcHJlZml4IGludG8gc29tZSBzb3J0IG9mIGRlY2lzaW9uIHRyZWVcblx0ZnVuY3Rpb24gdXBkYXRlKHJ1bGVzLCBvdGhlcndpc2VGbiwgZXZ0KSB7XG5cdCAgICBpZiAoZXZ0ICYmIGV2dC5kZWZhdWx0UHJldmVudGVkKVxuXHQgICAgICAgIHJldHVybjtcblx0ICAgIGZ1bmN0aW9uIGNoZWNrKHJ1bGUpIHtcblx0ICAgICAgICB2YXIgaGFuZGxlZCA9IHJ1bGUoY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLCAkbG9jYXRpb24pO1xuXHQgICAgICAgIGlmICghaGFuZGxlZClcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlZCkpIHtcblx0ICAgICAgICAgICAgJGxvY2F0aW9uLnJlcGxhY2UoKTtcblx0ICAgICAgICAgICAgJGxvY2F0aW9uLnVybChoYW5kbGVkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgbiA9IHJ1bGVzLmxlbmd0aCwgaTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICBpZiAoY2hlY2socnVsZXNbaV0pKVxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICAvLyBhbHdheXMgY2hlY2sgb3RoZXJ3aXNlIGxhc3QgdG8gYWxsb3cgZHluYW1pYyB1cGRhdGVzIHRvIHRoZSBzZXQgb2YgcnVsZXNcblx0ICAgIGlmIChvdGhlcndpc2VGbilcblx0ICAgICAgICBjaGVjayhvdGhlcndpc2VGbik7XG5cdH1cblx0LyoqXG5cdCAqIEBuZ2RvYyBvYmplY3Rcblx0ICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXJcblx0ICpcblx0ICogQHJlcXVpcmVzIHVpLnJvdXRlci51dGlsLiR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyXG5cdCAqIEByZXF1aXJlcyAkbG9jYXRpb25Qcm92aWRlclxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogYCR1cmxSb3V0ZXJQcm92aWRlcmAgaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB3YXRjaGluZyBgJGxvY2F0aW9uYC5cblx0ICogV2hlbiBgJGxvY2F0aW9uYCBjaGFuZ2VzIGl0IHJ1bnMgdGhyb3VnaCBhIGxpc3Qgb2YgcnVsZXMgb25lIGJ5IG9uZSB1bnRpbCBhXG5cdCAqIG1hdGNoIGlzIGZvdW5kLiBgJHVybFJvdXRlclByb3ZpZGVyYCBpcyB1c2VkIGJlaGluZCB0aGUgc2NlbmVzIGFueXRpbWUgeW91IHNwZWNpZnlcblx0ICogYSB1cmwgaW4gYSBzdGF0ZSBjb25maWd1cmF0aW9uLiBBbGwgdXJscyBhcmUgY29tcGlsZWQgaW50byBhIFVybE1hdGNoZXIgb2JqZWN0LlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgc2V2ZXJhbCBtZXRob2RzIG9uIGAkdXJsUm91dGVyUHJvdmlkZXJgIHRoYXQgbWFrZSBpdCB1c2VmdWwgdG8gdXNlIGRpcmVjdGx5XG5cdCAqIGluIHlvdXIgbW9kdWxlIGNvbmZpZy5cblx0ICovXG5cdHZhciBVcmxSb3V0ZXJQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBVcmxSb3V0ZXJQcm92aWRlcigkdXJsTWF0Y2hlckZhY3RvcnksICRzdGF0ZVBhcmFtcykge1xuXHQgICAgICAgIHRoaXMuJHVybE1hdGNoZXJGYWN0b3J5ID0gJHVybE1hdGNoZXJGYWN0b3J5O1xuXHQgICAgICAgIHRoaXMuJHN0YXRlUGFyYW1zID0gJHN0YXRlUGFyYW1zO1xuXHQgICAgICAgIC8qKiBAaGlkZGVuICovXG5cdCAgICAgICAgdGhpcy5ydWxlcyA9IFtdO1xuXHQgICAgICAgIC8qKiBAaGlkZGVuICovXG5cdCAgICAgICAgdGhpcy5vdGhlcndpc2VGbiA9IG51bGw7XG5cdCAgICAgICAgLyoqIEBoaWRkZW4gKi9cblx0ICAgICAgICB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXIjcnVsZVxuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBEZWZpbmVzIHJ1bGVzIHRoYXQgYXJlIHVzZWQgYnkgYCR1cmxSb3V0ZXJQcm92aWRlcmAgdG8gZmluZCBtYXRjaGVzIGZvclxuXHQgICAgICogc3BlY2lmaWMgVVJMcy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogPHByZT5cblx0ICAgICAqIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXIucm91dGVyJ10pO1xuXHQgICAgICpcblx0ICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuXHQgICAgICogICAvLyBIZXJlJ3MgYW4gZXhhbXBsZSBvZiBob3cgeW91IG1pZ2h0IGFsbG93IGNhc2UgaW5zZW5zaXRpdmUgdXJsc1xuXHQgICAgICogICAkdXJsUm91dGVyUHJvdmlkZXIucnVsZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcblx0ICAgICAqICAgICB2YXIgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCksXG5cdCAgICAgKiAgICAgICAgIG5vcm1hbGl6ZWQgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgIGlmIChwYXRoICE9PSBub3JtYWxpemVkKSB7XG5cdCAgICAgKiAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcblx0ICAgICAqICAgICB9XG5cdCAgICAgKiAgIH0pO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBydWxlIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmBcblx0ICAgICAqIHNlcnZpY2VzIGFzIGFyZ3VtZW50cy4gWW91IGNhbiB1c2UgdGhlbSB0byByZXR1cm4gYSB2YWxpZCBwYXRoIGFzIGEgc3RyaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge29iamVjdH0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgLSBgJHVybFJvdXRlclByb3ZpZGVyYCBpbnN0YW5jZVxuXHQgICAgICovXG5cdCAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUucnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihydWxlKSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3J1bGUnIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2Mgb2JqZWN0XG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlciNvdGhlcndpc2Vcblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogRGVmaW5lcyBhIHBhdGggdGhhdCBpcyB1c2VkIHdoZW4gYW4gaW52YWxpZCByb3V0ZSBpcyByZXF1ZXN0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcblx0ICAgICAqXG5cdCAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcblx0ICAgICAqICAgLy8gaWYgdGhlIHBhdGggZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIHVybHMgeW91IGNvbmZpZ3VyZWRcblx0ICAgICAqICAgLy8gb3RoZXJ3aXNlIHdpbGwgdGFrZSBjYXJlIG9mIHJvdXRpbmcgdGhlIHVzZXIgdG8gdGhlXG5cdCAgICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcblx0ICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2luZGV4Jyk7XG5cdCAgICAgKlxuXHQgICAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cblx0ICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZShmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcblx0ICAgICAqICAgICByZXR1cm4gJy9hL3ZhbGlkL3VybCc7XG5cdCAgICAgKiAgIH0pO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gcnVsZSBUaGUgdXJsIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgdG8gb3IgYSBmdW5jdGlvblxuXHQgICAgICogcnVsZSB0aGF0IHJldHVybnMgdGhlIHVybCBwYXRoLiBUaGUgZnVuY3Rpb24gdmVyc2lvbiBpcyBwYXNzZWQgdHdvIHBhcmFtczpcblx0ICAgICAqIGAkaW5qZWN0b3JgIGFuZCBgJGxvY2F0aW9uYCBzZXJ2aWNlcywgYW5kIG11c3QgcmV0dXJuIGEgdXJsIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGAkdXJsUm91dGVyUHJvdmlkZXJgIC0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgaW5zdGFuY2Vcblx0ICAgICAqL1xuXHQgICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLm90aGVyd2lzZSA9IGZ1bmN0aW9uIChydWxlKSB7XG5cdCAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihydWxlKSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKHJ1bGUpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIncnVsZScgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvblwiKTtcblx0ICAgICAgICB0aGlzLm90aGVyd2lzZUZuID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHJ1bGUpID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcnVsZTsgfSA6IHJ1bGU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlclByb3ZpZGVyI3doZW5cblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuXG5cdCAgICAgKlxuXHQgICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBzdHJpbmcsIGl0IGlzXG5cdCAgICAgKiB0cmVhdGVkIGFzIGEgcmVkaXJlY3QsIGFuZCBpcyBpbnRlcnBvbGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggb2YgbWF0Y2hcblx0ICAgICAqIChpLmUuIGxpa2UgYFN0cmluZy5yZXBsYWNlKClgIGZvciBgUmVnRXhwYCwgb3IgbGlrZSBhIGBVcmxNYXRjaGVyYCBwYXR0ZXJuIG90aGVyd2lzZSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW5qZWN0YWJsZS4gSXQgZ2V0cyBpbnZva2VkIGlmIGAkbG9jYXRpb25gXG5cdCAgICAgKiBtYXRjaGVzLiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBoYW5kbGVyIGNhbiByZXR1cm5cblx0ICAgICAqXG5cdCAgICAgKiAtICoqZmFsc3kqKiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBydWxlIGRpZG4ndCBtYXRjaCBhZnRlciBhbGwsIHRoZW4gYCR1cmxSb3V0ZXJgXG5cdCAgICAgKiAgIHdpbGwgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYW5vdGhlciBvbmUgdGhhdCBtYXRjaGVzLlxuXHQgICAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG5cdCAgICAgKiAtICoqdm9pZCoqIG9yIGFueSAqKnRydXRoeSoqIHZhbHVlIHRlbGxzIGAkdXJsUm91dGVyYCB0aGF0IHRoZSB1cmwgd2FzIGhhbmRsZWQuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcblx0ICAgICAqXG5cdCAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcblx0ICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4oJHN0YXRlLnVybCwgZnVuY3Rpb24gKCRtYXRjaCwgJHN0YXRlUGFyYW1zKSB7XG5cdCAgICAgKiAgICAgaWYgKCRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUgIT09IHN0YXRlIHx8XG5cdCAgICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcblx0ICAgICAqICAgICAgJHN0YXRlLnRyYW5zaXRpb25UbyhzdGF0ZSwgJG1hdGNoLCBmYWxzZSk7XG5cdCAgICAgKiAgICAgfVxuXHQgICAgICogICB9KTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogPC9wcmU+XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB3aGF0IFRoZSBpbmNvbWluZyBwYXRoIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gaGFuZGxlciBUaGUgcGF0aCB5b3Ugd2FudCB0byByZWRpcmVjdCB5b3VyIHVzZXIgdG8uXG5cdCAgICAgKi9cblx0ICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKHdoYXQsIGhhbmRsZXIpIHtcblx0ICAgICAgICB2YXIgX2EgPSB0aGlzLCAkdXJsTWF0Y2hlckZhY3RvcnkgPSBfYS4kdXJsTWF0Y2hlckZhY3RvcnksICRzdGF0ZVBhcmFtcyA9IF9hLiRzdGF0ZVBhcmFtcztcblx0ICAgICAgICB2YXIgcmVkaXJlY3QsIGhhbmRsZXJJc1N0cmluZyA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyhoYW5kbGVyKTtcblx0ICAgICAgICAvLyBAdG9kbyBRdWV1ZSB0aGlzXG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyh3aGF0KSlcblx0ICAgICAgICAgICAgd2hhdCA9ICR1cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKHdoYXQpO1xuXHQgICAgICAgIGlmICghaGFuZGxlcklzU3RyaW5nICYmICFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhcHJlZGljYXRlc18xLmlzQXJyYXkoaGFuZGxlcikpXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ2hhbmRsZXInIGluIHdoZW4oKVwiKTtcblx0ICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IHtcblx0ICAgICAgICAgICAgbWF0Y2hlcjogZnVuY3Rpb24gKF93aGF0LCBfaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJJc1N0cmluZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0ID0gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoX2hhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9oYW5kbGVyID0gWyckbWF0Y2gnLCByZWRpcmVjdC5mb3JtYXQuYmluZChyZWRpcmVjdCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLCAkc3RhdGVQYXJhbXMsIF9oYW5kbGVyLCBfd2hhdC5leGVjKCRsb2NhdGlvbi5wYXRoKCksICRsb2NhdGlvbi5zZWFyY2goKSwgJGxvY2F0aW9uLmhhc2goKSkpO1xuXHQgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZGljYXRlc18xLmlzU3RyaW5nKF93aGF0LnByZWZpeCkgPyBfd2hhdC5wcmVmaXggOiAnJ1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHJlZ2V4OiBmdW5jdGlvbiAoX3doYXQsIF9oYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3doYXQuZ2xvYmFsIHx8IF93aGF0LnN0aWNreSlcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3aGVuKCkgUmVnRXhwIG11c3Qgbm90IGJlIGdsb2JhbCBvciBzdGlja3lcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcklzU3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3QgPSBfaGFuZGxlcjtcblx0ICAgICAgICAgICAgICAgICAgICBfaGFuZGxlciA9IFsnJG1hdGNoJywgZnVuY3Rpb24gKCRtYXRjaCkgeyByZXR1cm4gaW50ZXJwb2xhdGUocmVkaXJlY3QsICRtYXRjaCk7IH1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLCAkc3RhdGVQYXJhbXMsIF9oYW5kbGVyLCBfd2hhdC5leGVjKCRsb2NhdGlvbi5wYXRoKCkpKTtcblx0ICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHJlZ0V4cFByZWZpeChfd2hhdClcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgY2hlY2sgPSB7XG5cdCAgICAgICAgICAgIG1hdGNoZXI6ICR1cmxNYXRjaGVyRmFjdG9yeS5pc01hdGNoZXIod2hhdCksXG5cdCAgICAgICAgICAgIHJlZ2V4OiB3aGF0IGluc3RhbmNlb2YgUmVnRXhwXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmb3IgKHZhciBuIGluIGNoZWNrKSB7XG5cdCAgICAgICAgICAgIGlmIChjaGVja1tuXSlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGUoc3RyYXRlZ2llc1tuXSh3aGF0LCBoYW5kbGVyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ3doYXQnIGluIHdoZW4oKVwiKTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyUHJvdmlkZXIjZGVmZXJJbnRlcmNlcHRcblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJQcm92aWRlclxuXHQgICAgICpcblx0ICAgICAqIEBkZXNjcmlwdGlvblxuXHQgICAgICogRGlzYWJsZXMgKG9yIGVuYWJsZXMpIGRlZmVycmluZyBsb2NhdGlvbiBjaGFuZ2UgaW50ZXJjZXB0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIElmIHlvdSB3aXNoIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2Ygc3luY2luZyB0aGUgVVJMIChmb3IgZXhhbXBsZSwgaWYgeW91IHdpc2ggdG9cblx0ICAgICAqIGRlZmVyIGEgdHJhbnNpdGlvbiBidXQgbWFpbnRhaW4gdGhlIGN1cnJlbnQgVVJMKSwgY2FsbCB0aGlzIG1ldGhvZCBhdCBjb25maWd1cmF0aW9uIHRpbWUuXG5cdCAgICAgKiBUaGVuLCBhdCBydW4gdGltZSwgY2FsbCBgJHVybFJvdXRlci5saXN0ZW4oKWAgYWZ0ZXIgeW91IGhhdmUgY29uZmlndXJlZCB5b3VyIG93blxuXHQgICAgICogYCRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3NgIGV2ZW50IGhhbmRsZXIuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqIDxwcmU+XG5cdCAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcblx0ICAgICAqXG5cdCAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcblx0ICAgICAqXG5cdCAgICAgKiAgIC8vIFByZXZlbnQgJHVybFJvdXRlciBmcm9tIGF1dG9tYXRpY2FsbHkgaW50ZXJjZXB0aW5nIFVSTCBjaGFuZ2VzO1xuXHQgICAgICogICAvLyB0aGlzIGFsbG93cyB5b3UgdG8gY29uZmlndXJlIGN1c3RvbSBiZWhhdmlvciBpbiBiZXR3ZWVuXG5cdCAgICAgKiAgIC8vIGxvY2F0aW9uIGNoYW5nZXMgYW5kIHJvdXRlIHN5bmNocm9uaXphdGlvbjpcblx0ICAgICAqICAgJHVybFJvdXRlclByb3ZpZGVyLmRlZmVySW50ZXJjZXB0KCk7XG5cdCAgICAgKlxuXHQgICAgICogfSkucnVuKGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkdXJsUm91dGVyLCBVc2VyU2VydmljZSkge1xuXHQgICAgICpcblx0ICAgICAqICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbihlKSB7XG5cdCAgICAgKiAgICAgLy8gVXNlclNlcnZpY2UgaXMgYW4gZXhhbXBsZSBzZXJ2aWNlIGZvciBtYW5hZ2luZyB1c2VyIHN0YXRlXG5cdCAgICAgKiAgICAgaWYgKFVzZXJTZXJ2aWNlLmlzTG9nZ2VkSW4oKSkgcmV0dXJuO1xuXHQgICAgICpcblx0ICAgICAqICAgICAvLyBQcmV2ZW50ICR1cmxSb3V0ZXIncyBkZWZhdWx0IGhhbmRsZXIgZnJvbSBmaXJpbmdcblx0ICAgICAqICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgIFVzZXJTZXJ2aWNlLmhhbmRsZUxvZ2luKCkudGhlbihmdW5jdGlvbigpIHtcblx0ICAgICAqICAgICAgIC8vIE9uY2UgdGhlIHVzZXIgaGFzIGxvZ2dlZCBpbiwgc3luYyB0aGUgY3VycmVudCBVUkxcblx0ICAgICAqICAgICAgIC8vIHRvIHRoZSByb3V0ZXI6XG5cdCAgICAgKiAgICAgICAkdXJsUm91dGVyLnN5bmMoKTtcblx0ICAgICAqICAgICB9KTtcblx0ICAgICAqICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAvLyBDb25maWd1cmVzICR1cmxSb3V0ZXIncyBsaXN0ZW5lciAqYWZ0ZXIqIHlvdXIgY3VzdG9tIGxpc3RlbmVyXG5cdCAgICAgKiAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi4gUGFzc2luZ1xuXHQgICAgICogICAgICAgIG5vIHBhcmFtZXRlciBpcyBlcXVpdmFsZW50IHRvIGB0cnVlYC5cblx0ICAgICAqL1xuXHQgICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG5cdCAgICAgICAgaWYgKGRlZmVyID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgIGRlZmVyID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLmludGVyY2VwdERlZmVycmVkID0gZGVmZXI7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgcmV0dXJuIFVybFJvdXRlclByb3ZpZGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlVybFJvdXRlclByb3ZpZGVyID0gVXJsUm91dGVyUHJvdmlkZXI7XG5cdHZhciBVcmxSb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVXJsUm91dGVyKHVybFJvdXRlclByb3ZpZGVyKSB7XG5cdCAgICAgICAgdGhpcy51cmxSb3V0ZXJQcm92aWRlciA9IHVybFJvdXRlclByb3ZpZGVyO1xuXHQgICAgICAgIGNvbW1vbl8xLmJpbmRGdW5jdGlvbnMoVXJsUm91dGVyLnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyI3N5bmNcblx0ICAgICAqIEBtZXRob2RPZiB1aS5yb3V0ZXIucm91dGVyLiR1cmxSb3V0ZXJcblx0ICAgICAqXG5cdCAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZTsgdGhlIHNhbWUgdXBkYXRlIHRoYXQgaGFwcGVucyB3aGVuIHRoZSBhZGRyZXNzIGJhciB1cmwgY2hhbmdlcywgYWthIGAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzYC5cblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHVzZSBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIGAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzYCBldmVudCxcblx0ICAgICAqIHBlcmZvcm0gc29tZSBjdXN0b20gbG9naWMgKHJvdXRlIHByb3RlY3Rpb24sIGF1dGgsIGNvbmZpZywgcmVkaXJlY3Rpb24sIGV0YykgYW5kIHRoZW4gZmluYWxseSBwcm9jZWVkXG5cdCAgICAgKiB3aXRoIHRoZSB0cmFuc2l0aW9uIGJ5IGNhbGxpbmcgYCR1cmxSb3V0ZXIuc3luYygpYC5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogPHByZT5cblx0ICAgICAqIGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKVxuXHQgICAgICogICAucnVuKGZ1bmN0aW9uKCRyb290U2NvcGUsICR1cmxSb3V0ZXIpIHtcblx0ICAgICAqICAgICAkcm9vdFNjb3BlLiRvbignJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uKGV2dCkge1xuXHQgICAgICogICAgICAgLy8gSGFsdCBzdGF0ZSBjaGFuZ2UgZnJvbSBldmVuIHN0YXJ0aW5nXG5cdCAgICAgKiAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAqICAgICAgIC8vIFBlcmZvcm0gY3VzdG9tIGxvZ2ljXG5cdCAgICAgKiAgICAgICB2YXIgbWVldHNSZXF1aXJlbWVudCA9IC4uLlxuXHQgICAgICogICAgICAgLy8gQ29udGludWUgd2l0aCB0aGUgdXBkYXRlIGFuZCBzdGF0ZSB0cmFuc2l0aW9uIGlmIGxvZ2ljIGFsbG93c1xuXHQgICAgICogICAgICAgaWYgKG1lZXRzUmVxdWlyZW1lbnQpICR1cmxSb3V0ZXIuc3luYygpO1xuXHQgICAgICogICAgIH0pO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiA8L3ByZT5cblx0ICAgICAqL1xuXHQgICAgVXJsUm91dGVyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHVwZGF0ZSh0aGlzLnVybFJvdXRlclByb3ZpZGVyLnJ1bGVzLCB0aGlzLnVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZUZuKTtcblx0ICAgIH07XG5cdCAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyID0gdGhpcy5saXN0ZW5lciB8fCAkbG9jYXRpb24ub25DaGFuZ2UoZnVuY3Rpb24gKGV2dCkgeyByZXR1cm4gdXBkYXRlKF90aGlzLnVybFJvdXRlclByb3ZpZGVyLnJ1bGVzLCBfdGhpcy51cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2VGbiwgZXZ0KTsgfSk7XG5cdCAgICB9O1xuXHQgICAgVXJsUm91dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocmVhZCkge1xuXHQgICAgICAgIGlmIChyZWFkKSB7XG5cdCAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSAkbG9jYXRpb24udXJsKCk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCRsb2NhdGlvbi51cmwoKSA9PT0gdGhpcy5sb2NhdGlvbilcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICRsb2NhdGlvbi51cmwodGhpcy5sb2NhdGlvbik7XG5cdCAgICAgICAgJGxvY2F0aW9uLnJlcGxhY2UoKTtcblx0ICAgIH07XG5cdCAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgJGxvY2F0aW9uLnVybCh1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pKTtcblx0ICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpXG5cdCAgICAgICAgICAgICRsb2NhdGlvbi5yZXBsYWNlKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBAbmdkb2MgZnVuY3Rpb25cblx0ICAgICAqIEBuYW1lIHVpLnJvdXRlci5yb3V0ZXIuJHVybFJvdXRlciNocmVmXG5cdCAgICAgKiBAbWV0aG9kT2YgdWkucm91dGVyLnJvdXRlci4kdXJsUm91dGVyXG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBBIFVSTCBnZW5lcmF0aW9uIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIGNvbXBpbGVkIFVSTCBmb3IgYSBnaXZlblxuXHQgICAgICoge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBgVXJsTWF0Y2hlcmB9LCBwb3B1bGF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICogPHByZT5cblx0ICAgICAqICRib2IgPSAkdXJsUm91dGVyLmhyZWYobmV3IFVybE1hdGNoZXIoXCIvYWJvdXQvOnBlcnNvblwiKSwge1xuXHQgICAgICogICBwZXJzb246IFwiYm9iXCJcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcblx0ICAgICAqIDwvcHJlPlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7VXJsTWF0Y2hlcn0gdXJsTWF0Y2hlciBUaGUgYFVybE1hdGNoZXJgIG9iamVjdCB3aGljaCBpcyB1c2VkIGFzIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgVVJMIHRvIGdlbmVyYXRlLlxuXHQgICAgICogQHBhcmFtIHtvYmplY3Q9fSBwYXJhbXMgQW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMgdG8gZmlsbCB0aGUgbWF0Y2hlcidzIHJlcXVpcmVkIHBhcmFtZXRlcnMuXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcblx0ICAgICAqXG5cdCAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bGx5IGNvbXBpbGVkIFVSTCwgb3IgYG51bGxgIGlmIGBwYXJhbXNgIGZhaWwgdmFsaWRhdGlvbiBhZ2FpbnN0IGB1cmxNYXRjaGVyYFxuXHQgICAgICovXG5cdCAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmhyZWYgPSBmdW5jdGlvbiAodXJsTWF0Y2hlciwgcGFyYW1zLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKCF1cmxNYXRjaGVyLnZhbGlkYXRlcyhwYXJhbXMpKVxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcblx0ICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgICAgICB2YXIgY2ZnID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMubG9jYXRpb25Db25maWc7XG5cdCAgICAgICAgdmFyIGlzSHRtbDUgPSBjZmcuaHRtbDVNb2RlKCk7XG5cdCAgICAgICAgaWYgKCFpc0h0bWw1ICYmIHVybCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB1cmwgPSBcIiNcIiArIGNmZy5oYXNoUHJlZml4KCkgKyB1cmw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHVybCA9IGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgb3B0aW9ucy5hYnNvbHV0ZSk7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zLmFic29sdXRlIHx8ICF1cmwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHVybDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNsYXNoID0gKCFpc0h0bWw1ICYmIHVybCA/ICcvJyA6ICcnKSwgcG9ydCA9IGNmZy5wb3J0KCk7XG5cdCAgICAgICAgcG9ydCA9IChwb3J0ID09PSA4MCB8fCBwb3J0ID09PSA0NDMgPyAnJyA6ICc6JyArIHBvcnQpO1xuXHQgICAgICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVXJsUm91dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcblxuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRmdW5jdGlvbiBfX2V4cG9ydChtKSB7XG5cdCAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG5cdH1cblx0LyoqIEBtb2R1bGUgdmlldyAqLyAvKiogZm9yIHR5cGVkb2MgKi9cblx0X19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MCkpO1xuXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKiBAbW9kdWxlIHZpZXcgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBob2ZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgbW9kdWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgbWF0Y2ggPSBmdW5jdGlvbiAob2JqMSkge1xuXHQgICAgdmFyIGtleXMgPSBbXTtcblx0ICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAga2V5c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmdW5jdGlvbiAob2JqMikgeyByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSkgeyByZXR1cm4gbWVtbyAmJiBvYmoxW2tleV0gPT09IG9iajJba2V5XTsgfSwgdHJ1ZSk7IH07XG5cdH07XG5cdC8qKlxuXHQgKiBUaGUgVmlldyBzZXJ2aWNlXG5cdCAqL1xuXHR2YXIgVmlld1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVmlld1NlcnZpY2UoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0aGlzLnVpVmlld3MgPSBbXTtcblx0ICAgICAgICB0aGlzLnZpZXdDb25maWdzID0gW107XG5cdCAgICAgICAgdGhpcy5fdmlld0NvbmZpZ0ZhY3RvcmllcyA9IHt9O1xuXHQgICAgICAgIHRoaXMuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHVpVmlld3NCeUZxbiA9IF90aGlzLnVpVmlld3MubWFwKGZ1bmN0aW9uICh1aXYpIHsgcmV0dXJuIFt1aXYuZnFuLCB1aXZdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogR2l2ZW4gYSB1aS12aWV3IGFuZCBhIFZpZXdDb25maWcsIGRldGVybWluZXMgaWYgdGhleSBcIm1hdGNoXCIuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEEgdWktdmlldyBoYXMgYSBmdWxseSBxdWFsaWZpZWQgbmFtZSAoZnFuKSBhbmQgYSBjb250ZXh0IG9iamVjdC4gIFRoZSBmcW4gaXMgYnVpbHQgZnJvbSBpdHMgb3ZlcmFsbCBsb2NhdGlvbiBpblxuXHQgICAgICAgICAgICAgKiB0aGUgRE9NLCBkZXNjcmliaW5nIGl0cyBuZXN0aW5nIHJlbGF0aW9uc2hpcCB0byBhbnkgcGFyZW50IHVpLXZpZXcgdGFncyBpdCBpcyBuZXN0ZWQgaW5zaWRlIG9mLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBBIFZpZXdDb25maWcgaGFzIGEgdGFyZ2V0IHVpLXZpZXcgbmFtZSBhbmQgYSBjb250ZXh0IGFuY2hvci4gIFRoZSB1aS12aWV3IG5hbWUgY2FuIGJlIGEgc2ltcGxlIG5hbWUsIG9yXG5cdCAgICAgICAgICAgICAqIGNhbiBiZSBhIHNlZ21lbnRlZCB1aS12aWV3IHBhdGgsIGRlc2NyaWJpbmcgYSBwb3J0aW9uIG9mIGEgdWktdmlldyBmcW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIElmIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IHVpLXZpZXcgbmFtZSBpcyBhIHNpbXBsZSBuYW1lIChubyBkb3RzKSwgdGhlbiBhIHVpLXZpZXcgbWF0Y2hlcyBpZjpcblx0ICAgICAgICAgICAgICogLSB0aGUgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG5cdCAgICAgICAgICAgICAqIC0gdGhlIHVpLXZpZXcncyBjb250ZXh0IG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3Jcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2VnbWVudGVkIG5hbWUgKHdpdGggZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XG5cdCAgICAgICAgICAgICAqIC0gVGhlcmUgZXhpc3RzIGEgcGFyZW50IHVpLXZpZXcgd2hlcmU6XG5cdCAgICAgICAgICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgbmFtZSBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IChpbmRleCAwKSBvZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG5cdCAgICAgICAgICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXG5cdCAgICAgICAgICAgICAqIC0gQW5kIHRoZSByZW1haW5pbmcgc2VnbWVudHMgKGluZGV4IDEuLm4pIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWUgbWF0Y2ggdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogRXhhbXBsZTpcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogRE9NOlxuXHQgICAgICAgICAgICAgKiA8ZGl2IHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBjcmVhdGVkIGluIHRoZSByb290IGNvbnRleHQgKG5hbWU6IFwiXCIpIC0tPlxuXHQgICAgICAgICAgICAgKiAgIDxkaXYgdWktdmlldz1cImZvb1wiPiAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQVwiICAgICAgLS0+XG5cdCAgICAgICAgICAgICAqICAgICA8ZGl2IHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CXCIgICAgLS0+XG5cdCAgICAgICAgICAgICAqICAgICAgIDxkaXYgdWktdmlldz1cImJhclwiPiAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkIuQ1wiICAtLT5cblx0ICAgICAgICAgICAgICogICAgICAgPC9kaXY+XG5cdCAgICAgICAgICAgICAqICAgICA8L2Rpdj5cblx0ICAgICAgICAgICAgICogICA8L2Rpdj5cblx0ICAgICAgICAgICAgICogPC9kaXY+XG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIHVpVmlld3M6IFtcblx0ICAgICAgICAgICAgICogIHsgZnFuOiBcIiRkZWZhdWx0XCIsICAgICAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiXCIgfSB9LFxuXHQgICAgICAgICAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vXCIsICAgICAgICAgICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBXCIgfSB9LFxuXHQgICAgICAgICAgICAgKiAgeyBmcW46IFwiJGRlZmF1bHQuZm9vLiRkZWZhdWx0XCIsICAgICBjcmVhdGlvbkNvbnRleHQ6IHsgbmFtZTogXCJBLkJcIiB9IH1cblx0ICAgICAgICAgICAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiwgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CLkNcIiB9IH1cblx0ICAgICAgICAgICAgICogXVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBUaGVzZSBmb3VyIHZpZXcgY29uZmlncyBhbGwgbWF0Y2ggdGhlIHVpLXZpZXcgd2l0aCB0aGUgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIjpcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogLSBWaWV3Q29uZmlnMTogeyB1aVZpZXdOYW1lOiBcImJhclwiLCAgICAgICAgICAgICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBLkIuQ1wiIH1cblx0ICAgICAgICAgICAgICogLSBWaWV3Q29uZmlnMjogeyB1aVZpZXdOYW1lOiBcIiRkZWZhdWx0LmJhclwiLCAgICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBLkJcIiB9XG5cdCAgICAgICAgICAgICAqIC0gVmlld0NvbmZpZzM6IHsgdWlWaWV3TmFtZTogXCJmb28uJGRlZmF1bHQuYmFyXCIsICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQVwiIH1cblx0ICAgICAgICAgICAgICogLSBWaWV3Q29uZmlnNDogeyB1aVZpZXdOYW1lOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiwgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJcIiB9XG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIFVzaW5nIFZpZXdDb25maWczIGFzIGFuIGV4YW1wbGUsIGl0IG1hdGNoZXMgdGhlIHVpLXZpZXcgd2l0aCBmcW4gXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIgYmVjYXVzZTpcblx0ICAgICAgICAgICAgICogLSBUaGUgVmlld0NvbmZpZydzIHNlZ21lbnRlZCB0YXJnZXQgbmFtZSBpczogWyBcImZvb1wiLCBcIiRkZWZhdWx0XCIsIFwiYmFyXCIgXVxuXHQgICAgICAgICAgICAgKiAtIFRoZXJlIGV4aXN0cyBhIHBhcmVudCB1aS12aWV3ICh3aGljaCBoYXMgZnFuOiBcIiRkZWZhdWx0LmZvb1wiKSB3aGVyZTpcblx0ICAgICAgICAgICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBuYW1lIFwiZm9vXCIgbWF0Y2hlcyB0aGUgZmlyc3Qgc2VnbWVudCBcImZvb1wiIG9mIHRoZSBWaWV3Q29uZmlnJ3MgdGFyZ2V0IG5hbWVcblx0ICAgICAgICAgICAgICogICAgLSB0aGUgcGFyZW50IHVpLXZpZXcncyBjb250ZXh0IFwiQVwiIG1hdGNoZXMgdGhlIFZpZXdDb25maWcncyBhbmNob3IgY29udGV4dCBcIkFcIlxuXHQgICAgICAgICAgICAgKiAtIEFuZCB0aGUgcmVtYWluaW5nIHNlZ21lbnRzIFsgXCIkZGVmYXVsdFwiLCBcImJhclwiIF0uam9pbihcIi5cIl8gb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZSBtYXRjaFxuXHQgICAgICAgICAgICAgKiAgIHRoZSB0YWlsIG9mIHRoZSB1aS12aWV3J3MgZnFuIFwiZGVmYXVsdC5iYXJcIlxuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAodWlWaWV3KSB7IHJldHVybiBmdW5jdGlvbiAodmlld0NvbmZpZykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3BsaXQgbmFtZXMgYXBhcnQgZnJvbSBib3RoIHZpZXdDb25maWcgYW5kIHVpVmlldyBpbnRvIHNlZ21lbnRzXG5cdCAgICAgICAgICAgICAgICB2YXIgdmMgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZjU2VnbWVudHMgPSB2Yy4kdWlWaWV3TmFtZS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgdWl2U2VnbWVudHMgPSB1aVZpZXcuZnFuLnNwbGl0KFwiLlwiKTtcblx0ICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0YWlscyBvZiB0aGUgc2VnbWVudCBhcnJheXMgbWF0Y2guIGV4LCB0aGVzZSBhcnJheXMnIHRhaWxzIG1hdGNoOlxuXHQgICAgICAgICAgICAgICAgLy8gdmM6IFtcImZvb1wiLCBcImJhclwiXSwgdWl2IGZxbjogW1wiJGRlZmF1bHRcIiwgXCJmb29cIiwgXCJiYXJcIl1cblx0ICAgICAgICAgICAgICAgIGlmICghY29tbW9uXzEuZXF1YWxzKHZjU2VnbWVudHMsIHVpdlNlZ21lbnRzLnNsaWNlKDAgLSB2Y1NlZ21lbnRzLmxlbmd0aCkpKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZnFuIGVuZGluZyBhdCB0aGUgZmlyc3Qgc2VnbWVudCBvZiB0aGUgdmlld0NvbmZpZyBtYXRjaGVzIHRoZSBjb250ZXh0OlxuXHQgICAgICAgICAgICAgICAgLy8gW1wiJGRlZmF1bHRcIiwgXCJmb29cIl0uam9pbihcIi5cIikgPT0gXCIkZGVmYXVsdC5mb29cIiwgZG9lcyB0aGUgdWktdmlldyAkZGVmYXVsdC5mb28gY29udGV4dCBtYXRjaD9cblx0ICAgICAgICAgICAgICAgIHZhciBuZWdPZmZzZXQgPSAoMSAtIHZjU2VnbWVudHMubGVuZ3RoKSB8fCB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnFuVG9GaXJzdFNlZ21lbnQgPSB1aXZTZWdtZW50cy5zbGljZSgwLCBuZWdPZmZzZXQpLmpvaW4oXCIuXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHVpVmlld0NvbnRleHQgPSB1aVZpZXdzQnlGcW5bZnFuVG9GaXJzdFNlZ21lbnRdLmNyZWF0aW9uQ29udGV4dDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2Yy4kdWlWaWV3Q29udGV4dEFuY2hvciA9PT0gKHVpVmlld0NvbnRleHQgJiYgdWlWaWV3Q29udGV4dC5uYW1lKTtcblx0ICAgICAgICAgICAgfTsgfTtcblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZG90cyBpbiB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWVcblx0ICAgICAgICAgICAgZnVuY3Rpb24gdWlWaWV3RGVwdGgodWlWaWV3KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdWlWaWV3LmZxbi5zcGxpdChcIi5cIikubGVuZ3RoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFJldHVybiB0aGUgVmlld0NvbmZpZydzIGNvbnRleHQncyBkZXB0aCBpbiB0aGUgY29udGV4dCB0cmVlLlxuXHQgICAgICAgICAgICBmdW5jdGlvbiB2aWV3Q29uZmlnRGVwdGgoY29uZmlnKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGNvbmZpZy52aWV3RGVjbC4kY29udGV4dCwgY291bnQgPSAwO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKCsrY291bnQgJiYgY29udGV4dC5wYXJlbnQpXG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEdpdmVuIGEgZGVwdGggZnVuY3Rpb24sIHJldHVybnMgYSBjb21wYXJlIGZ1bmN0aW9uIHdoaWNoIGNhbiByZXR1cm4gZWl0aGVyIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyXG5cdCAgICAgICAgICAgIHZhciBkZXB0aENvbXBhcmUgPSBob2ZfMS5jdXJyeShmdW5jdGlvbiAoZGVwdGhGbiwgcG9zTmVnLCBsZWZ0LCByaWdodCkgeyByZXR1cm4gcG9zTmVnICogKGRlcHRoRm4obGVmdCkgLSBkZXB0aEZuKHJpZ2h0KSk7IH0pO1xuXHQgICAgICAgICAgICB2YXIgbWF0Y2hpbmdDb25maWdQYWlyID0gZnVuY3Rpb24gKHVpVmlldykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nQ29uZmlncyA9IF90aGlzLnZpZXdDb25maWdzLmZpbHRlcihtYXRjaGVzKHVpVmlldykpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlncy5sZW5ndGggPiAxKVxuXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nQ29uZmlncy5zb3J0KGRlcHRoQ29tcGFyZSh2aWV3Q29uZmlnRGVwdGgsIC0xKSk7IC8vIGRlc2NlbmRpbmdcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbdWlWaWV3LCBtYXRjaGluZ0NvbmZpZ3NbMF1dO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgY29uZmlndXJlVWlWaWV3ID0gZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdWlWaWV3ID0gX2FbMF0sIHZpZXdDb25maWcgPSBfYVsxXTtcblx0ICAgICAgICAgICAgICAgIC8vIElmIGEgcGFyZW50IHVpLXZpZXcgaXMgcmVjb25maWd1cmVkLCBpdCBjb3VsZCBkZXN0cm95IGNoaWxkIHVpLXZpZXdzLlxuXHQgICAgICAgICAgICAgICAgLy8gQmVmb3JlIGNvbmZpZ3VyaW5nIGEgY2hpbGQgdWktdmlldywgbWFrZSBzdXJlIGl0J3Mgc3RpbGwgaW4gdGhlIGFjdGl2ZSB1aVZpZXdzIGFycmF5LlxuXHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLnVpVmlld3MuaW5kZXhPZih1aVZpZXcpICE9PSAtMSlcblx0ICAgICAgICAgICAgICAgICAgICB1aVZpZXcuY29uZmlnVXBkYXRlZCh2aWV3Q29uZmlnKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3RoaXMudWlWaWV3cy5zb3J0KGRlcHRoQ29tcGFyZSh1aVZpZXdEZXB0aCwgMSkpLm1hcChtYXRjaGluZ0NvbmZpZ1BhaXIpLmZvckVhY2goY29uZmlndXJlVWlWaWV3KTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgVmlld1NlcnZpY2UucHJvdG90eXBlLnJvb3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcm9vdENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuX3Jvb3RDb250ZXh0O1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS52aWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZmFjdG9yeSkge1xuXHQgICAgICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXNbdmlld1R5cGVdID0gZmFjdG9yeTtcblx0ICAgIH07XG5cdCAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuY3JlYXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uIChub2RlLCBkZWNsKSB7XG5cdCAgICAgICAgdmFyIGNmZ0ZhY3RvcnkgPSB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW2RlY2wuJHR5cGVdO1xuXHQgICAgICAgIGlmICghY2ZnRmFjdG9yeSlcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld1NlcnZpY2U6IE5vIHZpZXcgY29uZmlnIGZhY3RvcnkgcmVnaXN0ZXJlZCBmb3IgdHlwZSBcIiArIGRlY2wuJHR5cGUpO1xuXHQgICAgICAgIHJldHVybiBjZmdGYWN0b3J5KG5vZGUsIGRlY2wpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogRGUtcmVnaXN0ZXJzIGEgVmlld0NvbmZpZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0gdmlld0NvbmZpZyBUaGUgVmlld0NvbmZpZyB2aWV3IHRvIGRlcmVnaXN0ZXIuXG5cdCAgICAgKi9cblx0ICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5kZWFjdGl2YXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG5cdCAgICAgICAgbW9kdWxlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZUV2ZW50KFwiPC0gUmVtb3ZpbmdcIiwgdmlld0NvbmZpZyk7XG5cdCAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLnZpZXdDb25maWdzLCB2aWV3Q29uZmlnKTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcblx0ICAgICAgICBtb2R1bGVfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoXCItPiBSZWdpc3RlcmluZ1wiLCB2aWV3Q29uZmlnKTtcblx0ICAgICAgICB0aGlzLnZpZXdDb25maWdzLnB1c2godmlld0NvbmZpZyk7XG5cdCAgICB9O1xuXHQgICAgO1xuXHQgICAgLyoqXG5cdCAgICAgKiBBbGxvd3MgYSBgdWktdmlld2AgZWxlbWVudCB0byByZWdpc3RlciBpdHMgY2Fub25pY2FsIG5hbWUgd2l0aCBhIGNhbGxiYWNrIHRoYXQgYWxsb3dzIGl0IHRvXG5cdCAgICAgKiBiZSB1cGRhdGVkIHdpdGggYSB0ZW1wbGF0ZSwgY29udHJvbGxlciwgYW5kIGxvY2FsIHZhcmlhYmxlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgb2YgdGhlIGB1aS12aWV3YCBvYmplY3QgYmVpbmcgcmVnaXN0ZXJlZC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdXBkYXRlcyB0byB0aGUgY29udGVudCAmIGNvbmZpZ3VyYXRpb25cblx0ICAgICAqICAgICAgICAgICAgICAgICAgIG9mIHRoZSB2aWV3LlxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgYSBkZS1yZWdpc3RyYXRpb24gZnVuY3Rpb24gdXNlZCB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cblx0ICAgICAqL1xuXHQgICAgVmlld1NlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyVWlWaWV3ID0gZnVuY3Rpb24gKHVpVmlldykge1xuXHQgICAgICAgIG1vZHVsZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVaVZpZXdFdmVudChcIi0+IFJlZ2lzdGVyaW5nXCIsIHVpVmlldyk7XG5cdCAgICAgICAgdmFyIHVpVmlld3MgPSB0aGlzLnVpVmlld3M7XG5cdCAgICAgICAgdmFyIGZxbk1hdGNoZXMgPSBmdW5jdGlvbiAodWl2KSB7IHJldHVybiB1aXYuZnFuID09PSB1aVZpZXcuZnFuOyB9O1xuXHQgICAgICAgIGlmICh1aVZpZXdzLmZpbHRlcihmcW5NYXRjaGVzKS5sZW5ndGgpXG5cdCAgICAgICAgICAgIG1vZHVsZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVaVZpZXdFdmVudChcIiEhISEgZHVwbGljYXRlIHVpVmlldyBuYW1lZDpcIiwgdWlWaWV3KTtcblx0ICAgICAgICB1aVZpZXdzLnB1c2godWlWaWV3KTtcblx0ICAgICAgICB0aGlzLnN5bmMoKTtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gdWlWaWV3cy5pbmRleE9mKHVpVmlldyk7XG5cdCAgICAgICAgICAgIGlmIChpZHggPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgbW9kdWxlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVpVmlld0V2ZW50KFwiVHJpZWQgcmVtb3Zpbmcgbm9uLXJlZ2lzdGVyZWQgdWlWaWV3XCIsIHVpVmlldyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbW9kdWxlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVpVmlld0V2ZW50KFwiPC0gRGVyZWdpc3RlcmluZ1wiLCB1aVZpZXcpO1xuXHQgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHVpVmlld3MpKHVpVmlldyk7XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygdmlld3MgY3VycmVudGx5IGF2YWlsYWJsZSBvbiB0aGUgcGFnZSwgYnkgZnVsbHktcXVhbGlmaWVkIG5hbWUuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZnVsbHktcXVhbGlmaWVkIHZpZXcgbmFtZXMuXG5cdCAgICAgKi9cblx0ICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudWlWaWV3cy5tYXAoaG9mXzEucHJvcChcImZxblwiKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIG9uIHRoZSBwYWdlIGNvbnRhaW5pbmcgbG9hZGVkIGNvbnRlbnQuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgZnVsbHktcXVhbGlmaWVkIHZpZXcgbmFtZXMuXG5cdCAgICAgKi9cblx0ICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudWlWaWV3cy5maWx0ZXIoaG9mXzEucHJvcChcIiRjb25maWdcIikpLm1hcChob2ZfMS5wcm9wKFwibmFtZVwiKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBOb3JtYWxpemVzIGEgdmlldydzIG5hbWUgZnJvbSBhIHN0YXRlLnZpZXdzIGNvbmZpZ3VyYXRpb24gYmxvY2suXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIGNvbnRleHQgdGhlIGNvbnRleHQgb2JqZWN0IChzdGF0ZSBkZWNsYXJhdGlvbikgdGhhdCB0aGUgdmlldyBiZWxvbmdzIHRvXG5cdCAgICAgKiBAcGFyYW0gcmF3Vmlld05hbWUgdGhlIG5hbWUgb2YgdGhlIHZpZXcsIGFzIGRlY2xhcmVkIGluIHRoZSBbW1N0YXRlRGVjbGFyYXRpb24udmlld3NdXVxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm5zIHRoZSBub3JtYWxpemVkIHVpVmlld05hbWUgYW5kIHVpVmlld0NvbnRleHRBbmNob3IgdGhhdCB0aGUgdmlldyB0YXJnZXRzXG5cdCAgICAgKi9cblx0ICAgIFZpZXdTZXJ2aWNlLm5vcm1hbGl6ZVVpVmlld1RhcmdldCA9IGZ1bmN0aW9uIChjb250ZXh0LCByYXdWaWV3TmFtZSkge1xuXHQgICAgICAgIGlmIChyYXdWaWV3TmFtZSA9PT0gdm9pZCAwKSB7IHJhd1ZpZXdOYW1lID0gXCJcIjsgfVxuXHQgICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIGluY29taW5nIHZpZXcgbmFtZSB3aXRoIGEgcmVnZXhwIHRvIGFsbG93OlxuXHQgICAgICAgIC8vIGV4OiBcInZpZXcubmFtZUBmb28uYmFyXCIgLCBcIl4uXi52aWV3Lm5hbWVcIiAsIFwidmlldy5uYW1lQF4uXlwiICwgXCJcIiAsXG5cdCAgICAgICAgLy8gXCJAXCIgLCBcIiRkZWZhdWx0QF5cIiAsIFwiISRkZWZhdWx0LiRkZWZhdWx0XCIgLCBcIiFmb28uYmFyXCJcblx0ICAgICAgICB2YXIgdmlld0F0Q29udGV4dCA9IHJhd1ZpZXdOYW1lLnNwbGl0KFwiQFwiKTtcblx0ICAgICAgICB2YXIgdWlWaWV3TmFtZSA9IHZpZXdBdENvbnRleHRbMF0gfHwgXCIkZGVmYXVsdFwiOyAvLyBkZWZhdWx0IHRvIHVubmFtZWQgdmlld1xuXHQgICAgICAgIHZhciB1aVZpZXdDb250ZXh0QW5jaG9yID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHZpZXdBdENvbnRleHRbMV0pID8gdmlld0F0Q29udGV4dFsxXSA6IFwiXlwiOyAvLyBkZWZhdWx0IHRvIHBhcmVudCBjb250ZXh0XG5cdCAgICAgICAgLy8gSGFuZGxlIHJlbGF0aXZlIHZpZXctbmFtZSBzdWdhciBzeW50YXguXG5cdCAgICAgICAgLy8gTWF0Y2hlcyByYXdWaWV3TmFtZSBcIl4uXi5eLmZvby5iYXJcIiBpbnRvIGFycmF5OiBbXCJeLl4uXi5mb28uYmFyXCIsIFwiXi5eLl5cIiwgXCJmb28uYmFyXCJdLFxuXHQgICAgICAgIHZhciByZWxhdGl2ZVZpZXdOYW1lU3VnYXIgPSAvXihcXF4oPzpcXC5cXF4pKilcXC4oLiokKS8uZXhlYyh1aVZpZXdOYW1lKTtcblx0ICAgICAgICBpZiAocmVsYXRpdmVWaWV3TmFtZVN1Z2FyKSB7XG5cdCAgICAgICAgICAgIC8vIENsb2JiZXJzIGV4aXN0aW5nIGNvbnRleHRBbmNob3IgKHJhd1ZpZXdOYW1lIHZhbGlkYXRpb24gd2lsbCBmaXggdGhpcylcblx0ICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IHJlbGF0aXZlVmlld05hbWVTdWdhclsxXTsgLy8gc2V0IGFuY2hvciB0byBcIl4uXi5eXCJcblx0ICAgICAgICAgICAgdWlWaWV3TmFtZSA9IHJlbGF0aXZlVmlld05hbWVTdWdhclsyXTsgLy8gc2V0IHZpZXctbmFtZSB0byBcImZvby5iYXJcIlxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodWlWaWV3TmFtZS5jaGFyQXQoMCkgPT09ICchJykge1xuXHQgICAgICAgICAgICB1aVZpZXdOYW1lID0gdWlWaWV3TmFtZS5zdWJzdHIoMSk7XG5cdCAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBcIlwiOyAvLyB0YXJnZXQgYWJzb2x1dGVseSBmcm9tIHJvb3Rcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaGFuZGxlIHBhcmVudCByZWxhdGl2ZSB0YXJnZXRpbmcgXCJeLl4uXlwiXG5cdCAgICAgICAgdmFyIHJlbGF0aXZlTWF0Y2ggPSAvXihcXF4oPzpcXC5cXF4pKikkLztcblx0ICAgICAgICBpZiAocmVsYXRpdmVNYXRjaC5leGVjKHVpVmlld0NvbnRleHRBbmNob3IpKSB7XG5cdCAgICAgICAgICAgIHZhciBhbmNob3IgPSB1aVZpZXdDb250ZXh0QW5jaG9yLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKGZ1bmN0aW9uIChhbmNob3IsIHgpIHsgcmV0dXJuIGFuY2hvci5wYXJlbnQ7IH0pLCBjb250ZXh0KTtcblx0ICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvciA9IGFuY2hvci5uYW1lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4geyB1aVZpZXdOYW1lOiB1aVZpZXdOYW1lLCB1aVZpZXdDb250ZXh0QW5jaG9yOiB1aVZpZXdDb250ZXh0QW5jaG9yIH07XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFZpZXdTZXJ2aWNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlZpZXdTZXJ2aWNlID0gVmlld1NlcnZpY2U7XG5cblxuLyoqKi8gfSxcbi8qIDUxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgY29yZSAqLyAvKiogKi9cblx0dmFyIHVybE1hdGNoZXJGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblx0dmFyIHVybFJvdXRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG5cdHZhciBzdGF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdHZhciB1cmxSb3V0ZXJfMiA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXHR2YXIgdHJhbnNpdGlvblNlcnZpY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXHR2YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cdHZhciBzdGF0ZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblx0dmFyIHN0YXRlU2VydmljZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdHZhciBnbG9iYWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblx0LyoqXG5cdCAqIFRoZSBtYXN0ZXIgY2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZiBVSS1Sb3V0ZXIuXG5cdCAqXG5cdCAqIFRoaXMgY2xhc3MgaW5zdGFudGlhdGVzIGFuZCB3aXJlcyB0aGUgZ2xvYmFsIFVJLVJvdXRlciBzZXJ2aWNlcy5cblx0ICpcblx0ICogQWZ0ZXIgaW5zdGFudGlhdGluZyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUm91dGVyIGNsYXNzLCBjb25maWd1cmUgaXQgZm9yIHlvdXIgYXBwLiAgRm9yIGluc3RhbmNlLCByZWdpc3RlclxuXHQgKiB5b3VyIGFwcCBzdGF0ZXMgd2l0aCB0aGUgW1tzdGF0ZVJlZ2lzdHJ5XV0gKGFuZCBzZXQgdXJsIG9wdGlvbnMgdXNpbmcgLi4uKS4gIFRoZW4sIHRlbGwgVUktUm91dGVyIHRvIG1vbml0b3Jcblx0ICogdGhlIFVSTCBieSBjYWxsaW5nIGB1cmxSb3V0ZXIubGlzdGVuKClgIChbW1VSTFJvdXRlci5saXN0ZW5dXSlcblx0ICovXG5cdHZhciBVSVJvdXRlciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBVSVJvdXRlcigpIHtcblx0ICAgICAgICB0aGlzLnZpZXdTZXJ2aWNlID0gbmV3IHZpZXdfMS5WaWV3U2VydmljZSgpO1xuXHQgICAgICAgIHRoaXMudHJhbnNpdGlvblNlcnZpY2UgPSBuZXcgdHJhbnNpdGlvblNlcnZpY2VfMS5UcmFuc2l0aW9uU2VydmljZSh0aGlzLnZpZXdTZXJ2aWNlKTtcblx0ICAgICAgICB0aGlzLmdsb2JhbHMgPSBuZXcgZ2xvYmFsc18xLlVJUm91dGVyR2xvYmFscyh0aGlzLnRyYW5zaXRpb25TZXJ2aWNlKTtcblx0ICAgICAgICB0aGlzLnVybE1hdGNoZXJGYWN0b3J5ID0gbmV3IHVybE1hdGNoZXJGYWN0b3J5XzEuVXJsTWF0Y2hlckZhY3RvcnkoKTtcblx0ICAgICAgICB0aGlzLnVybFJvdXRlclByb3ZpZGVyID0gbmV3IHVybFJvdXRlcl8xLlVybFJvdXRlclByb3ZpZGVyKHRoaXMudXJsTWF0Y2hlckZhY3RvcnksIHRoaXMuZ2xvYmFscy5wYXJhbXMpO1xuXHQgICAgICAgIHRoaXMudXJsUm91dGVyID0gbmV3IHVybFJvdXRlcl8yLlVybFJvdXRlcih0aGlzLnVybFJvdXRlclByb3ZpZGVyKTtcblx0ICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBuZXcgc3RhdGVSZWdpc3RyeV8xLlN0YXRlUmVnaXN0cnkodGhpcy51cmxNYXRjaGVyRmFjdG9yeSwgdGhpcy51cmxSb3V0ZXJQcm92aWRlcik7XG5cdCAgICAgICAgLyoqIEBoaWRkZW4gVE9ETzogbW92ZSB0aGlzIHRvIG5nMS50cyAqL1xuXHQgICAgICAgIHRoaXMuc3RhdGVQcm92aWRlciA9IG5ldyBzdGF0ZV8xLlN0YXRlUHJvdmlkZXIodGhpcy5zdGF0ZVJlZ2lzdHJ5KTtcblx0ICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IG5ldyBzdGF0ZVNlcnZpY2VfMS5TdGF0ZVNlcnZpY2UodGhpcy52aWV3U2VydmljZSwgdGhpcy51cmxSb3V0ZXIsIHRoaXMudHJhbnNpdGlvblNlcnZpY2UsIHRoaXMuc3RhdGVSZWdpc3RyeSwgdGhpcy5zdGF0ZVByb3ZpZGVyLCB0aGlzLmdsb2JhbHMpO1xuXHQgICAgICAgIHRoaXMudmlld1NlcnZpY2Uucm9vdENvbnRleHQodGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSk7XG5cdCAgICAgICAgdGhpcy5nbG9iYWxzLiRjdXJyZW50ID0gdGhpcy5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKTtcblx0ICAgICAgICB0aGlzLmdsb2JhbHMuY3VycmVudCA9IHRoaXMuZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFVJUm91dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlVJUm91dGVyID0gVUlSb3V0ZXI7XG5cblxuLyoqKi8gfSxcbi8qIDUyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIEBtb2R1bGUgY29yZSAqLyAvKiogKi9cblx0dmFyIHN0YXRlUGFyYW1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblx0dmFyIHF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHQvKipcblx0ICogR2xvYmFsIG11dGFibGUgc3RhdGVcblx0ICpcblx0ICogVGhpcyBpcyB3aGVyZSB3ZSBob2xkIHRoZSBnbG9iYWwgbXV0YWJsZSBzdGF0ZSBzdWNoIGFzIGN1cnJlbnQgc3RhdGUsIGN1cnJlbnRcblx0ICogcGFyYW1zLCBjdXJyZW50IHRyYW5zaXRpb24sIGxhc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uLCBsYXN0IGF0dGVtcHRlZCB0cmFuc2l0aW9uLCBldGMuXG5cdCAqL1xuXHR2YXIgVUlSb3V0ZXJHbG9iYWxzID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFVJUm91dGVyR2xvYmFscyh0cmFuc2l0aW9uU2VydmljZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBuZXcgc3RhdGVQYXJhbXNfMS5TdGF0ZVBhcmFtcygpO1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFRoZSB0cmFuc2l0aW9uIGhpc3Rvcnlcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgcXVldWUncyBzaXplIGlzIGxpbWl0ZWQgdG8gYSBtYXhpbXVtIG51bWJlciAoZGVmYXVsdDogMSlcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLnRyYW5zaXRpb25IaXN0b3J5ID0gbmV3IHF1ZXVlXzEuUXVldWUoW10sIDEpO1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFRoZSBoaXN0b3J5IG9mIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbnNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgcXVldWUncyBzaXplIGlzIGxpbWl0ZWQgdG8gYSBtYXhpbXVtIG51bWJlciAoZGVmYXVsdDogMSlcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucyA9IG5ldyBxdWV1ZV8xLlF1ZXVlKFtdLCAxKTtcblx0ICAgICAgICB2YXIgYmVmb3JlTmV3VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgkdHJhbnNpdGlvbiQpIHtcblx0ICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbiA9ICR0cmFuc2l0aW9uJDtcblx0ICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbkhpc3RvcnkuZW5xdWV1ZSgkdHJhbnNpdGlvbiQpO1xuXHQgICAgICAgICAgICB2YXIgdXBkYXRlR2xvYmFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMuZW5xdWV1ZSgkdHJhbnNpdGlvbiQpO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuJGN1cnJlbnQgPSAkdHJhbnNpdGlvbiQuJHRvKCk7XG5cdCAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50ID0gX3RoaXMuJGN1cnJlbnQuc2VsZjtcblx0ICAgICAgICAgICAgICAgIGNvbW1vbl8xLmNvcHkoJHRyYW5zaXRpb24kLnBhcmFtcygpLCBfdGhpcy5wYXJhbXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAkdHJhbnNpdGlvbiQub25TdWNjZXNzKHt9LCB1cGRhdGVHbG9iYWxTdGF0ZSwgeyBwcmlvcml0eTogMTAwMDAgfSk7XG5cdCAgICAgICAgICAgIHZhciBjbGVhckN1cnJlbnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkgeyBpZiAoX3RoaXMudHJhbnNpdGlvbiA9PT0gJHRyYW5zaXRpb24kKVxuXHQgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbiA9IG51bGw7IH07XG5cdCAgICAgICAgICAgICR0cmFuc2l0aW9uJC5wcm9taXNlLnRoZW4oY2xlYXJDdXJyZW50VHJhbnNpdGlvbiwgY2xlYXJDdXJyZW50VHJhbnNpdGlvbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgWyckdHJhbnNpdGlvbiQnLCBiZWZvcmVOZXdUcmFuc2l0aW9uXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVUlSb3V0ZXJHbG9iYWxzO1xuXHR9KCkpO1xuXHRleHBvcnRzLlVJUm91dGVyR2xvYmFscyA9IFVJUm91dGVyR2xvYmFscztcblxuXG4vKioqLyB9LFxuLyogNTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiAjIFVJLVJvdXRlciBmb3IgQW5ndWxhciAxXG5cdCAqXG5cdCAqIC0gUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBbW0NvcmVTZXJ2aWNlc11dIEFQSSwgYmFzZWQgb24gYW5ndWxhciAxIHNlcnZpY2VzLlxuXHQgKiAtIEFsc28gcmVnaXN0ZXJzIHNvbWUgc2VydmljZXMgd2l0aCB0aGUgYW5ndWxhciAxIGluamVjdG9yLlxuXHQgKiAtIENyZWF0ZXMgYW5kIGJvb3RzdHJhcHMgYSBuZXcgW1tVSVJvdXRlcl1dIG9iamVjdC4gIFRpZXMgaXQgdG8gdGhlIHRoZSBhbmd1bGFyIDEgbGlmZWN5Y2xlLlxuXHQgKlxuXHQgKiBAbW9kdWxlIG5nMVxuXHQgKiBAcHJlZmVycmVkXG5cdCAqL1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqIGZvciB0eXBlZG9jICovXG5cdHZhciByb3V0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIG1vZHVsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cdHZhciBtb2R1bGVfMiA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXHR2YXIgbW9kdWxlXzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIHRyYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIHZpZXdzQnVpbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cdHZhciB0ZW1wbGF0ZUZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXHQvKiogQGhpZGRlbiAqL1xuXHR2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoXCJ1aS5yb3V0ZXIuYW5ndWxhcjFcIiwgW10pO1xuXHQvKipcblx0ICogQG5nZG9jIG92ZXJ2aWV3XG5cdCAqIEBuYW1lIHVpLnJvdXRlci51dGlsXG5cdCAqXG5cdCAqIEBkZXNjcmlwdGlvblxuXHQgKiAjIHVpLnJvdXRlci51dGlsIHN1Yi1tb2R1bGVcblx0ICpcblx0ICogVGhpcyBtb2R1bGUgaXMgYSBkZXBlbmRlbmN5IG9mIG90aGVyIHN1Yi1tb2R1bGVzLiBEbyBub3QgaW5jbHVkZSB0aGlzIG1vZHVsZSBhcyBhIGRlcGVuZGVuY3lcblx0ICogaW4geW91ciBhbmd1bGFyIGFwcCAodXNlIHtAbGluayB1aS5yb3V0ZXJ9IG1vZHVsZSBpbnN0ZWFkKS5cblx0ICpcblx0ICovXG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcsIFsnbmcnLCAndWkucm91dGVyLmluaXQnXSk7XG5cdC8qKlxuXHQgKiBAbmdkb2Mgb3ZlcnZpZXdcblx0ICogQG5hbWUgdWkucm91dGVyLnJvdXRlclxuXHQgKlxuXHQgKiBAcmVxdWlyZXMgdWkucm91dGVyLnV0aWxcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqICMgdWkucm91dGVyLnJvdXRlciBzdWItbW9kdWxlXG5cdCAqXG5cdCAqIFRoaXMgbW9kdWxlIGlzIGEgZGVwZW5kZW5jeSBvZiBvdGhlciBzdWItbW9kdWxlcy4gRG8gbm90IGluY2x1ZGUgdGhpcyBtb2R1bGUgYXMgYSBkZXBlbmRlbmN5XG5cdCAqIGluIHlvdXIgYW5ndWxhciBhcHAgKHVzZSB7QGxpbmsgdWkucm91dGVyfSBtb2R1bGUgaW5zdGVhZCkuXG5cdCAqL1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnJvdXRlcicsIFsndWkucm91dGVyLnV0aWwnXSk7XG5cdC8qKlxuXHQgKiBAbmdkb2Mgb3ZlcnZpZXdcblx0ICogQG5hbWUgdWkucm91dGVyLnN0YXRlXG5cdCAqXG5cdCAqIEByZXF1aXJlcyB1aS5yb3V0ZXIucm91dGVyXG5cdCAqIEByZXF1aXJlcyB1aS5yb3V0ZXIudXRpbFxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogIyB1aS5yb3V0ZXIuc3RhdGUgc3ViLW1vZHVsZVxuXHQgKlxuXHQgKiBUaGlzIG1vZHVsZSBpcyBhIGRlcGVuZGVuY3kgb2YgdGhlIG1haW4gdWkucm91dGVyIG1vZHVsZS4gRG8gbm90IGluY2x1ZGUgdGhpcyBtb2R1bGUgYXMgYSBkZXBlbmRlbmN5XG5cdCAqIGluIHlvdXIgYW5ndWxhciBhcHAgKHVzZSB7QGxpbmsgdWkucm91dGVyfSBtb2R1bGUgaW5zdGVhZCkuXG5cdCAqXG5cdCAqL1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcblx0LyoqXG5cdCAqIEBuZ2RvYyBvdmVydmlld1xuXHQgKiBAbmFtZSB1aS5yb3V0ZXJcblx0ICpcblx0ICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZVxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogIyB1aS5yb3V0ZXJcblx0ICpcblx0ICogIyMgVGhlIG1haW4gbW9kdWxlIGZvciB1aS5yb3V0ZXJcblx0ICogVGhlcmUgYXJlIHNldmVyYWwgc3ViLW1vZHVsZXMgaW5jbHVkZWQgd2l0aCB0aGUgdWkucm91dGVyIG1vZHVsZSwgaG93ZXZlciBvbmx5IHRoaXMgbW9kdWxlIGlzIG5lZWRlZFxuXHQgKiBhcyBhIGRlcGVuZGVuY3kgd2l0aGluIHlvdXIgYW5ndWxhciBhcHAuIFRoZSBvdGhlciBtb2R1bGVzIGFyZSBmb3Igb3JnYW5pemF0aW9uIHB1cnBvc2VzLlxuXHQgKlxuXHQgKiBUaGUgbW9kdWxlcyBhcmU6XG5cdCAqICogdWkucm91dGVyIC0gdGhlIG1haW4gXCJ1bWJyZWxsYVwiIG1vZHVsZVxuXHQgKiAqIHVpLnJvdXRlci5yb3V0ZXIgLVxuXHQgKlxuXHQgKiAqWW91J2xsIG5lZWQgdG8gaW5jbHVkZSAqKm9ubHkqKiB0aGlzIG1vZHVsZSBhcyB0aGUgZGVwZW5kZW5jeSB3aXRoaW4geW91ciBhbmd1bGFyIGFwcC4qXG5cdCAqXG5cdCAqIDxwcmU+XG5cdCAqIDwhZG9jdHlwZSBodG1sPlxuXHQgKiA8aHRtbCBuZy1hcHA9XCJteUFwcFwiPlxuXHQgKiA8aGVhZD5cblx0ICogICA8c2NyaXB0IHNyYz1cImpzL2FuZ3VsYXIuanNcIj48L3NjcmlwdD5cblx0ICogICA8IS0tIEluY2x1ZGUgdGhlIHVpLXJvdXRlciBzY3JpcHQgLS0+XG5cdCAqICAgPHNjcmlwdCBzcmM9XCJqcy9hbmd1bGFyLXVpLXJvdXRlci5taW4uanNcIj48L3NjcmlwdD5cblx0ICogICA8c2NyaXB0PlxuXHQgKiAgICAgLy8gLi4uYW5kIGFkZCAndWkucm91dGVyJyBhcyBhIGRlcGVuZGVuY3lcblx0ICogICAgIHZhciBteUFwcCA9IGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFsndWkucm91dGVyJ10pO1xuXHQgKiAgIDwvc2NyaXB0PlxuXHQgKiA8L2hlYWQ+XG5cdCAqIDxib2R5PlxuXHQgKiA8L2JvZHk+XG5cdCAqIDwvaHRtbD5cblx0ICogPC9wcmU+XG5cdCAqL1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuaW5pdCcsICd1aS5yb3V0ZXIuc3RhdGUnLCAndWkucm91dGVyLmFuZ3VsYXIxJ10pO1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLmNvbXBhdCcsIFsndWkucm91dGVyJ10pO1xuXHQvKipcblx0ICogQW5ub3RhdGVzIGEgY29udHJvbGxlciBleHByZXNzaW9uIChtYXkgYmUgYSBjb250cm9sbGVyIGZ1bmN0aW9uKCksIGEgXCJjb250cm9sbGVybmFtZVwiLFxuXHQgKiBvciBcImNvbnRyb2xsZXJuYW1lIGFzIG5hbWVcIilcblx0ICpcblx0ICogLSBUZW1wb3JhcmlseSBkZWNvcmF0ZXMgJGluamVjdG9yLmluc3RhbnRpYXRlLlxuXHQgKiAtIEludm9rZXMgJGNvbnRyb2xsZXIoKSBzZXJ2aWNlXG5cdCAqICAgLSBDYWxscyAkaW5qZWN0b3IuaW5zdGFudGlhdGUgd2l0aCBjb250cm9sbGVyIGNvbnN0cnVjdG9yXG5cdCAqIC0gQW5ub3RhdGUgY29uc3RydWN0b3Jcblx0ICogLSBVbmRlY29yYXRlICRpbmplY3RvclxuXHQgKlxuXHQgKiByZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdoaWNoIGFyZSB0aGUgYXJndW1lbnRzIG9mIHRoZSBjb250cm9sbGVyIGV4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGFubm90YXRlQ29udHJvbGxlcihjb250cm9sbGVyRXhwcmVzc2lvbikge1xuXHQgICAgdmFyICRpbmplY3RvciA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvcjtcblx0ICAgIHZhciAkY29udHJvbGxlciA9ICRpbmplY3Rvci5nZXQoXCIkY29udHJvbGxlclwiKTtcblx0ICAgIHZhciBvbGRJbnN0YW50aWF0ZSA9ICRpbmplY3Rvci5pbnN0YW50aWF0ZTtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIGRlcHNfMTtcblx0ICAgICAgICAkaW5qZWN0b3IuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiBmYWtlSW5zdGFudGlhdGUoY29uc3RydWN0b3JGdW5jdGlvbikge1xuXHQgICAgICAgICAgICAkaW5qZWN0b3IuaW5zdGFudGlhdGUgPSBvbGRJbnN0YW50aWF0ZTsgLy8gVW4tZGVjb3JhdGUgQVNBUFxuXHQgICAgICAgICAgICBkZXBzXzEgPSAkaW5qZWN0b3IuYW5ub3RhdGUoY29uc3RydWN0b3JGdW5jdGlvbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAkY29udHJvbGxlcihjb250cm9sbGVyRXhwcmVzc2lvbiwgeyAkc2NvcGU6IHt9IH0pO1xuXHQgICAgICAgIHJldHVybiBkZXBzXzE7XG5cdCAgICB9XG5cdCAgICBmaW5hbGx5IHtcblx0ICAgICAgICAkaW5qZWN0b3IuaW5zdGFudGlhdGUgPSBvbGRJbnN0YW50aWF0ZTtcblx0ICAgIH1cblx0fVxuXHRleHBvcnRzLmFubm90YXRlQ29udHJvbGxlciA9IGFubm90YXRlQ29udHJvbGxlcjtcblx0cnVuQmxvY2suJGluamVjdCA9IFsnJGluamVjdG9yJywgJyRxJ107XG5cdGZ1bmN0aW9uIHJ1bkJsb2NrKCRpbmplY3RvciwgJHEpIHtcblx0ICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvciA9ICRpbmplY3Rvcjtcblx0ICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxID0gJHE7XG5cdH1cblx0YXBwLnJ1bihydW5CbG9jayk7XG5cdHZhciByb3V0ZXIgPSBudWxsO1xuXHRuZzFVSVJvdXRlci4kaW5qZWN0ID0gWyckbG9jYXRpb25Qcm92aWRlciddO1xuXHQvKiogVGhpcyBhbmd1bGFyIDEgcHJvdmlkZXIgaW5zdGFudGlhdGVzIGEgUm91dGVyIGFuZCBleHBvc2VzIGl0cyBzZXJ2aWNlcyB2aWEgdGhlIGFuZ3VsYXIgaW5qZWN0b3IgKi9cblx0ZnVuY3Rpb24gbmcxVUlSb3V0ZXIoJGxvY2F0aW9uUHJvdmlkZXIpIHtcblx0ICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUm91dGVyIHdoZW4gdGhlIG5nMVVJUm91dGVyUHJvdmlkZXIgaXMgaW5pdGlhbGl6ZWRcblx0ICAgIHJvdXRlciA9IG5ldyByb3V0ZXJfMS5VSVJvdXRlcigpO1xuXHQgICAgLy8gQXBwbHkgbmcxIGB2aWV3c2AgYnVpbGRlciB0byB0aGUgU3RhdGVCdWlsZGVyXG5cdCAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IoXCJ2aWV3c1wiLCB2aWV3c0J1aWxkZXJfMS5uZzFWaWV3c0J1aWxkZXIpO1xuXHQgICAgcm91dGVyLnZpZXdTZXJ2aWNlLnZpZXdDb25maWdGYWN0b3J5KCduZzEnLCB2aWV3c0J1aWxkZXJfMS5uZzFWaWV3Q29uZmlnRmFjdG9yeSk7XG5cdCAgICAvLyBCaW5kIExvY2F0aW9uQ29uZmlnLmhhc2hQcmVmaXggdG8gJGxvY2F0aW9uUHJvdmlkZXIuaGFzaFByZWZpeFxuXHQgICAgY29tbW9uXzEuYmluZEZ1bmN0aW9ucygkbG9jYXRpb25Qcm92aWRlciwgY29yZXNlcnZpY2VzXzEuc2VydmljZXMubG9jYXRpb25Db25maWcsICRsb2NhdGlvblByb3ZpZGVyLCBbJ2hhc2hQcmVmaXgnXSk7XG5cdCAgICAvLyBDcmVhdGUgYSBMb2NhdGlvblNlcnZpY2Uub25DaGFuZ2UgcmVnaXN0cnlcblx0ICAgIHZhciB1cmxMaXN0ZW5lcnMgPSBbXTtcblx0ICAgIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLmxvY2F0aW9uLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdXJsTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5yZW1vdmVGcm9tKHVybExpc3RlbmVycykoY2FsbGJhY2spOyB9O1xuXHQgICAgfTtcblx0ICAgIHRoaXMuJGdldCA9ICRnZXQ7XG5cdCAgICAkZ2V0LiRpbmplY3QgPSBbJyRsb2NhdGlvbicsICckYnJvd3NlcicsICckc25pZmZlcicsICckcm9vdFNjb3BlJywgJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJ107XG5cdCAgICBmdW5jdGlvbiAkZ2V0KCRsb2NhdGlvbiwgJGJyb3dzZXIsICRzbmlmZmVyLCAkcm9vdFNjb3BlLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUpIHtcblx0ICAgICAgICAvLyBCaW5kICRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MgdG8gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGluIExvY2F0aW9uU2VydmljZS5vbkNoYW5nZVxuXHQgICAgICAgICRyb290U2NvcGUuJG9uKFwiJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc1wiLCBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiB1cmxMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKGV2dCk7IH0pOyB9KTtcblx0ICAgICAgICAvLyBCaW5kIExvY2F0aW9uQ29uZmlnLmh0bWw1TW9kZSB0byAkbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUgYW5kICRzbmlmZmVyLmhpc3Rvcnlcblx0ICAgICAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy5sb2NhdGlvbkNvbmZpZy5odG1sNU1vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBodG1sNU1vZGUgPSAkbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUoKTtcblx0ICAgICAgICAgICAgaHRtbDVNb2RlID0gcHJlZGljYXRlc18xLmlzT2JqZWN0KGh0bWw1TW9kZSkgPyBodG1sNU1vZGUuZW5hYmxlZCA6IGh0bWw1TW9kZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGh0bWw1TW9kZSAmJiAkc25pZmZlci5oaXN0b3J5O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMudGVtcGxhdGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KHVybCwgeyBjYWNoZTogJHRlbXBsYXRlQ2FjaGUsIGhlYWRlcnM6IHsgQWNjZXB0OiAndGV4dC9odG1sJyB9IH0pLnRoZW4oaG9mXzEucHJvcChcImRhdGFcIikpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gQmluZCB0aGVzZSBMb2NhdGlvblNlcnZpY2UgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuXHQgICAgICAgIGNvbW1vbl8xLmJpbmRGdW5jdGlvbnMoJGxvY2F0aW9uLCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy5sb2NhdGlvbiwgJGxvY2F0aW9uLCBbXCJyZXBsYWNlXCIsIFwidXJsXCIsIFwicGF0aFwiLCBcInNlYXJjaFwiLCBcImhhc2hcIl0pO1xuXHQgICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuXHQgICAgICAgIGNvbW1vbl8xLmJpbmRGdW5jdGlvbnMoJGxvY2F0aW9uLCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy5sb2NhdGlvbkNvbmZpZywgJGxvY2F0aW9uLCBbJ3BvcnQnLCAncHJvdG9jb2wnLCAnaG9zdCddKTtcblx0ICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkYnJvd3NlclxuXHQgICAgICAgIGNvbW1vbl8xLmJpbmRGdW5jdGlvbnMoJGJyb3dzZXIsIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLmxvY2F0aW9uQ29uZmlnLCAkYnJvd3NlciwgWydiYXNlSHJlZiddKTtcblx0ICAgICAgICByZXR1cm4gcm91dGVyO1xuXHQgICAgfVxuXHR9XG5cdHZhciByZXNvbHZlRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgZW11bGF0ZXMgbW9zdCBvZiB0aGUgYmVoYXZpb3Igb2YgdGhlIHVpLXJvdXRlciAwLjIueCAkcmVzb2x2ZS5yZXNvbHZlKCkgc2VydmljZSBBUEkuXG5cdCAgICAgKiBAcGFyYW0gaW52b2NhYmxlcyBhbiBvYmplY3QsIHdpdGgga2V5cyBhcyByZXNvbHZlIG5hbWVzIGFuZCB2YWx1ZXMgYXMgaW5qZWN0YWJsZSBmdW5jdGlvbnNcblx0ICAgICAqIEBwYXJhbSBsb2NhbHMga2V5L3ZhbHVlIHByZS1yZXNvbHZlZCBkYXRhIChsb2NhbHMpXG5cdCAgICAgKiBAcGFyYW0gcGFyZW50IGEgcHJvbWlzZSBmb3IgYSBcInBhcmVudCByZXNvbHZlXCJcblx0ICAgICAqL1xuXHQgICAgcmVzb2x2ZTogZnVuY3Rpb24gKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50KSB7XG5cdCAgICAgICAgaWYgKGxvY2FscyA9PT0gdm9pZCAwKSB7IGxvY2FscyA9IHt9OyB9XG5cdCAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBuZXcgbW9kdWxlXzEuTm9kZShuZXcgbW9kdWxlXzMuU3RhdGUoeyBwYXJhbXM6IHt9IH0pKTtcblx0ICAgICAgICB2YXIgbm9kZSA9IG5ldyBtb2R1bGVfMS5Ob2RlKG5ldyBtb2R1bGVfMy5TdGF0ZSh7IHBhcmFtczoge30gfSkpO1xuXHQgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IG1vZHVsZV8yLlJlc29sdmVDb250ZXh0KFtwYXJlbnROb2RlLCBub2RlXSk7XG5cdCAgICAgICAgY29udGV4dC5hZGRSZXNvbHZhYmxlcyhtb2R1bGVfMi5SZXNvbHZhYmxlLm1ha2VSZXNvbHZhYmxlcyhpbnZvY2FibGVzKSwgbm9kZS5zdGF0ZSk7XG5cdCAgICAgICAgdmFyIHJlc29sdmVEYXRhID0gZnVuY3Rpb24gKHBhcmVudExvY2Fscykge1xuXHQgICAgICAgICAgICB2YXIgcmV3cmFwID0gZnVuY3Rpb24gKF9sb2NhbHMpIHsgcmV0dXJuIG1vZHVsZV8yLlJlc29sdmFibGUubWFrZVJlc29sdmFibGVzKGNvbW1vbl8xLm1hcChfbG9jYWxzLCBmdW5jdGlvbiAobG9jYWwpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvY2FsOyB9OyB9KSk7IH07XG5cdCAgICAgICAgICAgIGNvbnRleHQuYWRkUmVzb2x2YWJsZXMocmV3cmFwKHBhcmVudExvY2FscyksIHBhcmVudE5vZGUuc3RhdGUpO1xuXHQgICAgICAgICAgICBjb250ZXh0LmFkZFJlc29sdmFibGVzKHJld3JhcChsb2NhbHMpLCBub2RlLnN0YXRlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucmVzb2x2ZVBhdGgoKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQudGhlbihyZXNvbHZlRGF0YSkgOiByZXNvbHZlRGF0YSh7fSk7XG5cdCAgICB9XG5cdH0pOyB9O1xuXHRmdW5jdGlvbiAkc3RhdGVQYXJhbXNGYWN0b3J5KG5nMVVJUm91dGVyKSB7XG5cdCAgICByZXR1cm4gbmcxVUlSb3V0ZXIuZ2xvYmFscy5wYXJhbXM7XG5cdH1cblx0Ly8gVGhlICd1aS5yb3V0ZXInIG5nMSBtb2R1bGUgZGVwZW5kcyBvbiAndWkucm91dGVyLmluaXQnIG1vZHVsZS5cblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5pbml0JywgW10pLnByb3ZpZGVyKFwibmcxVUlSb3V0ZXJcIiwgbmcxVUlSb3V0ZXIpO1xuXHQvLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSB0byBpbml0IHdoZW4gd2UgZW50ZXIgcnVudGltZVxuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLmluaXQnKS5ydW4oWyduZzFVSVJvdXRlcicsIGZ1bmN0aW9uIChuZzFVSVJvdXRlcikgeyB9XSk7XG5cdC8vICR1cmxNYXRjaGVyRmFjdG9yeSBzZXJ2aWNlIGFuZCAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlclxuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnV0aWwnKS5wcm92aWRlcignJHVybE1hdGNoZXJGYWN0b3J5JywgWyduZzFVSVJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9XSk7XG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnkpIHsgfV0pO1xuXHQvLyAkdXJsUm91dGVyIHNlcnZpY2UgYW5kICR1cmxSb3V0ZXJQcm92aWRlclxuXHRmdW5jdGlvbiBnZXRVcmxSb3V0ZXJQcm92aWRlcigpIHtcblx0ICAgIHJvdXRlci51cmxSb3V0ZXJQcm92aWRlcltcIiRnZXRcIl0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcm91dGVyLnVybFJvdXRlci51cGRhdGUodHJ1ZSk7XG5cdCAgICAgICAgaWYgKCF0aGlzLmludGVyY2VwdERlZmVycmVkKVxuXHQgICAgICAgICAgICByb3V0ZXIudXJsUm91dGVyLmxpc3RlbigpO1xuXHQgICAgICAgIHJldHVybiByb3V0ZXIudXJsUm91dGVyO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiByb3V0ZXIudXJsUm91dGVyUHJvdmlkZXI7XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInKS5wcm92aWRlcignJHVybFJvdXRlcicsIFsnbmcxVUlSb3V0ZXJQcm92aWRlcicsIGdldFVybFJvdXRlclByb3ZpZGVyXSk7XG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIucm91dGVyJykucnVuKFsnJHVybFJvdXRlcicsIGZ1bmN0aW9uICgkdXJsUm91dGVyKSB7IH1dKTtcblx0Ly8gJHN0YXRlIHNlcnZpY2UgYW5kICRzdGF0ZVByb3ZpZGVyXG5cdC8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG5cdGZ1bmN0aW9uIGdldFN0YXRlUHJvdmlkZXIoKSB7XG5cdCAgICByb3V0ZXIuc3RhdGVQcm92aWRlcltcIiRnZXRcIl0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQXV0b2ZsdXNoIG9uY2Ugd2UgYXJlIGluIHJ1bnRpbWVcblx0ICAgICAgICByb3V0ZXIuc3RhdGVSZWdpc3RyeS5zdGF0ZVF1ZXVlLmF1dG9GbHVzaChyb3V0ZXIuc3RhdGVTZXJ2aWNlKTtcblx0ICAgICAgICByZXR1cm4gcm91dGVyLnN0YXRlU2VydmljZTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gcm91dGVyLnN0YXRlUHJvdmlkZXI7XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckc3RhdGUnLCBbJ25nMVVJUm91dGVyUHJvdmlkZXInLCBnZXRTdGF0ZVByb3ZpZGVyXSk7XG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5ydW4oWyckc3RhdGUnLCBmdW5jdGlvbiAoJHN0YXRlKSB7IH1dKTtcblx0Ly8gJHN0YXRlUGFyYW1zIHNlcnZpY2Vcblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmZhY3RvcnkoJyRzdGF0ZVBhcmFtcycsIFsnbmcxVUlSb3V0ZXInLCBmdW5jdGlvbiAobmcxVUlSb3V0ZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmcxVUlSb3V0ZXIuZ2xvYmFscy5wYXJhbXM7XG5cdCAgICB9XSk7XG5cdC8vICR0cmFuc2l0aW9ucyBzZXJ2aWNlIGFuZCAkdHJhbnNpdGlvbnNQcm92aWRlclxuXHRmdW5jdGlvbiBnZXRUcmFuc2l0aW9uc1Byb3ZpZGVyKCkge1xuXHQgICAgbG9hZEFsbENvbnRyb2xsZXJMb2NhbHMuJGluamVjdCA9IFsnJHRyYW5zaXRpb24kJ107XG5cdCAgICBmdW5jdGlvbiBsb2FkQWxsQ29udHJvbGxlckxvY2FscygkdHJhbnNpdGlvbiQpIHtcblx0ICAgICAgICB2YXIgbG9hZExvY2FscyA9IGZ1bmN0aW9uICh2Yykge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQoJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCkudG8sIGhvZl8xLnByb3BFcSgnc3RhdGUnLCB2Yy52aWV3RGVjbC4kY29udGV4dCkpO1xuXHQgICAgICAgICAgICAvLyBUZW1wb3JhcnkgZml4OyBUaGlzIHdob2xlIGNhbGxiYWNrIHNob3VsZCBiZSBudWtlZCB3aGVuIGZpeGluZyAjMjY2MlxuXHQgICAgICAgICAgICBpZiAoIW5vZGUpXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbigpO1xuXHQgICAgICAgICAgICB2YXIgcmVzb2x2ZUN0eCA9IG5vZGUucmVzb2x2ZUNvbnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBjb250cm9sbGVyRGVwcyA9IGFubm90YXRlQ29udHJvbGxlcih2Yy5jb250cm9sbGVyKTtcblx0ICAgICAgICAgICAgdmFyIHJlc29sdmFibGVzID0gcmVzb2x2ZUN0eC5nZXRSZXNvbHZhYmxlcygpO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiAkbG9hZENvbnRyb2xsZXJMb2NhbHMoKSB7IH1cblx0ICAgICAgICAgICAgJGxvYWRDb250cm9sbGVyTG9jYWxzLiRpbmplY3QgPSBjb250cm9sbGVyRGVwcy5maWx0ZXIoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gcmVzb2x2YWJsZXMuaGFzT3duUHJvcGVydHkoZGVwKTsgfSk7XG5cdCAgICAgICAgICAgIC8vIExvYWQgYW55IGNvbnRyb2xsZXIgcmVzb2x2ZXMgdGhhdCBhcmVuJ3QgYWxyZWFkeSBsb2FkZWRcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVDdHguaW52b2tlTGF0ZXIoJGxvYWRDb250cm9sbGVyTG9jYWxzKVxuXHQgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmMubG9jYWxzID0gY29tbW9uXzEubWFwKHJlc29sdmFibGVzLCBmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuZGF0YTsgfSk7IH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFyIGxvYWRBbGxMb2NhbHMgPSAkdHJhbnNpdGlvbiQudmlld3MoXCJlbnRlcmluZ1wiKS5maWx0ZXIoZnVuY3Rpb24gKHZjKSB7IHJldHVybiAhIXZjLmNvbnRyb2xsZXI7IH0pLm1hcChsb2FkTG9jYWxzKTtcblx0ICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKGxvYWRBbGxMb2NhbHMpLnRoZW4oY29tbW9uXzEubm9vcCk7XG5cdCAgICB9XG5cdCAgICByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25GaW5pc2goe30sIGxvYWRBbGxDb250cm9sbGVyTG9jYWxzKTtcblx0ICAgIHJvdXRlci50cmFuc2l0aW9uU2VydmljZVtcIiRnZXRcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2U7IH07XG5cdCAgICByZXR1cm4gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuXHR9XG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHRyYW5zaXRpb25zJywgWyduZzFVSVJvdXRlclByb3ZpZGVyJywgZ2V0VHJhbnNpdGlvbnNQcm92aWRlcl0pO1xuXHQvLyAkdGVtcGxhdGVGYWN0b3J5IHNlcnZpY2Vcblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJykuZmFjdG9yeSgnJHRlbXBsYXRlRmFjdG9yeScsIFsnbmcxVUlSb3V0ZXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgdGVtcGxhdGVGYWN0b3J5XzEuVGVtcGxhdGVGYWN0b3J5KCk7IH1dKTtcblx0Ly8gVGhlICR2aWV3IHNlcnZpY2Vcblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlcicpLmZhY3RvcnkoJyR2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnZpZXdTZXJ2aWNlOyB9KTtcblx0Ly8gVGhlIG9sZCAkcmVzb2x2ZSBzZXJ2aWNlXG5cdGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXInKS5mYWN0b3J5KCckcmVzb2x2ZScsIHJlc29sdmVGYWN0b3J5KTtcblx0Ly8gJHRyYWNlIHNlcnZpY2Vcblx0YW5ndWxhci5tb2R1bGUoXCJ1aS5yb3V0ZXJcIikuc2VydmljZShcIiR0cmFjZVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFjZV8xLnRyYWNlOyB9KTtcblx0d2F0Y2hEaWdlc3RzLiRpbmplY3QgPSBbJyRyb290U2NvcGUnXTtcblx0ZnVuY3Rpb24gd2F0Y2hEaWdlc3RzKCRyb290U2NvcGUpIHtcblx0ICAgICRyb290U2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgdHJhY2VfMS50cmFjZS5hcHByb3hpbWF0ZURpZ2VzdHMrKzsgfSk7XG5cdH1cblx0ZXhwb3J0cy53YXRjaERpZ2VzdHMgPSB3YXRjaERpZ2VzdHM7XG5cdGFuZ3VsYXIubW9kdWxlKFwidWkucm91dGVyXCIpLnJ1bih3YXRjaERpZ2VzdHMpO1xuXG5cbi8qKiovIH0sXG4vKiA1NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBzdHJpbmdzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgY29yZXNlcnZpY2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgdHJhY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgdGVtcGxhdGVGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblx0ZXhwb3J0cy5uZzFWaWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uIChub2RlLCB2aWV3KSB7IHJldHVybiBuZXcgTmcxVmlld0NvbmZpZyhub2RlLCB2aWV3KTsgfTtcblx0LyoqXG5cdCAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGB2aWV3c2AuXG5cdCAqXG5cdCAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZV1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcblx0ICogaGFuZGxlcyB0aGUgYHZpZXdzYCBwcm9wZXJ0eSB3aXRoIGxvZ2ljIHNwZWNpZmljIHRvIGFuZ3VsYXItdWktcm91dGVyIChuZzEpLlxuXHQgKlxuXHQgKiBJZiBubyBgdmlld3M6IHt9YCBwcm9wZXJ0eSBleGlzdHMgb24gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGVuIGl0IGNyZWF0ZXMgdGhlIGB2aWV3c2Agb2JqZWN0XG5cdCAqIGFuZCBhcHBsaWVzIHRoZSBzdGF0ZS1sZXZlbCBjb25maWd1cmF0aW9uIHRvIGEgdmlldyBuYW1lZCBgJGRlZmF1bHRgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbmcxVmlld3NCdWlsZGVyKHN0YXRlKSB7XG5cdCAgICB2YXIgdHBsS2V5cyA9IFsndGVtcGxhdGVQcm92aWRlcicsICd0ZW1wbGF0ZVVybCcsICd0ZW1wbGF0ZScsICdub3RpZnknLCAnYXN5bmMnXSwgY3RybEtleXMgPSBbJ2NvbnRyb2xsZXInLCAnY29udHJvbGxlclByb3ZpZGVyJywgJ2NvbnRyb2xsZXJBcycsICdyZXNvbHZlQXMnXSwgY29tcEtleXMgPSBbJ2NvbXBvbmVudCcsICdiaW5kaW5ncyddLCBub25Db21wS2V5cyA9IHRwbEtleXMuY29uY2F0KGN0cmxLZXlzKSwgYWxsS2V5cyA9IGNvbXBLZXlzLmNvbmNhdChub25Db21wS2V5cyk7XG5cdCAgICB2YXIgdmlld3MgPSB7fSwgdmlld3NPYmplY3QgPSBzdGF0ZS52aWV3cyB8fCB7IFwiJGRlZmF1bHRcIjogY29tbW9uXzEucGljayhzdGF0ZSwgYWxsS2V5cykgfTtcblx0ICAgIGNvbW1vbl8xLmZvckVhY2godmlld3NPYmplY3QsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcblx0ICAgICAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBcIlwiOiB7IHRlbXBsYXRlLi4uIH0gfVxuXHQgICAgICAgIG5hbWUgPSBuYW1lIHx8IFwiJGRlZmF1bHRcIjtcblx0ICAgICAgICAvLyBBY2NvdW50IGZvciB2aWV3czogeyBoZWFkZXI6IFwiaGVhZGVyQ29tcG9uZW50XCIgfVxuXHQgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY29uZmlnKSlcblx0ICAgICAgICAgICAgY29uZmlnID0geyBjb21wb25lbnQ6IGNvbmZpZyB9O1xuXHQgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29uZmlnKS5sZW5ndGgpXG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAvLyBDb25maWd1cmUgdGhpcyB2aWV3IGZvciByb3V0aW5nIHRvIGFuIGFuZ3VsYXIgMS41KyBzdHlsZSAuY29tcG9uZW50IChvciBhbnkgZGlyZWN0aXZlLCByZWFsbHkpXG5cdCAgICAgICAgaWYgKGNvbmZpZy5jb21wb25lbnQpIHtcblx0ICAgICAgICAgICAgaWYgKG5vbkNvbXBLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZ1trZXldKTsgfSkucmVkdWNlKGNvbW1vbl8xLmFueVRydWVSLCBmYWxzZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lOiBcIiArIGNvbXBLZXlzLmpvaW4oXCJ8XCIpICsgXCIgd2l0aDogXCIgKyBub25Db21wS2V5cy5qb2luKFwifFwiKSArIFwiIGluIHN0YXRldmlldzogJ25hbWVAXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIER5bmFtaWNhbGx5IGJ1aWxkIGEgdGVtcGxhdGUgbGlrZSBcIjxjb21wb25lbnQtbmFtZSBpbnB1dDE9JyRyZXNvbHZlLmZvbyc+PC9jb21wb25lbnQtbmFtZT5cIlxuXHQgICAgICAgICAgICBjb25maWcudGVtcGxhdGVQcm92aWRlciA9IFsnJGluamVjdG9yJywgZnVuY3Rpb24gKCRpbmplY3Rvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlRm9yID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29uZmlnLmJpbmRpbmdzICYmIGNvbmZpZy5iaW5kaW5nc1trZXldIHx8IGtleTsgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gYW5ndWxhci52ZXJzaW9uLm1pbm9yID49IDMgPyBcIjo6XCIgOiBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IGdldENvbXBvbmVudElucHV0cygkaW5qZWN0b3IsIGNvbmZpZy5jb21wb25lbnQpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoc3RyaW5nc18xLmtlYm9iU3RyaW5nKGtleSkgKyBcIj0nXCIgKyBwcmVmaXggKyBcIiRyZXNvbHZlLlwiICsgcmVzb2x2ZUZvcihrZXkpICsgXCInXCIpOyB9KS5qb2luKFwiIFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2Vib2JOYW1lID0gc3RyaW5nc18xLmtlYm9iU3RyaW5nKGNvbmZpZy5jb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxcIiArIGtlYm9iTmFtZSArIFwiIFwiICsgYXR0cnMgKyBcIj48L1wiICsga2Vib2JOYW1lICsgXCI+XCI7XG5cdCAgICAgICAgICAgICAgICB9XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29uZmlnLnJlc29sdmVBcyA9IGNvbmZpZy5yZXNvbHZlQXMgfHwgJyRyZXNvbHZlJztcblx0ICAgICAgICBjb25maWcuJHR5cGUgPSBcIm5nMVwiO1xuXHQgICAgICAgIGNvbmZpZy4kY29udGV4dCA9IHN0YXRlO1xuXHQgICAgICAgIGNvbmZpZy4kbmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB2aWV3XzEuVmlld1NlcnZpY2Uubm9ybWFsaXplVWlWaWV3VGFyZ2V0KGNvbmZpZy4kY29udGV4dCwgY29uZmlnLiRuYW1lKTtcblx0ICAgICAgICBjb25maWcuJHVpVmlld05hbWUgPSBub3JtYWxpemVkLnVpVmlld05hbWU7XG5cdCAgICAgICAgY29uZmlnLiR1aVZpZXdDb250ZXh0QW5jaG9yID0gbm9ybWFsaXplZC51aVZpZXdDb250ZXh0QW5jaG9yO1xuXHQgICAgICAgIHZpZXdzW25hbWVdID0gY29uZmlnO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gdmlld3M7XG5cdH1cblx0ZXhwb3J0cy5uZzFWaWV3c0J1aWxkZXIgPSBuZzFWaWV3c0J1aWxkZXI7XG5cdC8vIGZvciBuZyAxLjIgc3R5bGUsIHByb2Nlc3MgdGhlIHNjb3BlOiB7IGlucHV0OiBcIj1mb29cIiB9IG9iamVjdFxuXHR2YXIgc2NvcGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChiaW5kaW5nc09iaikgeyByZXR1cm4gT2JqZWN0LmtleXMoYmluZGluZ3NPYmogfHwge30pXG5cdCAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIC9eWz08XSguKikvLmV4ZWMoYmluZGluZ3NPYmpba2V5XSldOyB9KVxuXHQgICAgLmZpbHRlcihmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodHVwbGVbMV0pOyB9KVxuXHQgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzFdWzFdIHx8IHR1cGxlWzBdOyB9KTsgfTtcblx0Ly8gZm9yIG5nIDEuMysgYmluZFRvQ29udHJvbGxlciBvciAxLjUgY29tcG9uZW50IHN0eWxlLCBwcm9jZXNzIGEgJCRiaW5kaW5ncyBvYmplY3Rcblx0dmFyIGJpbmRUb0N0cmxCaW5kaW5ncyA9IGZ1bmN0aW9uIChiaW5kaW5nc09iaikgeyByZXR1cm4gT2JqZWN0LmtleXMoYmluZGluZ3NPYmogfHwge30pXG5cdCAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICEhL1s9PF0vLmV4ZWMoYmluZGluZ3NPYmpba2V5XS5tb2RlKTsgfSlcblx0ICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gYmluZGluZ3NPYmpba2V5XS5hdHRyTmFtZTsgfSk7IH07XG5cdC8vIEdpdmVuIGEgZGlyZWN0aXZlIGRlZmluaXRpb24sIGZpbmQgaXRzIG9iamVjdCBpbnB1dCBhdHRyaWJ1dGVzXG5cdC8vIFVzZSBkaWZmZXJlbnQgcHJvcGVydGllcywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGRpcmVjdGl2ZSAoY29tcG9uZW50LCBiaW5kVG9Db250cm9sbGVyLCBub3JtYWwpXG5cdHZhciBnZXRCaW5kaW5ncyA9IGZ1bmN0aW9uIChkZWYpIHtcblx0ICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QoZGVmLmJpbmRUb0NvbnRyb2xsZXIpKVxuXHQgICAgICAgIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5iaW5kVG9Db250cm9sbGVyKTtcblx0ICAgIGlmIChkZWYuJCRiaW5kaW5ncyAmJiBkZWYuJCRiaW5kaW5ncy5iaW5kVG9Db250cm9sbGVyKVxuXHQgICAgICAgIHJldHVybiBiaW5kVG9DdHJsQmluZGluZ3MoZGVmLiQkYmluZGluZ3MuYmluZFRvQ29udHJvbGxlcik7XG5cdCAgICBpZiAoZGVmLiQkaXNvbGF0ZUJpbmRpbmdzKVxuXHQgICAgICAgIHJldHVybiBiaW5kVG9DdHJsQmluZGluZ3MoZGVmLiQkaXNvbGF0ZUJpbmRpbmdzKTtcblx0ICAgIHJldHVybiBzY29wZUJpbmRpbmdzKGRlZi5zY29wZSk7XG5cdH07XG5cdC8vIEdldHMgYWxsIHRoZSBkaXJlY3RpdmUocyknIGlucHV0cyAoJz0nIGFuZCAnPCcpXG5cdGZ1bmN0aW9uIGdldENvbXBvbmVudElucHV0cygkaW5qZWN0b3IsIG5hbWUpIHtcblx0ICAgIHZhciBjbXBEZWZzID0gJGluamVjdG9yLmdldChuYW1lICsgXCJEaXJlY3RpdmVcIik7IC8vIGNvdWxkIGJlIG11bHRpcGxlXG5cdCAgICBpZiAoIWNtcERlZnMgfHwgIWNtcERlZnMubGVuZ3RoKVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuXHQgICAgcmV0dXJuIGNtcERlZnMubWFwKGdldEJpbmRpbmdzKS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuXHR9XG5cdHZhciBOZzFWaWV3Q29uZmlnID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIE5nMVZpZXdDb25maWcobm9kZSwgdmlld0RlY2wpIHtcblx0ICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuXHQgICAgICAgIHRoaXMudmlld0RlY2wgPSB2aWV3RGVjbDtcblx0ICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciAkcSA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxO1xuXHQgICAgICAgIGlmICghdGhpcy5oYXNUZW1wbGF0ZSgpKVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0ZW1wbGF0ZSBjb25maWd1cmF0aW9uIHNwZWNpZmllZCBmb3IgJ1wiICsgdGhpcy52aWV3RGVjbC4kdWlWaWV3TmFtZSArIFwiQFwiICsgdGhpcy52aWV3RGVjbC4kdWlWaWV3Q29udGV4dEFuY2hvciArIFwiJ1wiKTtcblx0ICAgICAgICB2YXIgaW5qZWN0b3IgPSB0aGlzLm5vZGUucmVzb2x2ZUNvbnRleHQ7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMubm9kZS5wYXJhbVZhbHVlcztcblx0ICAgICAgICB2YXIgcHJvbWlzZXMgPSB7XG5cdCAgICAgICAgICAgIHRlbXBsYXRlOiAkcS53aGVuKHRoaXMuZ2V0VGVtcGxhdGUocGFyYW1zLCBuZXcgdGVtcGxhdGVGYWN0b3J5XzEuVGVtcGxhdGVGYWN0b3J5KCksIGluamVjdG9yKSksXG5cdCAgICAgICAgICAgIGNvbnRyb2xsZXI6ICRxLndoZW4odGhpcy5nZXRDb250cm9sbGVyKGluamVjdG9yKSlcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0ICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoXCJMb2FkZWRcIiwgX3RoaXMpO1xuXHQgICAgICAgICAgICBfdGhpcy5jb250cm9sbGVyID0gcmVzdWx0cy5jb250cm9sbGVyO1xuXHQgICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IHJlc3VsdHMudGVtcGxhdGU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgYSB2aWV3IGNvbmZpZ3VyYXRpb24gdG8gZW5zdXJlIHRoYXQgaXQgc3BlY2lmaWVzIGEgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbmZpZ3VyYXRpb24gY29udGFpbnMgYSB2YWxpZCB0ZW1wbGF0ZSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIE5nMVZpZXdDb25maWcucHJvdG90eXBlLmhhc1RlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAhISh0aGlzLnZpZXdEZWNsLnRlbXBsYXRlIHx8IHRoaXMudmlld0RlY2wudGVtcGxhdGVVcmwgfHwgdGhpcy52aWV3RGVjbC50ZW1wbGF0ZVByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICBOZzFWaWV3Q29uZmlnLnByb3RvdHlwZS5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsICRmYWN0b3J5LCBpbmplY3Rvcikge1xuXHQgICAgICAgIHJldHVybiAkZmFjdG9yeS5mcm9tQ29uZmlnKHRoaXMudmlld0RlY2wsIHBhcmFtcywgaW5qZWN0b3IuaW52b2tlTGF0ZXIuYmluZChpbmplY3RvcikpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgY29udHJvbGxlciBmb3IgYSB2aWV3IGNvbmZpZ3VyYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufFByb21pc2UuPEZ1bmN0aW9uPn0gUmV0dXJucyBhIGNvbnRyb2xsZXIsIG9yIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29udHJvbGxlci5cblx0ICAgICAqL1xuXHQgICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChpbmplY3Rvcikge1xuXHQgICAgICAgIC8vKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIEEgY29udGV4dCBvYmplY3QgZnJvbSB0cmFuc2l0aW9uLmNvbnRleHQoKSB0byBpbnZva2UgYSBmdW5jdGlvbiBpbiB0aGUgY29ycmVjdCBjb250ZXh0XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gdGhpcy52aWV3RGVjbC5jb250cm9sbGVyUHJvdmlkZXI7XG5cdCAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUocHJvdmlkZXIpID8gaW5qZWN0b3IuaW52b2tlTGF0ZXIocHJvdmlkZXIsIHt9KSA6IHRoaXMudmlld0RlY2wuY29udHJvbGxlcjtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gTmcxVmlld0NvbmZpZztcblx0fSgpKTtcblx0ZXhwb3J0cy5OZzFWaWV3Q29uZmlnID0gTmcxVmlld0NvbmZpZztcblxuXG4vKioqLyB9LFxuLyogNTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiogQG1vZHVsZSB2aWV3ICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIGNvcmVzZXJ2aWNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0LyoqXG5cdCAqIFNlcnZpY2Ugd2hpY2ggbWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcyBmcm9tIGEgVmlld0NvbmZpZy5cblx0ICovXG5cdHZhciBUZW1wbGF0ZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVGYWN0b3J5KCkge1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHdoaWNoIHRvIGxvYWQgYSB0ZW1wbGF0ZS5cblx0ICAgICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgc2VhcmNoIGluIHRoZSBzcGVjaWZpZWQgb3JkZXIsIGFuZCB0aGUgZmlyc3Qgb25lXG5cdCAgICAgKiB0aGF0IGlzIGRlZmluZWQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRlbXBsYXRlOlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBwYXJhbXMgIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXG5cdCAgICAgKiBAcGFyYW0gaW5qZWN0Rm4gRnVuY3Rpb24gdG8gd2hpY2ggYW4gaW5qZWN0YWJsZSBmdW5jdGlvbiBtYXkgYmUgcGFzc2VkLlxuXHQgICAgICogICAgICAgIElmIHRlbXBsYXRlUHJvdmlkZXIgaXMgZGVmaW5lZCwgdGhpcyBpbmplY3RGbiB3aWxsIGJlIHVzZWQgdG8gaW52b2tlIGl0LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9ICBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvclxuXHQgICAgICogdGhhdCBzdHJpbmcsb3IgYG51bGxgIGlmIG5vIHRlbXBsYXRlIGlzIGNvbmZpZ3VyZWQuXG5cdCAgICAgKi9cblx0ICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcsIHBhcmFtcywgaW5qZWN0Rm4pIHtcblx0ICAgICAgICByZXR1cm4gKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlKSA/IHRoaXMuZnJvbVN0cmluZyhjb25maWcudGVtcGxhdGUsIHBhcmFtcykgOlxuXHQgICAgICAgICAgICBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVVybCkgPyB0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpIDpcblx0ICAgICAgICAgICAgICAgIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIpID8gdGhpcy5mcm9tUHJvdmlkZXIoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIsIHBhcmFtcywgaW5qZWN0Rm4pIDpcblx0ICAgICAgICAgICAgICAgICAgICBudWxsKTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nLlxuXHQgICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge3N0cmluZ3xvYmplY3R9IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIHRoYXRcblx0ICAgICAqIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIC8qKlxuXHQgICAgICogTG9hZHMgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBhIFVSTCB2aWEgYCRodHRwYCBhbmQgYCR0ZW1wbGF0ZUNhY2hlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gdXJsIHVybCBvZiB0aGUgdGVtcGxhdGUgdG8gbG9hZCwgb3IgYSBmdW5jdGlvblxuXHQgICAgICogdGhhdCByZXR1cm5zIGEgdXJsLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVybCBmdW5jdGlvbi5cblx0ICAgICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlXG5cdCAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih1cmwpKVxuXHQgICAgICAgICAgICB1cmwgPSB1cmwocGFyYW1zKTtcblx0ICAgICAgICBpZiAodXJsID09IG51bGwpXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy50ZW1wbGF0ZS5nZXQodXJsKTtcblx0ICAgIH07XG5cdCAgICA7XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBwcm92aWRlciBGdW5jdGlvbiB0byBpbnZva2UgdmlhIGBsb2NhbHNgXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuXHQgICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2Vcblx0ICAgICAqIGZvciB0aGF0IHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgaW5qZWN0Rm4pIHtcblx0ICAgICAgICByZXR1cm4gaW5qZWN0Rm4ocHJvdmlkZXIpO1xuXHQgICAgfTtcblx0ICAgIDtcblx0ICAgIHJldHVybiBUZW1wbGF0ZUZhY3Rvcnk7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVGVtcGxhdGVGYWN0b3J5ID0gVGVtcGxhdGVGYWN0b3J5O1xuXG5cbi8qKiovIH0sXG4vKiA1NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiBUaGVzZSBhcmUgdGhlIFVJLVJvdXRlciBhbmd1bGFyIDEgZGlyZWN0aXZlcy5cblx0ICpcblx0ICogVGhlc2UgZGlyZWN0aXZlcyBhcmUgdXNlZCBpbiB0ZW1wbGF0ZXMgdG8gY3JlYXRlIHZpZXdwb3J0cyBhbmQgbmF2aWdhdGUgdG8gc3RhdGVzXG5cdCAqXG5cdCAqIEBwcmVmZXJyZWQgQG1vZHVsZSBuZzFfZGlyZWN0aXZlc1xuXHQgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdHZhciBwcmVkaWNhdGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHQvKiogQGhpZGRlbiAqL1xuXHRmdW5jdGlvbiBwYXJzZVN0YXRlUmVmKHJlZiwgY3VycmVudCkge1xuXHQgICAgdmFyIHByZXBhcnNlZCA9IHJlZi5tYXRjaCgvXlxccyooe1tefV0qfSlcXHMqJC8pLCBwYXJzZWQ7XG5cdCAgICBpZiAocHJlcGFyc2VkKVxuXHQgICAgICAgIHJlZiA9IGN1cnJlbnQgKyAnKCcgKyBwcmVwYXJzZWRbMV0gKyAnKSc7XG5cdCAgICBwYXJzZWQgPSByZWYucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5tYXRjaCgvXihbXihdKz8pXFxzKihcXCgoLiopXFwpKT8kLyk7XG5cdCAgICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQubGVuZ3RoICE9PSA0KVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgcmVmICdcIiArIHJlZiArIFwiJ1wiKTtcblx0ICAgIHJldHVybiB7IHN0YXRlOiBwYXJzZWRbMV0sIHBhcmFtRXhwcjogcGFyc2VkWzNdIHx8IG51bGwgfTtcblx0fVxuXHQvKiogQGhpZGRlbiAqL1xuXHRmdW5jdGlvbiBzdGF0ZUNvbnRleHQoZWwpIHtcblx0ICAgIHZhciAkdWlWaWV3ID0gZWwucGFyZW50KCkuaW5oZXJpdGVkRGF0YSgnJHVpVmlldycpO1xuXHQgICAgdmFyIGNvbnRleHQgPSBob2ZfMS5wYXJzZSgnJGNmZy5ub2RlLnN0YXRlJykoJHVpVmlldyk7XG5cdCAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0Lm5hbWUgPyBjb250ZXh0IDogdW5kZWZpbmVkO1xuXHR9XG5cdC8qKiBAaGlkZGVuICovXG5cdGZ1bmN0aW9uIGdldFR5cGVJbmZvKGVsKSB7XG5cdCAgICAvLyBTVkdBRWxlbWVudCBkb2VzIG5vdCB1c2UgdGhlIGhyZWYgYXR0cmlidXRlLCBidXQgcmF0aGVyIHRoZSAneGxpbmtIcmVmJyBhdHRyaWJ1dGUuXG5cdCAgICB2YXIgaXNTdmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwucHJvcCgnaHJlZicpKSA9PT0gJ1tvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddJztcblx0ICAgIHZhciBpc0Zvcm0gPSBlbFswXS5ub2RlTmFtZSA9PT0gXCJGT1JNXCI7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGF0dHI6IGlzRm9ybSA/IFwiYWN0aW9uXCIgOiAoaXNTdmcgPyAneGxpbms6aHJlZicgOiAnaHJlZicpLFxuXHQgICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKFwidGFnTmFtZVwiKS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIixcblx0ICAgICAgICBjbGlja2FibGU6ICFpc0Zvcm1cblx0ICAgIH07XG5cdH1cblx0LyoqIEBoaWRkZW4gKi9cblx0ZnVuY3Rpb24gY2xpY2tIb29rKGVsLCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBjdXJyZW50KSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgYnV0dG9uID0gZS53aGljaCB8fCBlLmJ1dHRvbiwgdGFyZ2V0ID0gY3VycmVudCgpO1xuXHQgICAgICAgIGlmICghKGJ1dHRvbiA+IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGVsLmF0dHIoJ3RhcmdldCcpKSkge1xuXHQgICAgICAgICAgICAvLyBIQUNLOiBUaGlzIGlzIHRvIGFsbG93IG5nLWNsaWNrcyB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGlzIGluaXRpYXRlZDpcblx0ICAgICAgICAgICAgdmFyIHRyYW5zaXRpb24gPSAkdGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAkc3RhdGUuZ28odGFyZ2V0LnN0YXRlLCB0YXJnZXQucGFyYW1zLCB0YXJnZXQub3B0aW9ucyk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0ZSBoYXMgbm8gVVJMLCBpZ25vcmUgb25lIHByZXZlbnREZWZhdWx0IGZyb20gdGhlIDxhPiBkaXJlY3RpdmUuXG5cdCAgICAgICAgICAgIHZhciBpZ25vcmVQcmV2ZW50RGVmYXVsdENvdW50ID0gdHlwZS5pc0FuY2hvciAmJiAhdGFyZ2V0LmhyZWYgPyAxIDogMDtcblx0ICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpZ25vcmVQcmV2ZW50RGVmYXVsdENvdW50LS0gPD0gMClcblx0ICAgICAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwodHJhbnNpdGlvbik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fVxuXHQvKiogQGhpZGRlbiAqL1xuXHRmdW5jdGlvbiBkZWZhdWx0T3B0cyhlbCwgJHN0YXRlKSB7XG5cdCAgICByZXR1cm4geyByZWxhdGl2ZTogc3RhdGVDb250ZXh0KGVsKSB8fCAkc3RhdGUuJGN1cnJlbnQsIGluaGVyaXQ6IHRydWUgfTtcblx0fVxuXHQvKipcblx0ICogYHVpLXNyZWZgOiBBIGRpcmVjdGl2ZSBmb3IgbGlua2luZyB0byBhIHN0YXRlXG5cdCAqXG5cdCAqIEEgZGlyZWN0aXZlIHRoYXQgYmluZHMgYSBsaW5rIChgPGE+YCB0YWcpIHRvIGEgc3RhdGUuIElmIHRoZSBzdGF0ZSBoYXMgYW4gYXNzb2NpYXRlZFxuXHQgKiBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlICYgdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlIHZpYVxuXHQgKiB0aGUge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19ocmVmICRzdGF0ZS5ocmVmKCl9IG1ldGhvZC4gQ2xpY2tpbmdcblx0ICogdGhlIGxpbmsgd2lsbCB0cmlnZ2VyIGEgc3RhdGUgdHJhbnNpdGlvbiB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG5cdCAqXG5cdCAqIEFsc28gbWlkZGxlLWNsaWNraW5nLCByaWdodC1jbGlja2luZywgYW5kIGN0cmwtY2xpY2tpbmcgb24gdGhlIGxpbmsgd2lsbCBiZVxuXHQgKiBoYW5kbGVkIG5hdGl2ZWx5IGJ5IHRoZSBicm93c2VyLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gdXNlIHJlbGF0aXZlIHN0YXRlIHBhdGhzIHdpdGhpbiB1aS1zcmVmLCBqdXN0IGxpa2UgdGhlIHJlbGF0aXZlXG5cdCAqIHBhdGhzIHBhc3NlZCB0byBgJHN0YXRlLmdvKClgLiBZb3UganVzdCBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgdGhlIHBhdGggaXMgcmVsYXRpdmVcblx0ICogdG8gdGhlIHN0YXRlIHRoYXQgdGhlIGxpbmsgbGl2ZXMgaW4sIGluIG90aGVyIHdvcmRzIHRoZSBzdGF0ZSB0aGF0IGxvYWRlZCB0aGVcblx0ICogdGVtcGxhdGUgY29udGFpbmluZyB0aGUgbGluay5cblx0ICpcblx0ICogWW91IGNhbiBzcGVjaWZ5IG9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNnbyAkc3RhdGUuZ28oKX1cblx0ICogdXNpbmcgdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS4gT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsXG5cdCAqIGFuZCBgcmVsb2FkYC5cblx0ICpcblx0ICogSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSdkIHVzZSB1aS1zcmVmIGFuZCBob3cgaXQgd291bGQgY29tcGlsZS4gSWYgeW91IGhhdmUgdGhlXG5cdCAqIGZvbGxvd2luZyB0ZW1wbGF0ZTpcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8cHJlPlxuXHQgKiA8YSB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+IHwgPGEgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+IHwgPGEgdWktc3JlZj1cIntwYWdlOiAyfVwiPk5leHQgcGFnZTwvYT5cblx0ICpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cblx0ICogICAgICAgICA8YSB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj57eyBjb250YWN0Lm5hbWUgfX08L2E+XG5cdCAqICAgICA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiA8L3ByZT5cblx0ICogYGBgXG5cdCAqXG5cdCAqIFRoZW4gdGhlIGNvbXBpbGVkIGh0bWwgd291bGQgYmUgKGFzc3VtaW5nIEh0bWw1TW9kZSBpcyBvZmYgYW5kIGN1cnJlbnQgc3RhdGUgaXMgY29udGFjdHMpOlxuXHQgKlxuXHQgKiBgYGBodG1sXG5cdCAqXG5cdCAqIDxwcmU+XG5cdCAqIDxhIGhyZWY9XCIjL2hvbWVcIiB1aS1zcmVmPVwiaG9tZVwiPkhvbWU8L2E+IHwgPGEgaHJlZj1cIiMvYWJvdXRcIiB1aS1zcmVmPVwiYWJvdXRcIj5BYm91dDwvYT4gfCA8YSBocmVmPVwiIy9jb250YWN0cz9wYWdlPTJcIiB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuXHQgKlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuXHQgKiAgICAgICAgIDxhIGhyZWY9XCIjL2NvbnRhY3RzLzFcIiB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj5Kb2U8L2E+XG5cdCAqICAgICA8L2xpPlxuXHQgKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cblx0ICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8yXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+QWxpY2U8L2E+XG5cdCAqICAgICA8L2xpPlxuXHQgKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cblx0ICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8zXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Qm9iPC9hPlxuXHQgKiAgICAgPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGEgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7cmVsb2FkOiB0cnVlfVwiPkhvbWU8L2E+XG5cdCAqIDwvcHJlPlxuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVpLXNyZWYgJ3N0YXRlTmFtZScgY2FuIGJlIGFueSB2YWxpZCBhYnNvbHV0ZSBvciByZWxhdGl2ZSBzdGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdWktc3JlZi1vcHRzIG9wdGlvbnMgdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5nb11dXG5cdCAqL1xuXHR2YXIgdWlTcmVmTmcxID0gWyckc3RhdGUnLCAnJHRpbWVvdXQnLFxuXHQgICAgZnVuY3Rpb24gJFN0YXRlUmVmRGlyZWN0aXZlKCRzdGF0ZSwgJHRpbWVvdXQpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICByZXN0cmljdDogJ0EnLFxuXHQgICAgICAgICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcblx0ICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdWlTcmVmQWN0aXZlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihhdHRycy51aVNyZWYsICRzdGF0ZS5jdXJyZW50Lm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHsgc3RhdGU6IHJlZi5zdGF0ZSwgaHJlZjogbnVsbCwgcGFyYW1zOiBudWxsLCBvcHRpb25zOiBudWxsIH07XG5cdCAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGVJbmZvKGVsZW1lbnQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgdW5saW5rSW5mb0ZuID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGRlZi5vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKGRlZmF1bHRPcHRzKGVsZW1lbnQsICRzdGF0ZSksIGF0dHJzLnVpU3JlZk9wdHMgPyBzY29wZS4kZXZhbChhdHRycy51aVNyZWZPcHRzKSA6IHt9KTtcblx0ICAgICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnBhcmFtcyA9IGFuZ3VsYXIuY29weSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZi5ocmVmID0gJHN0YXRlLmhyZWYocmVmLnN0YXRlLCBkZWYucGFyYW1zLCBkZWYub3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHVubGlua0luZm9Gbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKHJlZi5zdGF0ZSwgZGVmLnBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5ocmVmICE9PSBudWxsKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhdHRycy4kc2V0KHR5cGUuYXR0ciwgZGVmLmhyZWYpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGlmIChyZWYucGFyYW1FeHByKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKHJlZi5wYXJhbUV4cHIsIGZ1bmN0aW9uICh2YWwpIHsgaWYgKHZhbCAhPT0gZGVmLnBhcmFtcylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHZhbCk7IH0sIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZi5wYXJhbXMgPSBhbmd1bGFyLmNvcHkoc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwcikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQuYmluZChcImNsaWNrXCIsIGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWY7IH0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XTtcblx0LyoqXG5cdCAqIGB1aS1zdGF0ZWA6IEEgZHluYW1pYyB2ZXJzaW9uIG9mIGB1aS1zcmVmYFxuXHQgKlxuXHQgKiBNdWNoIGxpa2UgdWktc3JlZiwgYnV0IHdpbGwgYWNjZXB0IG5hbWVkICRzY29wZSBwcm9wZXJ0aWVzIHRvIGV2YWx1YXRlIGZvciBhIHN0YXRlIGRlZmluaXRpb24sXG5cdCAqIHBhcmFtcyBhbmQgb3ZlcnJpZGUgb3B0aW9ucy5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8bGkgbmctcmVwZWF0PVwibmF2IGluIG5hdmxpbmtzXCI+XG5cdCAqICAgPGEgdWktc3RhdGU9XCJuYXYuc3RhdGVuYW1lXCI+e3tuYXYuZGVzY3JpcHRpb259fTwvYT5cblx0ICogPC9saT5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVpLXN0YXRlICdzdGF0ZU5hbWUnIGNhbiBiZSBhbnkgdmFsaWQgYWJzb2x1dGUgb3IgcmVsYXRpdmUgc3RhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHVpLXN0YXRlLXBhcmFtcyBwYXJhbXMgdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5ocmVmXV1cblx0ICogQHBhcmFtIHtPYmplY3R9IHVpLXN0YXRlLW9wdHMgb3B0aW9ucyB0byBwYXNzIHRvIFtbU3RhdGVTZXJ2aWNlLmdvXV1cblx0ICovXG5cdHZhciB1aVN0YXRlTmcxID0gWyckc3RhdGUnLCAnJHRpbWVvdXQnLFxuXHQgICAgZnVuY3Rpb24gJFN0YXRlUmVmRHluYW1pY0RpcmVjdGl2ZSgkc3RhdGUsICR0aW1lb3V0KSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcblx0ICAgICAgICAgICAgcmVxdWlyZTogWyc/XnVpU3JlZkFjdGl2ZScsICc/XnVpU3JlZkFjdGl2ZUVxJ10sXG5cdCAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcblx0ICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSB1aVNyZWZBY3RpdmVbMV0gfHwgdWlTcmVmQWN0aXZlWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gW2F0dHJzLnVpU3RhdGUsIGF0dHJzLnVpU3RhdGVQYXJhbXMgfHwgbnVsbCwgYXR0cnMudWlTdGF0ZU9wdHMgfHwgbnVsbF07XG5cdCAgICAgICAgICAgICAgICB2YXIgd2F0Y2ggPSAnWycgKyBncm91cC5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsIHx8ICdudWxsJzsgfSkuam9pbignLCAnKSArICddJztcblx0ICAgICAgICAgICAgICAgIHZhciBkZWYgPSB7IHN0YXRlOiBudWxsLCBwYXJhbXM6IG51bGwsIG9wdGlvbnM6IG51bGwsIGhyZWY6IG51bGwgfTtcblx0ICAgICAgICAgICAgICAgIHZhciB1bmxpbmtJbmZvRm4gPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gcnVuU3RhdGVSZWZMaW5rKGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmLnN0YXRlID0gZ3JvdXBbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmLnBhcmFtcyA9IGdyb3VwWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlZi5vcHRpb25zID0gZ3JvdXBbMl07XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmLmhyZWYgPSAkc3RhdGUuaHJlZihkZWYuc3RhdGUsIGRlZi5wYXJhbXMsIGRlZi5vcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodW5saW5rSW5mb0ZuKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4gPSBhY3RpdmUuJCRhZGRTdGF0ZUluZm8oZGVmLnN0YXRlLCBkZWYucGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmhyZWYpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2god2F0Y2gsIHJ1blN0YXRlUmVmTGluaywgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICBydW5TdGF0ZVJlZkxpbmsoc2NvcGUuJGV2YWwod2F0Y2gpKTtcblx0ICAgICAgICAgICAgICAgIGlmICghdHlwZS5jbGlja2FibGUpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKFwiY2xpY2tcIiwgY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZjsgfSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH1dO1xuXHQvKipcblx0ICogYHVpLXNyZWYtYWN0aXZlYCBhbmQgYHVpLXNyZWYtYWN0aXZlLWVxYDogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gYSBgdWktc3JlZmAgaXMgYWN0aXZlXG5cdCAqXG5cdCAqIEEgZGlyZWN0aXZlIHdvcmtpbmcgYWxvbmdzaWRlIHVpLXNyZWYgdG8gYWRkIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB3aGVuIHRoZVxuXHQgKiByZWxhdGVkIHVpLXNyZWYgZGlyZWN0aXZlJ3Mgc3RhdGUgaXMgYWN0aXZlLCBhbmQgcmVtb3ZpbmcgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlLlxuXHQgKiBUaGUgcHJpbWFyeSB1c2UtY2FzZSBpcyB0byBzaW1wbGlmeSB0aGUgc3BlY2lhbCBhcHBlYXJhbmNlIG9mIG5hdmlnYXRpb24gbWVudXNcblx0ICogcmVseWluZyBvbiBgdWktc3JlZmAsIGJ5IGhhdmluZyB0aGUgXCJhY3RpdmVcIiBzdGF0ZSdzIG1lbnUgYnV0dG9uIGFwcGVhciBkaWZmZXJlbnQsXG5cdCAqIGRpc3Rpbmd1aXNoaW5nIGl0IGZyb20gdGhlIGluYWN0aXZlIG1lbnUgaXRlbXMuXG5cdCAqXG5cdCAqIHVpLXNyZWYtYWN0aXZlIGNhbiBsaXZlIG9uIHRoZSBzYW1lIGVsZW1lbnQgYXMgdWktc3JlZiBvciBvbiBhIHBhcmVudCBlbGVtZW50LiBUaGUgZmlyc3Rcblx0ICogdWktc3JlZi1hY3RpdmUgZm91bmQgYXQgdGhlIHNhbWUgbGV2ZWwgb3IgYWJvdmUgdGhlIHVpLXNyZWYgd2lsbCBiZSB1c2VkLlxuXHQgKlxuXHQgKiBXaWxsIGFjdGl2YXRlIHdoZW4gdGhlIHVpLXNyZWYncyB0YXJnZXQgc3RhdGUgb3IgYW55IGNoaWxkIHN0YXRlIGlzIGFjdGl2ZS4gSWYgeW91XG5cdCAqIG5lZWQgdG8gYWN0aXZhdGUgb25seSB3aGVuIHRoZSB1aS1zcmVmIHRhcmdldCBzdGF0ZSBpcyBhY3RpdmUgYW5kICpub3QqIGFueSBvZlxuXHQgKiBpdCdzIGNoaWxkcmVuLCB0aGVuIHlvdSB3aWxsIHVzZSB1aS1zcmVmLWFjdGl2ZS1lcVxuXHQgKlxuXHQgKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlOlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBgYGBodG1sXG5cdCAqXG5cdCAqIDxwcmU+XG5cdCAqIDx1bD5cblx0ICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW1cIj5cblx0ICogICAgIDxhIGhyZWYgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCI+QGJpbGJvYmFnZ2luczwvYT5cblx0ICogICA8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiA8L3ByZT5cblx0ICogYGBgXG5cdCAqXG5cdCAqXG5cdCAqIFdoZW4gdGhlIGFwcCBzdGF0ZSBpcyBcImFwcC51c2VyXCIgKG9yIGFueSBjaGlsZHJlbiBzdGF0ZXMpLCBhbmQgY29udGFpbnMgdGhlIHN0YXRlIHBhcmFtZXRlciBcInVzZXJcIiB3aXRoIHZhbHVlIFwiYmlsYm9iYWdnaW5zXCIsXG5cdCAqIHRoZSByZXN1bHRpbmcgSFRNTCB3aWxsIGFwcGVhciBhcyAobm90ZSB0aGUgJ2FjdGl2ZScgY2xhc3MpOlxuXHQgKlxuXHQgKiBgYGBodG1sXG5cdCAqXG5cdCAqIDxwcmU+XG5cdCAqIDx1bD5cblx0ICogICA8bGkgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiBjbGFzcz1cIml0ZW0gYWN0aXZlXCI+XG5cdCAqICAgICA8YSB1aS1zcmVmPVwiYXBwLnVzZXIoe3VzZXI6ICdiaWxib2JhZ2dpbnMnfSlcIiBocmVmPVwiL3VzZXJzL2JpbGJvYmFnZ2luc1wiPkBiaWxib2JhZ2dpbnM8L2E+XG5cdCAqICAgPC9saT5cblx0ICogPC91bD5cblx0ICogPC9wcmU+XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBUaGUgY2xhc3MgbmFtZSBpcyBpbnRlcnBvbGF0ZWQgKipvbmNlKiogZHVyaW5nIHRoZSBkaXJlY3RpdmVzIGxpbmsgdGltZSAoYW55IGZ1cnRoZXIgY2hhbmdlcyB0byB0aGVcblx0ICogaW50ZXJwb2xhdGVkIHZhbHVlIGFyZSBpZ25vcmVkKS5cblx0ICpcblx0ICogTXVsdGlwbGUgY2xhc3NlcyBtYXkgYmUgc3BlY2lmaWVkIGluIGEgc3BhY2Utc2VwYXJhdGVkIGZvcm1hdDpcblx0ICpcblx0ICogYGBgaHRtbFxuXHQgKiA8cHJlPlxuXHQgKiA8dWw+XG5cdCAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPSdjbGFzczEgY2xhc3MyIGNsYXNzMyc+XG5cdCAqICAgICA8YSB1aS1zcmVmPVwiYXBwLnVzZXJcIj5saW5rPC9hPlxuXHQgKiAgIDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIDwvcHJlPlxuXHQgKiBgYGBcblx0ICpcblx0ICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwYXNzIHVpLXNyZWYtYWN0aXZlIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXNcblx0ICogdG8gYW4gb2JqZWN0IGhhc2gsIHdob3NlIGtleXMgcmVwcmVzZW50IGFjdGl2ZSBjbGFzcyBuYW1lcyBhbmQgd2hvc2Vcblx0ICogdmFsdWVzIHJlcHJlc2VudCB0aGUgcmVzcGVjdGl2ZSBzdGF0ZSBuYW1lcy9nbG9icy5cblx0ICogdWktc3JlZi1hY3RpdmUgd2lsbCBtYXRjaCBpZiB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUgKippbmNsdWRlcyoqIGFueSBvZlxuXHQgKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuXHQgKlxuXHQgKiBHaXZlbiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLCB3aXRoIFwiYWRtaW5cIiBiZWluZyBhbiBhYnN0cmFjdCBzdGF0ZTpcblx0ICogQGV4YW1wbGVcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8cHJlPlxuXHQgKiA8ZGl2IHVpLXNyZWYtYWN0aXZlPVwieydhY3RpdmUnOiAnYWRtaW4uKid9XCI+XG5cdCAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cblx0ICogPC9kaXY+XG5cdCAqIDwvcHJlPlxuXHQgKiBgYGBcblx0ICpcblx0ICogV2hlbiB0aGUgY3VycmVudCBzdGF0ZSBpcyBcImFkbWluLnJvbGVzXCIgdGhlIFwiYWN0aXZlXCIgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkXG5cdCAqIHRvIGJvdGggdGhlIDxkaXY+IGFuZCA8YT4gZWxlbWVudHMuIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlIHN0YXRlXG5cdCAqIG5hbWVzL2dsb2JzIHBhc3NlZCB0byB1aS1zcmVmLWFjdGl2ZSBzaGFkb3cgdGhlIHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYuXG5cdCAqL1xuXHR2YXIgdWlTcmVmQWN0aXZlTmcxID0gWyckc3RhdGUnLCAnJHN0YXRlUGFyYW1zJywgJyRpbnRlcnBvbGF0ZScsICckdHJhbnNpdGlvbnMnLFxuXHQgICAgZnVuY3Rpb24gJFN0YXRlUmVmQWN0aXZlRGlyZWN0aXZlKCRzdGF0ZSwgJHN0YXRlUGFyYW1zLCAkaW50ZXJwb2xhdGUsICR0cmFuc2l0aW9ucykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHJlc3RyaWN0OiBcIkFcIixcblx0ICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHRpbWVvdXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVzID0gW10sIGFjdGl2ZUNsYXNzZXMgPSB7fSwgYWN0aXZlRXFDbGFzcywgdWlTcmVmQWN0aXZlO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdWlTcmVmQWN0aXZlIGFuZCB1aVNyZWZBY3RpdmVFcSBzaGFyZSB0aGUgc2FtZSBkaXJlY3RpdmUgb2JqZWN0IHdpdGggc29tZVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNsaWdodCBkaWZmZXJlbmNlIGluIGxvZ2ljIHJvdXRpbmdcblx0ICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdWlTcmVmQWN0aXZlID0gJHNjb3BlLiRldmFsKCRhdHRycy51aVNyZWZBY3RpdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB1aVNyZWZBY3RpdmUgPSB1aVNyZWZBY3RpdmUgfHwgJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmUgfHwgJycsIGZhbHNlKSgkc2NvcGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QodWlTcmVmQWN0aXZlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25fMS5mb3JFYWNoKHVpU3JlZkFjdGl2ZSwgZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBhY3RpdmVDbGFzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzdGF0ZU9yTmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihzdGF0ZU9yTmFtZSwgJHN0YXRlLmN1cnJlbnQubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3RhdGUocmVmLnN0YXRlLCAkc2NvcGUuJGV2YWwocmVmLnBhcmFtRXhwciksIGFjdGl2ZUNsYXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHVpU3JlZiB0byBjb21tdW5pY2F0ZSB3aXRoIHVpU3JlZkFjdGl2ZVtFcXVhbHNdXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kJGFkZFN0YXRlSW5mbyA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3UGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFscmVhZHkgZ290IGFuIGV4cGxpY2l0IHN0YXRlIHByb3ZpZGVkIGJ5IHVpLXNyZWYtYWN0aXZlLCBzbyB3ZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGFkb3cgdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdWktc3JlZlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KHVpU3JlZkFjdGl2ZSkgJiYgc3RhdGVzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlciA9IGFkZFN0YXRlKG5ld1N0YXRlLCBuZXdQYXJhbXMsIHVpU3JlZkFjdGl2ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVyZWdpc3Rlcjtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVBZnRlclRyYW5zaXRpb24gPSBbJyR0cmFuc2l0aW9uJCcsIGZ1bmN0aW9uICgkdHJhbnNpdGlvbiQpIHsgJHRyYW5zaXRpb24kLnByb21pc2UudGhlbih1cGRhdGUpOyB9XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlckZuID0gJHRyYW5zaXRpb25zLm9uU3RhcnQoe30sIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBkZXJlZ2lzdGVyRm4pO1xuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFN0YXRlKHN0YXRlTmFtZSwgc3RhdGVQYXJhbXMsIGFjdGl2ZUNsYXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9ICRzdGF0ZS5nZXQoc3RhdGVOYW1lLCBzdGF0ZUNvbnRleHQoJGVsZW1lbnQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlSGFzaCA9IGNyZWF0ZVN0YXRlSGFzaChzdGF0ZU5hbWUsIHN0YXRlUGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlSW5mbyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSB8fCB7IG5hbWU6IHN0YXRlTmFtZSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZVBhcmFtcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHN0YXRlSGFzaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaChzdGF0ZUluZm8pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzc2VzW3N0YXRlSGFzaF0gPSBhY3RpdmVDbGFzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZVN0YXRlKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHN0YXRlcy5pbmRleE9mKHN0YXRlSW5mbyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZXMuc3BsaWNlKGlkeCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW3BhcmFtc11cblx0ICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAgICAgICAgICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3RhdGVIYXNoKHN0YXRlLCBwYXJhbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXRlIHNob3VsZCBiZSBhIHN0cmluZycpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QocGFyYW1zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlICsgY29tbW9uXzEudG9Kc29uKHBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gJHNjb3BlLiRldmFsKHBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNPYmplY3QocGFyYW1zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlICsgY29tbW9uXzEudG9Kc29uKHBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcm91dGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW55TWF0Y2goc3RhdGVzW2ldLnN0YXRlLCBzdGF0ZXNbaV0ucGFyYW1zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKCRlbGVtZW50LCBhY3RpdmVDbGFzc2VzW3N0YXRlc1tpXS5oYXNoXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcygkZWxlbWVudCwgYWN0aXZlQ2xhc3Nlc1tzdGF0ZXNbaV0uaGFzaF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4YWN0TWF0Y2goc3RhdGVzW2ldLnN0YXRlLCBzdGF0ZXNbaV0ucGFyYW1zKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKCRlbGVtZW50LCBhY3RpdmVFcUNsYXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKCRlbGVtZW50LCBhY3RpdmVFcUNsYXNzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3NOYW1lKSB7ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHsgZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTsgfSk7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7IGVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbnlNYXRjaChzdGF0ZSwgcGFyYW1zKSB7IHJldHVybiAkc3RhdGUuaW5jbHVkZXMoc3RhdGUubmFtZSwgcGFyYW1zKTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGV4YWN0TWF0Y2goc3RhdGUsIHBhcmFtcykgeyByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLm5hbWUsIHBhcmFtcyk7IH1cblx0ICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcblx0ICAgICAgICAgICAgICAgIH1dXG5cdCAgICAgICAgfTtcblx0ICAgIH1dO1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcblx0ICAgIC5kaXJlY3RpdmUoJ3VpU3JlZicsIHVpU3JlZk5nMSlcblx0ICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZScsIHVpU3JlZkFjdGl2ZU5nMSlcblx0ICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZUVxJywgdWlTcmVmQWN0aXZlTmcxKVxuXHQgICAgLmRpcmVjdGl2ZSgndWlTdGF0ZScsIHVpU3RhdGVOZzEpO1xuXG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKipcblx0ICogQG5nZG9jIGZpbHRlclxuXHQgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZmlsdGVyOmlzU3RhdGVcblx0ICpcblx0ICogQHJlcXVpcmVzIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGVcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFRyYW5zbGF0ZXMgdG8ge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kc3RhdGUjbWV0aG9kc19pcyAkc3RhdGUuaXMoXCJzdGF0ZU5hbWVcIil9LlxuXHQgKi9cblx0JElzU3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5cdGZ1bmN0aW9uICRJc1N0YXRlRmlsdGVyKCRzdGF0ZSkge1xuXHQgICAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gJHN0YXRlLmlzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIGlzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG5cdCAgICByZXR1cm4gaXNGaWx0ZXI7XG5cdH1cblx0ZXhwb3J0cy4kSXNTdGF0ZUZpbHRlciA9ICRJc1N0YXRlRmlsdGVyO1xuXHQvKipcblx0ICogQG5nZG9jIGZpbHRlclxuXHQgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZmlsdGVyOmluY2x1ZGVkQnlTdGF0ZVxuXHQgKlxuXHQgKiBAcmVxdWlyZXMgdWkucm91dGVyLnN0YXRlLiRzdGF0ZVxuXHQgKlxuXHQgKiBAZGVzY3JpcHRpb25cblx0ICogVHJhbnNsYXRlcyB0byB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiRzdGF0ZSNtZXRob2RzX2luY2x1ZGVzICRzdGF0ZS5pbmNsdWRlcygnZnVsbE9yUGFydGlhbFN0YXRlTmFtZScpfS5cblx0ICovXG5cdCRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIuJGluamVjdCA9IFsnJHN0YXRlJ107XG5cdGZ1bmN0aW9uICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG5cdCAgICB2YXIgaW5jbHVkZXNGaWx0ZXIgPSBmdW5jdGlvbiAoc3RhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuXHQgICAgICAgIHJldHVybiAkc3RhdGUuaW5jbHVkZXMoc3RhdGUsIHBhcmFtcywgb3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgaW5jbHVkZXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcblx0ICAgIHJldHVybiBpbmNsdWRlc0ZpbHRlcjtcblx0fVxuXHRleHBvcnRzLiRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIgPSAkSW5jbHVkZWRCeVN0YXRlRmlsdGVyO1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcblx0ICAgIC5maWx0ZXIoJ2lzU3RhdGUnLCAkSXNTdGF0ZUZpbHRlcilcblx0ICAgIC5maWx0ZXIoJ2luY2x1ZGVkQnlTdGF0ZScsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIpO1xuXG5cbi8qKiovIH0sXG4vKiA1OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyoqIEBtb2R1bGUgbmcxX2RpcmVjdGl2ZXMgKi8gLyoqIGZvciB0eXBlZG9jICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgcHJlZGljYXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHRyYWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIHJlamVjdEZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgaG9mXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgc3RyaW5nc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0LyoqXG5cdCAqIGB1aS12aWV3YDogQSB2aWV3cG9ydCBkaXJlY3RpdmUgd2hpY2ggaXMgZmlsbGVkIGluIGJ5IGEgdmlldyBmcm9tIHRoZSBhY3RpdmUgc3RhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBBIHZpZXcgbmFtZS4gVGhlIG5hbWUgc2hvdWxkIGJlIHVuaXF1ZSBhbW9uZ3N0IHRoZSBvdGhlciB2aWV3cyBpbiB0aGVcblx0ICogc2FtZSBzdGF0ZS4gWW91IGNhbiBoYXZlIHZpZXdzIG9mIHRoZSBzYW1lIG5hbWUgdGhhdCBsaXZlIGluIGRpZmZlcmVudCBzdGF0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gYXV0b3Njcm9sbCBJdCBhbGxvd3MgeW91IHRvIHNldCB0aGUgc2Nyb2xsIGJlaGF2aW9yIG9mIHRoZSBicm93c2VyIHdpbmRvd1xuXHQgKiB3aGVuIGEgdmlldyBpcyBwb3B1bGF0ZWQuIEJ5IGRlZmF1bHQsICRhbmNob3JTY3JvbGwgaXMgb3ZlcnJpZGRlbiBieSB1aS1yb3V0ZXIncyBjdXN0b20gc2Nyb2xsXG5cdCAqIHNlcnZpY2UsIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbH0uIFRoaXMgY3VzdG9tIHNlcnZpY2UgbGV0J3MgeW91XG5cdCAqIHNjcm9sbCB1aS12aWV3IGVsZW1lbnRzIGludG8gdmlldyB3aGVuIHRoZXkgYXJlIHBvcHVsYXRlZCBkdXJpbmcgYSBzdGF0ZSBhY3RpdmF0aW9uLlxuXHQgKlxuXHQgKiAqTm90ZTogVG8gcmV2ZXJ0IGJhY2sgdG8gb2xkIFtgJGFuY2hvclNjcm9sbGBdKGh0dHA6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nLiRhbmNob3JTY3JvbGwpXG5cdCAqIGZ1bmN0aW9uYWxpdHksIGNhbGwgYCR1aVZpZXdTY3JvbGxQcm92aWRlci51c2VBbmNob3JTY3JvbGwoKWAuKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9ubG9hZCBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW5ldmVyIHRoZSB2aWV3IHVwZGF0ZXMuXG5cdCAqXG5cdCAqIEEgdmlldyBjYW4gYmUgdW5uYW1lZCBvciBuYW1lZC5cblx0ICogQGV4YW1wbGVcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8IS0tIFVubmFtZWQgLS0+XG5cdCAqIDxkaXYgdWktdmlldz48L2Rpdj5cblx0ICpcblx0ICogPCEtLSBOYW1lZCAtLT5cblx0ICogPGRpdiB1aS12aWV3PVwidmlld05hbWVcIj48L2Rpdj5cblx0ICogYGBgXG5cdCAqXG5cdCAqIFlvdSBjYW4gb25seSBoYXZlIG9uZSB1bm5hbWVkIHZpZXcgd2l0aGluIGFueSB0ZW1wbGF0ZSAob3Igcm9vdCBodG1sKS4gSWYgeW91IGFyZSBvbmx5IHVzaW5nIGFcblx0ICogc2luZ2xlIHZpZXcgYW5kIGl0IGlzIHVubmFtZWQgdGhlbiB5b3UgY2FuIHBvcHVsYXRlIGl0IGxpa2Ugc286XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG5cdCAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG5cdCAqICAgdGVtcGxhdGU6IFwiPGgxPkhFTExPITwvaDE+XCJcblx0ICogfSlcblx0ICogYGBgXG5cdCAqXG5cdCAqIFRoZSBhYm92ZSBpcyBhIGNvbnZlbmllbnQgc2hvcnRjdXQgZXF1aXZhbGVudCB0byBzcGVjaWZ5aW5nIHlvdXIgdmlldyBleHBsaWNpdGx5IHdpdGggdGhlIHtAbGluayB1aS5yb3V0ZXIuc3RhdGUuJHN0YXRlUHJvdmlkZXIjdmlld3MgYHZpZXdzYH1cblx0ICogY29uZmlnIHByb3BlcnR5LCBieSBuYW1lLCBpbiB0aGlzIGNhc2UgYW4gZW1wdHkgbmFtZTpcblx0ICogYGBganNcblx0ICpcblx0ICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcblx0ICogICB2aWV3czoge1xuXHQgKiAgICAgXCJcIjoge1xuXHQgKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuXHQgKiAgICAgfVxuXHQgKiAgIH1cblx0ICogfSlcblx0ICogYGBgXG5cdCAqXG5cdCAqIEJ1dCB0eXBpY2FsbHkgeW91J2xsIG9ubHkgdXNlIHRoZSB2aWV3cyBwcm9wZXJ0eSBpZiB5b3UgbmFtZSB5b3VyIHZpZXcgb3IgaGF2ZSBtb3JlIHRoYW4gb25lIHZpZXdcblx0ICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsXG5cdCAqIGJ1dCB5b3UgY291bGQgaWYgeW91IHdhbnRlZCwgbGlrZSBzbzpcblx0ICpcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8ZGl2IHVpLXZpZXc9XCJtYWluXCI+PC9kaXY+XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBgYGBqc1xuXHQgKlxuXHQgKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuXHQgKiAgIHZpZXdzOiB7XG5cdCAqICAgICBcIm1haW5cIjoge1xuXHQgKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuXHQgKiAgICAgfVxuXHQgKiAgIH1cblx0ICogfSlcblx0ICogYGBgXG5cdCAqXG5cdCAqIFJlYWxseSB0aG91Z2gsIHlvdSdsbCB1c2Ugdmlld3MgdG8gc2V0IHVwIG11bHRpcGxlIHZpZXdzOlxuXHQgKiBgYGBodG1sXG5cdCAqXG5cdCAqIDxkaXYgdWktdmlldz48L2Rpdj5cblx0ICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj5cblx0ICogPGRpdiB1aS12aWV3PVwiZGF0YVwiPjwvZGl2PlxuXHQgKiBgYGBcblx0ICpcblx0ICogYGBganNcblx0ICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoXCJob21lXCIsIHtcblx0ICogICB2aWV3czoge1xuXHQgKiAgICAgXCJcIjoge1xuXHQgKiAgICAgICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuXHQgKiAgICAgfSxcblx0ICogICAgIFwiY2hhcnRcIjoge1xuXHQgKiAgICAgICB0ZW1wbGF0ZTogXCI8Y2hhcnRfdGhpbmcvPlwiXG5cdCAqICAgICB9LFxuXHQgKiAgICAgXCJkYXRhXCI6IHtcblx0ICogICAgICAgdGVtcGxhdGU6IFwiPGRhdGFfdGhpbmcvPlwiXG5cdCAqICAgICB9XG5cdCAqICAgfVxuXHQgKiB9KVxuXHQgKiBgYGBcblx0ICpcblx0ICogRXhhbXBsZXMgZm9yIGBhdXRvc2Nyb2xsYDpcblx0ICpcblx0ICogYGBgaHRtbFxuXHQgKlxuXHQgKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIG5vIGV4cHJlc3Npb24sXG5cdCAqICAgICAgdGhlbiBzY3JvbGwgdWktdmlldyBpbnRvIHZpZXcgLS0+XG5cdCAqIDx1aS12aWV3IGF1dG9zY3JvbGwvPlxuXHQgKlxuXHQgKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIHZhbGlkIGV4cHJlc3Npb24sXG5cdCAqICAgICAgdGhlbiBzY3JvbGwgdWktdmlldyBpbnRvIHZpZXcgaWYgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZSAtLT5cblx0ICogPHVpLXZpZXcgYXV0b3Njcm9sbD0ndHJ1ZScvPlxuXHQgKiA8dWktdmlldyBhdXRvc2Nyb2xsPSdmYWxzZScvPlxuXHQgKiA8dWktdmlldyBhdXRvc2Nyb2xsPSdzY29wZVZhcmlhYmxlJy8+XG5cdCAqIGBgYFxuXHQgKlxuXHQgKiBSZXNvbHZlIGRhdGE6XG5cdCAqXG5cdCAqIFRoZSByZXNvbHZlZCBkYXRhIGZyb20gdGhlIHN0YXRlJ3MgYHJlc29sdmVgIGJsb2NrIGlzIHBsYWNlZCBvbiB0aGUgc2NvcGUgYXMgYCRyZXNvbHZlYCAodGhpc1xuXHQgKiBjYW4gYmUgY3VzdG9taXplZCB1c2luZyBbW1ZpZXdEZWNsYXJhdGlvbi5yZXNvbHZlQXNdXSkuICBUaGlzIGNhbiBiZSB0aGVuIGFjY2Vzc2VkIGZyb20gdGhlIHRlbXBsYXRlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgd2hlbiBgY29udHJvbGxlckFzYCBpcyBiZWluZyB1c2VkLCBgJHJlc29sdmVgIGlzIHNldCBvbiB0aGUgY29udHJvbGxlciBpbnN0YW5jZSAqYWZ0ZXIqIHRoZVxuXHQgKiBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZC4gIFRoZSBgJG9uSW5pdCgpYCBob29rIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gY29kZSB3aGljaFxuXHQgKiBkZXBlbmRzIG9uIGAkcmVzb2x2ZWAgZGF0YS5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogYGBganNcblx0ICpcblx0ICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG5cdCAqICAgdGVtcGxhdGU6ICc8bXktY29tcG9uZW50IHVzZXI9XCIkcmVzb2x2ZS51c2VyXCI+PC9teS1jb21wb25lbnQ+Jyxcblx0ICogICByZXNvbHZlOiB7XG5cdCAqICAgICB1c2VyOiBmdW5jdGlvbihVc2VyU2VydmljZSkgeyByZXR1cm4gVXNlclNlcnZpY2UuZmV0Y2hVc2VyKCk7IH1cblx0ICogICB9XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdHZhciB1aVZpZXdOZzEgPSBbJyR2aWV3JywgJyRhbmltYXRlJywgJyR1aVZpZXdTY3JvbGwnLCAnJGludGVycG9sYXRlJywgJyRxJyxcblx0ICAgIGZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlKCR2aWV3LCAkYW5pbWF0ZSwgJHVpVmlld1Njcm9sbCwgJGludGVycG9sYXRlLCAkcSkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQsIGNiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCkudGhlbihjYik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50LCBjYik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjb25maWdzRXF1YWwoY29uZmlnMSwgY29uZmlnMikge1xuXHQgICAgICAgICAgICByZXR1cm4gY29uZmlnMSA9PT0gY29uZmlnMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJvb3REYXRhID0ge1xuXHQgICAgICAgICAgICAkY2ZnOiB7IHZpZXdEZWNsOiB7ICRjb250ZXh0OiAkdmlldy5yb290Q29udGV4dCgpIH0gfSxcblx0ICAgICAgICAgICAgJHVpVmlldzoge31cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHZhciBkaXJlY3RpdmUgPSB7XG5cdCAgICAgICAgICAgIGNvdW50OiAwLFxuXHQgICAgICAgICAgICByZXN0cmljdDogJ0VDQScsXG5cdCAgICAgICAgICAgIHRlcm1pbmFsOiB0cnVlLFxuXHQgICAgICAgICAgICBwcmlvcml0eTogNDAwLFxuXHQgICAgICAgICAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG5cdCAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0RWxlbWVudCwgdEF0dHJzLCAkdHJhbnNjbHVkZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgJGVsZW1lbnQsIGF0dHJzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRWwsIGN1cnJlbnRFbCwgY3VycmVudFNjb3BlLCB1bnJlZ2lzdGVyLCBvbmxvYWRFeHAgPSBhdHRycy5vbmxvYWQgfHwgJycsIGF1dG9TY3JvbGxFeHAgPSBhdHRycy5hdXRvc2Nyb2xsLCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGF0dHJzLCBzY29wZSksIHZpZXdDb25maWcgPSB1bmRlZmluZWQsIGluaGVyaXRlZCA9ICRlbGVtZW50LmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKSB8fCByb290RGF0YSwgbmFtZSA9ICRpbnRlcnBvbGF0ZShhdHRycy51aVZpZXcgfHwgYXR0cnMubmFtZSB8fCAnJykoc2NvcGUpIHx8ICckZGVmYXVsdCc7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZVVJVmlldyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRpcmVjdGl2ZS5jb3VudCsrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcW46IGluaGVyaXRlZC4kdWlWaWV3LmZxbiA/IGluaGVyaXRlZC4kdWlWaWV3LmZxbiArIFwiLlwiICsgbmFtZSA6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogbnVsbCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnVXBkYXRlZDogY29uZmlnVXBkYXRlZENhbGxiYWNrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY3JlYXRpb25Db250ZXh0KCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvZl8xLnBhcnNlKCckY2ZnLnZpZXdEZWNsLiRjb250ZXh0JykoaW5oZXJpdGVkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVVpVmlld0V2ZW50KFwiTGlua2luZ1wiLCBhY3RpdmVVSVZpZXcpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayhjb25maWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVWlWaWV3Q29uZmlnVXBkYXRlZChhY3RpdmVVSVZpZXcsIGNvbmZpZyAmJiBjb25maWcudmlld0RlY2wgJiYgY29uZmlnLnZpZXdEZWNsLiRjb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmlld0NvbmZpZyA9IGNvbmZpZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldyhjb25maWcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5kYXRhKCckdWlWaWV3JywgeyAkdWlWaWV3OiBhY3RpdmVVSVZpZXcgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlldygpO1xuXHQgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIgPSAkdmlldy5yZWdpc3RlclVpVmlldyhhY3RpdmVVSVZpZXcpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNjb3BlLiRvbihcIiRkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVVpVmlld0V2ZW50KFwiRGVzdHJveWluZy9VbnJlZ2lzdGVyaW5nXCIsIGFjdGl2ZVVJVmlldyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwTGFzdFZpZXcoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0VsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVWlWaWV3RXZlbnQoXCJSZW1vdmluZyAocHJldmlvdXMpIGVsXCIsIHByZXZpb3VzRWwuZGF0YSgnJHVpVmlldycpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3BlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVWlWaWV3RXZlbnQoXCJEZXN0cm95aW5nIHNjb3BlXCIsIGFjdGl2ZVVJVmlldyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGRlc3Ryb3koKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF92aWV3RGF0YV8xID0gY3VycmVudEVsLmRhdGEoJyR1aVZpZXcnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VVaVZpZXdFdmVudChcIkFuaW1hdGUgb3V0XCIsIF92aWV3RGF0YV8xKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmxlYXZlKGN1cnJlbnRFbCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3RGF0YV8xLiQkYW5pbUxlYXZlLnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNFbCA9IGN1cnJlbnRFbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhjb25maWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVWlWaWV3U2NvcGVDcmVhdGVkKGFjdGl2ZVVJVmlldywgbmV3U2NvcGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbUVudGVyID0gJHEuZGVmZXIoKSwgYW5pbUxlYXZlID0gJHEuZGVmZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR1aVZpZXdEYXRhID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNmZzogY29uZmlnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHVpVmlldzogYWN0aXZlVUlWaWV3LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1FbnRlcjogYW5pbUVudGVyLnByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYW5pbUxlYXZlOiBhbmltTGVhdmUucHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkYW5pbUxlYXZlOiBhbmltTGVhdmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmVudGVyKGNsb25lLmRhdGEoJyR1aVZpZXcnLCAkdWlWaWV3RGF0YSksICRlbGVtZW50LCBmdW5jdGlvbiBvblVpVmlld0VudGVyKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1FbnRlci5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRBbmltYXRpb25FbmRlZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR1aVZpZXdTY3JvbGwoY2xvbmUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cExhc3RWaWV3KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWwgPSBjbG9uZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG5ld1Njb3BlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQG5nZG9jIGV2ZW50XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlldyMkdmlld0NvbnRlbnRMb2FkZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50T2YgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpcmVkIG9uY2UgdGhlIHZpZXcgaXMgKipsb2FkZWQqKiwgKmFmdGVyKiB0aGUgRE9NIGlzIHJlbmRlcmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgRXZlbnQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkZWQnLCBjb25maWcgfHwgdmlld0NvbmZpZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZXZhbChvbmxvYWRFeHApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBkaXJlY3RpdmU7XG5cdCAgICB9XTtcblx0JFZpZXdEaXJlY3RpdmVGaWxsLiRpbmplY3QgPSBbJyRjb21waWxlJywgJyRjb250cm9sbGVyJywgJyR0cmFuc2l0aW9ucycsICckdmlldycsICckdGltZW91dCddO1xuXHQvKiogQGhpZGRlbiAqL1xuXHRmdW5jdGlvbiAkVmlld0RpcmVjdGl2ZUZpbGwoJGNvbXBpbGUsICRjb250cm9sbGVyLCAkdHJhbnNpdGlvbnMsICR2aWV3LCAkdGltZW91dCkge1xuXHQgICAgdmFyIGdldENvbnRyb2xsZXJBcyA9IGhvZl8xLnBhcnNlKCd2aWV3RGVjbC5jb250cm9sbGVyQXMnKTtcblx0ICAgIHZhciBnZXRSZXNvbHZlQXMgPSBob2ZfMS5wYXJzZSgndmlld0RlY2wucmVzb2x2ZUFzJyk7XG5cdCAgICB2YXIgZ2V0UmVzb2x2ZUNvbnRleHQgPSBob2ZfMS5wYXJzZSgnbm9kZS5yZXNvbHZlQ29udGV4dCcpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICByZXN0cmljdDogJ0VDQScsXG5cdCAgICAgICAgcHJpb3JpdHk6IC00MDAsXG5cdCAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBpbml0aWFsID0gdEVsZW1lbnQuaHRtbCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCAkZWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKCckdWlWaWV3Jyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWRhdGEpXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNmZyA9IGRhdGEuJGNmZyB8fCB7IHZpZXdEZWNsOiB7fSB9O1xuXHQgICAgICAgICAgICAgICAgJGVsZW1lbnQuaHRtbChjZmcudGVtcGxhdGUgfHwgaW5pdGlhbCk7XG5cdCAgICAgICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVWlWaWV3RmlsbChkYXRhLiR1aVZpZXcsICRlbGVtZW50Lmh0bWwoKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjZmcuY29udHJvbGxlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyQXMgPSBnZXRDb250cm9sbGVyQXMoY2ZnKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQXMgPSBnZXRSZXNvbHZlQXMoY2ZnKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQ3R4ID0gZ2V0UmVzb2x2ZUNvbnRleHQoY2ZnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBsb2NhbHMgPSByZXNvbHZlQ3R4ICYmIGNvbW1vbl8xLm1hcChyZXNvbHZlQ3R4LmdldFJlc29sdmFibGVzKCksIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmRhdGE7IH0pO1xuXHQgICAgICAgICAgICAgICAgc2NvcGVbcmVzb2x2ZUFzXSA9IGxvY2Fscztcblx0ICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJbnN0YW5jZSA9ICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGNvbW1vbl8xLmV4dGVuZCh7fSwgbG9jYWxzLCB7ICRzY29wZTogc2NvcGUsICRlbGVtZW50OiAkZWxlbWVudCB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXJBcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdID0gY29udHJvbGxlckluc3RhbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtjb250cm9sbGVyQXNdW3Jlc29sdmVBc10gPSBsb2NhbHM7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFVzZSAkdmlldyBzZXJ2aWNlIGFzIGEgY2VudHJhbCBwb2ludCBmb3IgcmVnaXN0ZXJpbmcgY29tcG9uZW50LWxldmVsIGhvb2tzXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2hlbiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkLCB0ZWxsIHRoZSAkdmlldyBzZXJ2aWNlLCBzbyBpdCBjYW4gaW52b2tlIGhvb2tzXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gJHZpZXcuY29tcG9uZW50TG9hZGVkKGNvbnRyb2xsZXJJbnN0YW5jZSwgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2NvcGUuJG9uKCckZGVzdHJveScsICgpID0+ICR2aWV3LmNvbXBvbmVudFVubG9hZGVkKGNvbnRyb2xsZXJJbnN0YW5jZSwgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICRlbGVtZW50LmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5jaGlsZHJlbigpLmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcblx0ICAgICAgICAgICAgICAgICAgICByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsIHNjb3BlLCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNvbXBvbmVudCB0byBhcHBlYXIgaW4gdGhlIERPTVxuXHQgICAgICAgICAgICAgICAgaWYgKGNmZy52aWV3RGVjbC5jb21wb25lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY21wXzEgPSBjZmcudmlld0RlY2wuY29tcG9uZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBrZWJvYk5hbWVfMSA9IHN0cmluZ3NfMS5rZWJvYlN0cmluZyhjbXBfMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdldENvbXBvbmVudENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVFbCA9IFtdLnNsaWNlLmNhbGwoJGVsZW1lbnRbMF0uY2hpbGRyZW4pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGtlYm9iTmFtZV8xOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUVsICYmIGFuZ3VsYXIuZWxlbWVudChkaXJlY3RpdmVFbCkuZGF0YShcIiRcIiArIGNtcF8xICsgXCJDb250cm9sbGVyXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlcmVnaXN0ZXJXYXRjaF8xID0gc2NvcGUuJHdhdGNoKGdldENvbXBvbmVudENvbnRyb2xsZXIsIGZ1bmN0aW9uIChjdHJsSW5zdGFuY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsSW5zdGFuY2UpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbGxlckNhbGxiYWNrcygkdHJhbnNpdGlvbnMsIGN0cmxJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJXYXRjaF8xKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBsaW5rKHNjb3BlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9XG5cdC8qKiBAaGlkZGVuICovXG5cdHZhciBoYXNDb21wb25lbnRJbXBsID0gdHlwZW9mIGFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXInKVsnY29tcG9uZW50J10gPT09ICdmdW5jdGlvbic7XG5cdC8qKiBAaGlkZGVuIFRPRE86IG1vdmUgdGhlc2UgY2FsbGJhY2tzIHRvICR2aWV3IGFuZC9vciBgL2hvb2tzL2NvbXBvbmVudHMudHNgIG9yIHNvbWV0aGluZyAqL1xuXHRmdW5jdGlvbiByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHRyYW5zaXRpb25zLCBjb250cm9sbGVySW5zdGFuY2UsICRzY29wZSwgY2ZnKSB7XG5cdCAgICAvLyBDYWxsICRvbkluaXQoKSBBU0FQXG5cdCAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQpICYmICEoY2ZnLnZpZXdEZWNsLmNvbXBvbmVudCAmJiBoYXNDb21wb25lbnRJbXBsKSlcblx0ICAgICAgICBjb250cm9sbGVySW5zdGFuY2UuJG9uSW5pdCgpO1xuXHQgICAgdmFyIGhvb2tPcHRpb25zID0geyBiaW5kOiBjb250cm9sbGVySW5zdGFuY2UgfTtcblx0ICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25QYXJhbXNDaGFuZ2Vcblx0ICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihjb250cm9sbGVySW5zdGFuY2UudWlPblBhcmFtc0NoYW5nZWQpKSB7XG5cdCAgICAgICAgLy8gRmlyZSBjYWxsYmFjayBvbiBhbnkgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG5cdCAgICAgICAgdmFyIHBhcmFtc1VwZGF0ZWRfMSA9IGZ1bmN0aW9uICgkdHJhbnNpdGlvbiQpIHtcblx0ICAgICAgICAgICAgdmFyIGN0eCA9IGNmZy5ub2RlLnJlc29sdmVDb250ZXh0O1xuXHQgICAgICAgICAgICB2YXIgdmlld0NyZWF0aW9uVHJhbnMgPSBjdHguZ2V0UmVzb2x2YWJsZXMoKVsnJHRyYW5zaXRpb24kJ10uZGF0YTtcblx0ICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIGlzIHRoZSBzYW1lIGFzIHRoZSB2aWV3IHdhcyBjcmVhdGVkIHdpdGhpbi5cblx0ICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgJHRyYW5zaXRpb24kIHdpbGwgZXhpdCB0aGUgc3RhdGUgdGhlIHZpZXcgaXMgZm9yLlxuXHQgICAgICAgICAgICBpZiAoJHRyYW5zaXRpb24kID09PSB2aWV3Q3JlYXRpb25UcmFucyB8fCAkdHJhbnNpdGlvbiQuZXhpdGluZygpLmluZGV4T2YoY2ZnLm5vZGUuc3RhdGUuc2VsZikgIT09IC0xKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB2YXIgdG9QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKFwidG9cIik7XG5cdCAgICAgICAgICAgIHZhciBmcm9tUGFyYW1zID0gJHRyYW5zaXRpb24kLnBhcmFtcyhcImZyb21cIik7XG5cdCAgICAgICAgICAgIHZhciB0b1NjaGVtYSA9ICR0cmFuc2l0aW9uJC50cmVlQ2hhbmdlcygpLnRvLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcblx0ICAgICAgICAgICAgdmFyIGZyb21TY2hlbWEgPSAkdHJhbnNpdGlvbiQudHJlZUNoYW5nZXMoKS5mcm9tLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYXJhbVNjaGVtYTsgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcblx0ICAgICAgICAgICAgLy8gRmluZCB0aGUgdG8gcGFyYW1zIHRoYXQgaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIHRoYW4gdGhlIGZyb20gcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBjaGFuZ2VkVG9QYXJhbXMgPSB0b1NjaGVtYS5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZnJvbVNjaGVtYS5pbmRleE9mKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpZHggPT09IC0xIHx8ICFmcm9tU2NoZW1hW2lkeF0udHlwZS5lcXVhbHModG9QYXJhbXNbcGFyYW0uaWRdLCBmcm9tUGFyYW1zW3BhcmFtLmlkXSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2FsbGJhY2sgaWYgYSB0byBwYXJhbSBoYXMgY2hhbmdlZCBvciBpcyBuZXdcblx0ICAgICAgICAgICAgaWYgKGNoYW5nZWRUb1BhcmFtcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkS2V5c18xID0gY2hhbmdlZFRvUGFyYW1zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSk7XG5cdCAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHBhcmFtcyB0byBvbmx5IGNoYW5nZWQvbmV3IHRvIHBhcmFtcy4gIGAkdHJhbnNpdGlvbiQucGFyYW1zKClgIG1heSBiZSB1c2VkIHRvIGdldCBhbGwgcGFyYW1zLlxuXHQgICAgICAgICAgICAgICAgY29udHJvbGxlckluc3RhbmNlLnVpT25QYXJhbXNDaGFuZ2VkKGNvbW1vbl8xLmZpbHRlcih0b1BhcmFtcywgZnVuY3Rpb24gKHZhbCwga2V5KSB7IHJldHVybiBjaGFuZ2VkS2V5c18xLmluZGV4T2Yoa2V5KSAhPT0gLTE7IH0pLCAkdHJhbnNpdGlvbiQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vblN1Y2Nlc3Moe30sIFsnJHRyYW5zaXRpb24kJywgcGFyYW1zVXBkYXRlZF8xXSksIGhvb2tPcHRpb25zKTtcblx0ICAgICAgICAvLyBGaXJlIGNhbGxiYWNrIG9uIGFueSBJR05PUkVEIHRyYW5zaXRpb25cblx0ICAgICAgICB2YXIgb25EeW5hbWljID0gZnVuY3Rpb24gKCRlcnJvciQsICR0cmFuc2l0aW9uJCkge1xuXHQgICAgICAgICAgICBpZiAoJGVycm9yJC50eXBlID09PSByZWplY3RGYWN0b3J5XzEuUmVqZWN0VHlwZS5JR05PUkVEKVxuXHQgICAgICAgICAgICAgICAgcGFyYW1zVXBkYXRlZF8xKCR0cmFuc2l0aW9uJCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vbkVycm9yKHt9LCBbJyRlcnJvciQnLCAnJHRyYW5zaXRpb24kJywgb25EeW5hbWljXSksIGhvb2tPcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3IgdWlDYW5FeGl0XG5cdCAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24oY29udHJvbGxlckluc3RhbmNlLnVpQ2FuRXhpdCkpIHtcblx0ICAgICAgICB2YXIgY3JpdGVyaWEgPSB7IGV4aXRpbmc6IGNmZy5ub2RlLnN0YXRlLm5hbWUgfTtcblx0ICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vbkJlZm9yZShjcml0ZXJpYSwgY29udHJvbGxlckluc3RhbmNlLnVpQ2FuRXhpdCwgaG9va09wdGlvbnMpKTtcblx0ICAgIH1cblx0fVxuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCB1aVZpZXdOZzEpO1xuXHRhbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykuZGlyZWN0aXZlKCd1aVZpZXcnLCAkVmlld0RpcmVjdGl2ZUZpbGwpO1xuXG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8qKlxuXHQgKiBAbmdkb2Mgb2JqZWN0XG5cdCAqIEBuYW1lIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXJcblx0ICpcblx0ICogQGRlc2NyaXB0aW9uXG5cdCAqIFByb3ZpZGVyIHRoYXQgcmV0dXJucyB0aGUge0BsaW5rIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsfSBzZXJ2aWNlIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gJFZpZXdTY3JvbGxQcm92aWRlcigpIHtcblx0ICAgIHZhciB1c2VBbmNob3JTY3JvbGwgPSBmYWxzZTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIGZ1bmN0aW9uXG5cdCAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuJHVpVmlld1Njcm9sbFByb3ZpZGVyI3VzZUFuY2hvclNjcm9sbFxuXHQgICAgICogQG1ldGhvZE9mIHVpLnJvdXRlci5zdGF0ZS4kdWlWaWV3U2Nyb2xsUHJvdmlkZXJcblx0ICAgICAqXG5cdCAgICAgKiBAZGVzY3JpcHRpb25cblx0ICAgICAqIFJldmVydHMgYmFjayB0byB1c2luZyB0aGUgY29yZSBbYCRhbmNob3JTY3JvbGxgXShodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9uZy4kYW5jaG9yU2Nyb2xsKSBzZXJ2aWNlIGZvclxuXHQgICAgICogc2Nyb2xsaW5nIGJhc2VkIG9uIHRoZSB1cmwgYW5jaG9yLlxuXHQgICAgICovXG5cdCAgICB0aGlzLnVzZUFuY2hvclNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB1c2VBbmNob3JTY3JvbGwgPSB0cnVlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHQgICAgICogQG5nZG9jIG9iamVjdFxuXHQgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGxcblx0ICAgICAqXG5cdCAgICAgKiBAcmVxdWlyZXMgJGFuY2hvclNjcm9sbFxuXHQgICAgICogQHJlcXVpcmVzICR0aW1lb3V0XG5cdCAgICAgKlxuXHQgICAgICogQGRlc2NyaXB0aW9uXG5cdCAgICAgKiBXaGVuIGNhbGxlZCB3aXRoIGEganFMaXRlIGVsZW1lbnQsIGl0IHNjcm9sbHMgdGhlIGVsZW1lbnQgaW50byB2aWV3IChhZnRlciBhXG5cdCAgICAgKiBgJHRpbWVvdXRgIHNvIHRoZSBET00gaGFzIHRpbWUgdG8gcmVmcmVzaCkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgeW91IHByZWZlciB0byByZWx5IG9uIGAkYW5jaG9yU2Nyb2xsYCB0byBzY3JvbGwgdGhlIHZpZXcgdG8gdGhlIGFuY2hvcixcblx0ICAgICAqIHRoaXMgY2FuIGJlIGVuYWJsZWQgYnkgY2FsbGluZyB7QGxpbmsgdWkucm91dGVyLnN0YXRlLiR1aVZpZXdTY3JvbGxQcm92aWRlciNtZXRob2RzX3VzZUFuY2hvclNjcm9sbCBgJHVpVmlld1Njcm9sbFByb3ZpZGVyLnVzZUFuY2hvclNjcm9sbCgpYH0uXG5cdCAgICAgKi9cblx0ICAgIHRoaXMuJGdldCA9IFsnJGFuY2hvclNjcm9sbCcsICckdGltZW91dCcsIGZ1bmN0aW9uICgkYW5jaG9yU2Nyb2xsLCAkdGltZW91dCkge1xuXHQgICAgICAgICAgICBpZiAodXNlQW5jaG9yU2Nyb2xsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvclNjcm9sbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICRlbGVtZW50WzBdLnNjcm9sbEludG9WaWV3KCk7XG5cdCAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfV07XG5cdH1cblx0YW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLnByb3ZpZGVyKCckdWlWaWV3U2Nyb2xsJywgJFZpZXdTY3JvbGxQcm92aWRlcik7XG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ndWxhci11aS1yb3V0ZXIuanMubWFwXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXItdWktcm91dGVyL3JlbGVhc2UvYW5ndWxhci11aS1yb3V0ZXIuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIHZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xuLy8gcmVxdWlyZSgnYW5ndWxhci11aS1yb3V0ZXInKTtcblxudmFyIGdWZXJzaW9uID0gXCIwLjAuMVI2XCI7XG5cbmZ1bmN0aW9uIHJlZGlyZWN0Tm9uU1NMKHVybCkge1xuICAgIGlmKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnICAmJiB1cmwudHJpbSgpLmluZGV4T2YoJ2xvY2FsaG9zdCcpID09IC0xICYmIHVybC50cmltKCkuc3RhcnRzV2l0aCgnaHR0cDovLycpKSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT0gXCJodHRwczpcIilcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCJodHRwczpcIiArIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnN1YnN0cmluZyh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wubGVuZ3RoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTU0wodXJsKSB7XG4gICAgaWYodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcgICYmIHVybC50cmltKCkuaW5kZXhPZignbG9jYWxob3N0JykgPT0gLTEgJiYgdXJsLnRyaW0oKS5zdGFydHNXaXRoKCdodHRwOi8vJykpIHtcbiAgICAgICAgdmFyIHJldCA9IHVybC50cmltKCkucmVwbGFjZSgnaHR0cDovLycsICdodHRwczovLycpO1xuICAgICAgICBjb25zb2xlLmxvZygndXJsIGNoYW5nZWQgdG8gU1NMLWJhc2VkIC0+IFsnICsgcmV0ICsgJ10nKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn1cblxucmVkaXJlY3ROb25TU0wod2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG5jb25zb2xlLmxvZygncmVkaXJlY3ROb25TU0wgaW52b2tlZCcpO1xuXG4vL2NvbnNvbGUubG9nKFwiYXBwLmpzIDIgJHN0YXRlOlwiKTtcbi8vY29uc29sZS5sb2coJHN0YXRlKTtcblxuLy89PT0gSldUIGFuZCBuYXZpZ2F0aW9ucyBzdHVmZlxuYW5ndWxhci5tb2R1bGUoJ215QXBwJywgWyd1aS5yb3V0ZXInXSlcbiAgICAuY29uZmlnKFsnJHN0YXRlUHJvdmlkZXInLCAnJHVybFJvdXRlclByb3ZpZGVyJywgZnVuY3Rpb24oJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAgICAkdXJsUm91dGVyUHJvdmlkZXIub3RoZXJ3aXNlKCcvaG9tZScpO1xuXG4gICAgICAgICRzdGF0ZVByb3ZpZGVyXG4gICAgICAgICAgICAuc3RhdGUoJ2hvbWUnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL2hvbWUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnLi4vcmVhY3QvZnVzcnN0YXJ0Lmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LiRzdGF0ZSA9ICRzdGF0ZTsgLy9UT0RPIGhvdyBkbyB3ZSBhdm9pZCBnbG9iYWwgaGVyZT8/PyEhIVxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgU1JTdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KFNSU3RhcnQsIHskc3RhdGU6ICRzdGF0ZX0pLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Itc3RhcnQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0YXRlKCd1cGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiAnL3VwZGF0ZS97aWQ6aW50fScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcuLi9yZWFjdC9mdXNydXBkYXRlLmh0bWwnLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuaW5ib3hJZCA9ICRzdGF0ZVBhcmFtcy5pbmJveElkO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdhcHAuanMgJHN0YXRlUHJvdmlkZXIgdXBkYXRlOiAnLCAkc3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSAkc3RhdGVQYXJhbXMuaWQ7ICAgIC8vJHN0YXRlUGFyYW1zLm9iai5pZDtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYXBwLmpzIGlkID0gWycgKyBpZCArICddJyk7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KFNSVXBkYXRlLCB7JHN0YXRlOiAkc3RhdGUsIGlkOiBpZH0pLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ItdXBkYXRlJykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG9iajogbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3RhdGUoJ2NyZWF0ZScsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJy4uL3JlYWN0L2Z1c3JjcmVhdGUuaHRtbCcsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5pbmJveElkID0gJHN0YXRlUGFyYW1zLmluYm94SWQ7XG4gICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KFNSQ3JlYXRlLCB7JHN0YXRlOiAkc3RhdGV9KSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NyLWNyZWF0ZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgfV0pXG4gICAgLmNvbnRyb2xsZXIoJ01haW5DdHJsJywgWydtYWluU2VydmljZScsJyRzY29wZScsJyRodHRwJywgJyRzdGF0ZScsXG4gICAgICAgIGZ1bmN0aW9uKG1haW5TZXJ2aWNlLCAkc2NvcGUsICRodHRwLCAkY29tcGlsZSwgJHN0YXRlKSB7XG4gICAgICAgICAgICAkc2NvcGUudmVyc2lvbiA9IGdWZXJzaW9uO1xuICAgICAgICAgICAgJHNjb3BlLnN0YXR1cyA9ICdQbGVhc2Ugc2lnbiBpbic7XG4gICAgICAgICAgICAkc2NvcGUuZ3JlZXRpbmcgPSAnV2VsY29tZSEnO1xuICAgICAgICAgICAgJHNjb3BlLnRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICRzY29wZS5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAkc2NvcGUucm9sZVVzZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS5yb2xlQWRtaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICRzY29wZS5yb2xlRm9vID0gZmFsc2U7XG5cbiAgICAgICAgICAgICRzY29wZS5sb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5zdGF0dXMgPSBcIkxvZ2dpbmcgaW4gLi4uXCI7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtYWluU2VydmljZS5sb2dpbigkc2NvcGUudXNlck5hbWUsICRzY29wZS5wYXNzV29yZCkudGhlbihmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgJGh0dHAuZGVmYXVsdHMuaGVhZGVycy5jb21tb24uQXV0aG9yaXphdGlvbiA9ICdCZWFyZXIgJyArIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY2hlY2tSb2xlcygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc3RhdHVzID0gXCJJbnZhbGlkIGxvZ2luLiBQbGVhc2UgdHJ5IGFnYWluLlwiO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZXJyb3IgPSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudXNlck5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnBhc3NXb3JkID0gJyc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRzY29wZS5jaGVja1JvbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbWFpblNlcnZpY2UuaGFzUm9sZSgndXNlcicpLnRoZW4oZnVuY3Rpb24odXNlcikgeyRzY29wZS5yb2xlVXNlciA9IHVzZXJ9KTtcbiAgICAgICAgICAgICAgICBtYWluU2VydmljZS5oYXNSb2xlKCdhZG1pbicpLnRoZW4oZnVuY3Rpb24oYWRtaW4pIHskc2NvcGUucm9sZUFkbWluID0gYWRtaW59KTtcbiAgICAgICAgICAgICAgICBtYWluU2VydmljZS5oYXNSb2xlKCdmb28nKS50aGVuKGZ1bmN0aW9uKGZvbykgeyRzY29wZS5yb2xlRm9vID0gZm9vfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRzY29wZS5sb2dvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUudXNlck5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAkc2NvcGUudG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgICRodHRwLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uLkF1dGhvcml6YXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gXCJpbmRleC5odG1sXCI7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIEpXVCB0b2tlbi5cbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlckpXVFRva2VuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRzY29wZS5sb2dnZWRJbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9ICRzY29wZS50b2tlbjtcbiAgICAgICAgICAgICAgICBpZih0b2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBKV1QgdG9rZW4uXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VySldUVG9rZW4nLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSBcImFwcC5odG1sXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiAhPT0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJHNjb3BlLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZj0nYXBwLmh0bWwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gXSlcbiAgICAuc2VydmljZSgnbWFpblNlcnZpY2UnLCBbJyRodHRwJywgZnVuY3Rpb24oJGh0dHApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvZ2luIDogZnVuY3Rpb24odXNlcm5hbWUsIHB3ZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkaHR0cC5wb3N0KCcvYXBpL3VzZXIvbG9naW4nLCB7bmFtZTogdXNlcm5hbWUsIHBhc3N3b3JkOiBwd2R9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnRva2VuO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFzUm9sZSA6IGZ1bmN0aW9uKHJvbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KCcvYXBpL2p3dC9yb2xlLycgKyByb2xlKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG5cbi8vIENvbW1vbiBkaXJlY3RpdmUgZm9yIEZvY3VzXG5hbmd1bGFyLm1vZHVsZSgnbXlBcHAnKS5kaXJlY3RpdmUoJ2ZvY3VzJywgWyckdGltZW91dCcsXG4gICAgZnVuY3Rpb24gKCR0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdAZm9jdXMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCd0cmlnZ2VyJywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1dXG4pO1xuXG53aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKG1zZywgdXJsLCBsaW5lLCBjb2wsIGVycm9yKSB7XG4gICAgLy8gTm90ZSB0aGF0IGNvbCAmIGVycm9yIGFyZSBuZXcgdG8gdGhlIEhUTUwgNSBzcGVjIGFuZCBtYXkgbm90IGJlXG4gICAgLy8gc3VwcG9ydGVkIGluIGV2ZXJ5IGJyb3dzZXIuICBJdCB3b3JrZWQgZm9yIG1lIGluIENocm9tZS5cbiAgICB2YXIgZXh0cmEgPSAhY29sID8gJycgOiAnXFxuY29sdW1uOiAnICsgY29sO1xuICAgIGV4dHJhICs9ICFlcnJvciA/ICcnIDogJ1xcbmVycm9yOiAnICsgZXJyb3I7XG5cbiAgICAvLyBZb3UgY2FuIHZpZXcgdGhlIGluZm9ybWF0aW9uIGluIGFuIGFsZXJ0IHRvIHNlZSB0aGluZ3Mgd29ya2luZyBsaWtlIHRoaXM6XG4gICAgLy8gYWxlcnQoXCJuL25nL2FwcC5qcyBvbmVycm9yOiBcIiArIG1zZyArIFwiXFxudXJsOiBcIiArIHVybCArIFwiXFxubGluZTogXCIgKyBsaW5lICsgZXh0cmEpO1xuICAgIGNvbnNvbGUuZXJyb3IoXCJuL25nL2FwcC5qcyBvbmVycm9yOiBcIiArIG1zZyArIFwiXFxudXJsOiBcIiArIHVybCArIFwiXFxubGluZTogXCIgKyBsaW5lICsgZXh0cmEpO1xuXG4gICAgLy8gVE9ETzogUmVwb3J0IHRoaXMgZXJyb3IgdmlhIGFqYXggc28geW91IGNhbiBrZWVwIHRyYWNrXG4gICAgLy8gICAgICAgb2Ygd2hhdCBwYWdlcyBoYXZlIEpTIGlzc3Vlc1xuXG4gICAgdmFyIHN1cHByZXNzRXJyb3JBbGVydCA9IHRydWU7XG4gICAgLy8gSWYgeW91IHJldHVybiB0cnVlLCB0aGVuIGVycm9yIGFsZXJ0cyAobGlrZSBpbiBvbGRlciB2ZXJzaW9ucyBvZlxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyKSB3aWxsIGJlIHN1cHByZXNzZWQuXG4gICAgcmV0dXJuIHN1cHByZXNzRXJyb3JBbGVydDtcbn07XG5cbi8vIGFuZ3VsYXIuYm9vdHN0cmFwKGRvY3VtZW50LCBbJ215QXBwJ10pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vbmcvYXBwLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==